# 常见的代码设计模式

## 目录
- [什么是设计模式](#什么是设计模式)
- [设计模式的分类](#设计模式的分类)
- [创建型模式](#创建型模式)
  - [单例模式](#单例模式)
  - [工厂方法模式](#工厂方法模式)
  - [抽象工厂模式](#抽象工厂模式)
  - [建造者模式](#建造者模式)
  - [原型模式](#原型模式)
- [结构型模式](#结构型模式)
  - [适配器模式](#适配器模式)
  - [装饰器模式](#装饰器模式)
  - [代理模式](#代理模式)
  - [外观模式](#外观模式)
  - [桥接模式](#桥接模式)
  - [组合模式](#组合模式)
  - [享元模式](#享元模式)
- [行为型模式](#行为型模式)
  - [策略模式](#策略模式)
  - [观察者模式](#观察者模式)
  - [命令模式](#命令模式)
  - [模板方法模式](#模板方法模式)
  - [迭代器模式](#迭代器模式)
  - [责任链模式](#责任链模式)
  - [状态模式](#状态模式)
- [设计模式的最佳实践](#设计模式的最佳实践)
- [常见问题解答](#常见问题解答)

---

## 什么是设计模式

设计模式(Design Pattern)是软件开发中经过反复使用、多数人知晓、经过分类编目的代码设计经验总结。它代表了最佳实践,被有经验的面向对象软件开发人员所采用。

**设计模式的核心价值:**
- 提供了一套被反复使用的解决方案
- 提高代码的可重用性、可维护性和可扩展性
- 促进团队成员之间的沟通(使用统一的术语)
- 降低系统复杂度,使设计更加灵活

**设计模式的起源:**

设计模式的概念最早由建筑师Christopher Alexander在1977年提出,后来被"四人帮"(Gang of Four, GoF)——Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides引入到软件工程领域,并在1994年出版了经典著作《设计模式:可复用面向对象软件的基础》。

---

## 设计模式的分类

GoF将23种设计模式分为三大类:

### 1. 创建型模式(Creational Patterns)
关注对象的创建过程,将对象的创建和使用分离。
- 单例模式(Singleton)
- 工厂方法模式(Factory Method)
- 抽象工厂模式(Abstract Factory)
- 建造者模式(Builder)
- 原型模式(Prototype)

### 2. 结构型模式(Structural Patterns)
关注类和对象的组合,通过组合获得更强大的结构。
- 适配器模式(Adapter)
- 装饰器模式(Decorator)
- 代理模式(Proxy)
- 外观模式(Facade)
- 桥接模式(Bridge)
- 组合模式(Composite)
- 享元模式(Flyweight)

### 3. 行为型模式(Behavioral Patterns)
关注对象之间的通信和职责分配。
- 策略模式(Strategy)
- 观察者模式(Observer)
- 命令模式(Command)
- 模板方法模式(Template Method)
- 迭代器模式(Iterator)
- 责任链模式(Chain of Responsibility)
- 状态模式(State)
- 访问者模式(Visitor)
- 中介者模式(Mediator)
- 备忘录模式(Memento)
- 解释器模式(Interpreter)

---

## 创建型模式

### 单例模式

**定义:** 确保一个类只有一个实例,并提供一个全局访问点。

**使用场景:**
- 配置管理器
- 数据库连接池
- 日志记录器
- 线程池
- 缓存管理

**实现示例(Java):**

```java
// 饿汉式单例(线程安全)
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    
    private Singleton() {
        // 私有构造函数
    }
    
    public static Singleton getInstance() {
        return INSTANCE;
    }
}

// 懒汉式单例(双重检查锁定)
public class LazySingleton {
    private static volatile LazySingleton instance;
    
    private LazySingleton() {}
    
    public static LazySingleton getInstance() {
        if (instance == null) {
            synchronized (LazySingleton.class) {
                if (instance == null) {
                    instance = new LazySingleton();
                }
            }
        }
        return instance;
    }
}

// 枚举单例(推荐方式)
public enum EnumSingleton {
    INSTANCE;
    
    public void doSomething() {
        // 业务逻辑
    }
}
```

**Python实现:**

```python
class Singleton:
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance

# 使用装饰器实现
def singleton(cls):
    instances = {}
    lock = threading.Lock()
    
    def get_instance(*args, **kwargs):
        if cls not in instances:
            with lock:
                if cls not in instances:
                    instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    
    return get_instance

@singleton
class Database:
    def __init__(self):
        self.connection = "Connected"
```

**优点:**
- 控制实例数量,节省系统资源
- 提供全局访问点
- 延迟实例化(懒汉式)

**缺点:**
- 违反单一职责原则
- 可能成为全局状态,增加模块间耦合
- 多线程环境下需要特别处理

---

### 工厂方法模式

**定义:** 定义一个创建对象的接口,让子类决定实例化哪一个类。

**使用场景:**
- 对象创建逻辑复杂
- 需要根据不同条件创建不同对象
- 框架需要标准化对象创建流程

**实现示例(Java):**

```java
// 产品接口
interface Product {
    void use();
}

// 具体产品A
class ConcreteProductA implements Product {
    @Override
    public void use() {
        System.out.println("Using Product A");
    }
}

// 具体产品B
class ConcreteProductB implements Product {
    @Override
    public void use() {
        System.out.println("Using Product B");
    }
}

// 抽象工厂
abstract class Factory {
    public abstract Product createProduct();
    
    public void operation() {
        Product product = createProduct();
        product.use();
    }
}

// 具体工厂A
class ConcreteFactoryA extends Factory {
    @Override
    public Product createProduct() {
        return new ConcreteProductA();
    }
}

// 具体工厂B
class ConcreteFactoryB extends Factory {
    @Override
    public Product createProduct() {
        return new ConcreteProductB();
    }
}
```

**Python实现:**

```python
from abc import ABC, abstractmethod

class Product(ABC):
    @abstractmethod
    def use(self):
        pass

class ConcreteProductA(Product):
    def use(self):
        return "Using Product A"

class ConcreteProductB(Product):
    def use(self):
        return "Using Product B"

class Factory(ABC):
    @abstractmethod
    def create_product(self) -> Product:
        pass
    
    def operation(self):
        product = self.create_product()
        return product.use()

class ConcreteFactoryA(Factory):
    def create_product(self) -> Product:
        return ConcreteProductA()

class ConcreteFactoryB(Factory):
    def create_product(self) -> Product:
        return ConcreteProductB()
```

**优点:**
- 符合开闭原则,易于扩展
- 将对象创建和使用分离
- 降低耦合度

**缺点:**
- 增加系统复杂度
- 每增加一个产品需要增加对应的工厂类

---

### 抽象工厂模式

**定义:** 提供一个创建一系列相关或相互依赖对象的接口,无需指定它们具体的类。

**使用场景:**
- 系统需要独立于产品的创建、组合和表示
- 系统需要配置多个产品族中的一个
- UI主题切换(不同风格的按钮、文本框等组件)

**实现示例(Java):**

```java
// 抽象产品A
interface Button {
    void render();
}

// 抽象产品B
interface Checkbox {
    void render();
}

// Windows产品族
class WindowsButton implements Button {
    @Override
    public void render() {
        System.out.println("Render Windows Button");
    }
}

class WindowsCheckbox implements Checkbox {
    @Override
    public void render() {
        System.out.println("Render Windows Checkbox");
    }
}

// MacOS产品族
class MacButton implements Button {
    @Override
    public void render() {
        System.out.println("Render Mac Button");
    }
}

class MacCheckbox implements Checkbox {
    @Override
    public void render() {
        System.out.println("Render Mac Checkbox");
    }
}

// 抽象工厂
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// 具体工厂
class WindowsFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new WindowsButton();
    }
    
    @Override
    public Checkbox createCheckbox() {
        return new WindowsCheckbox();
    }
}

class MacFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new MacButton();
    }
    
    @Override
    public Checkbox createCheckbox() {
        return new MacCheckbox();
    }
}
```

**优点:**
- 保证产品族的一致性
- 易于切换产品族
- 符合开闭原则

**缺点:**
- 增加新产品困难,需要修改抽象工厂和所有具体工厂

---

### 建造者模式

**定义:** 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示。

**使用场景:**
- 需要创建的对象有复杂的内部结构
- 对象的创建过程独立于对象的组成部分
- 需要生成的对象有不同的表示

**实现示例(Java):**

```java
// 产品类
class Computer {
    private String cpu;
    private String ram;
    private String storage;
    private String gpu;
    private String motherboard;
    
    // 私有构造函数
    private Computer(Builder builder) {
        this.cpu = builder.cpu;
        this.ram = builder.ram;
        this.storage = builder.storage;
        this.gpu = builder.gpu;
        this.motherboard = builder.motherboard;
    }
    
    // 静态内部建造者类
    public static class Builder {
        // 必选参数
        private final String cpu;
        private final String ram;
        
        // 可选参数
        private String storage = "512GB SSD";
        private String gpu = "Integrated";
        private String motherboard = "Standard";
        
        public Builder(String cpu, String ram) {
            this.cpu = cpu;
            this.ram = ram;
        }
        
        public Builder storage(String storage) {
            this.storage = storage;
            return this;
        }
        
        public Builder gpu(String gpu) {
            this.gpu = gpu;
            return this;
        }
        
        public Builder motherboard(String motherboard) {
            this.motherboard = motherboard;
            return this;
        }
        
        public Computer build() {
            return new Computer(this);
        }
    }
    
    @Override
    public String toString() {
        return "Computer{" +
                "cpu='" + cpu + '\'' +
                ", ram='" + ram + '\'' +
                ", storage='" + storage + '\'' +
                ", gpu='" + gpu + '\'' +
                ", motherboard='" + motherboard + '\'' +
                '}';
    }
}

// 使用示例
Computer gamingPC = new Computer.Builder("Intel i9", "32GB")
                        .storage("2TB NVMe SSD")
                        .gpu("RTX 4090")
                        .motherboard("ASUS ROG")
                        .build();
```

**Python实现:**

```python
class Computer:
    def __init__(self):
        self.cpu = None
        self.ram = None
        self.storage = None
        self.gpu = None
        self.motherboard = None
    
    def __str__(self):
        return f"Computer(cpu={self.cpu}, ram={self.ram}, " \
               f"storage={self.storage}, gpu={self.gpu}, " \
               f"motherboard={self.motherboard})"

class ComputerBuilder:
    def __init__(self):
        self.computer = Computer()
    
    def set_cpu(self, cpu):
        self.computer.cpu = cpu
        return self
    
    def set_ram(self, ram):
        self.computer.ram = ram
        return self
    
    def set_storage(self, storage):
        self.computer.storage = storage
        return self
    
    def set_gpu(self, gpu):
        self.computer.gpu = gpu
        return self
    
    def set_motherboard(self, motherboard):
        self.computer.motherboard = motherboard
        return self
    
    def build(self):
        return self.computer

# 使用示例
gaming_pc = (ComputerBuilder()
             .set_cpu("Intel i9")
             .set_ram("32GB")
             .set_storage("2TB NVMe SSD")
             .set_gpu("RTX 4090")
             .set_motherboard("ASUS ROG")
             .build())
```

**优点:**
- 将复杂对象的构建与表示分离
- 可以更好地控制构建过程
- 便于创建不可变对象

**缺点:**
- 代码量增加
- 如果产品属性不多,使用建造者模式会显得冗余

---

### 原型模式

**定义:** 用原型实例指定创建对象的种类,并通过拷贝这些原型创建新的对象。

**使用场景:**
- 对象创建成本较大
- 系统需要独立于产品的创建、组合和表示
- 需要保留对象状态的快照

**实现示例(Java):**

```java
// 实现Cloneable接口
class Prototype implements Cloneable {
    private String name;
    private List<String> data;
    
    public Prototype(String name) {
        this.name = name;
        this.data = new ArrayList<>();
    }
    
    public void addData(String item) {
        this.data.add(item);
    }
    
    // 浅拷贝
    @Override
    public Prototype clone() {
        try {
            return (Prototype) super.clone();
        } catch (CloneNotSupportedException e) {
            return null;
        }
    }
    
    // 深拷贝
    public Prototype deepClone() {
        try {
            Prototype cloned = (Prototype) super.clone();
            cloned.data = new ArrayList<>(this.data);
            return cloned;
        } catch (CloneNotSupportedException e) {
            return null;
        }
    }
}
```

**Python实现:**

```python
import copy

class Prototype:
    def __init__(self, name):
        self.name = name
        self.data = []
    
    def add_data(self, item):
        self.data.append(item)
    
    # 浅拷贝
    def clone(self):
        return copy.copy(self)
    
    # 深拷贝
    def deep_clone(self):
        return copy.deepcopy(self)
```

**优点:**
- 性能优于直接new创建对象
- 简化对象创建过程
- 可以动态获得对象运行时状态

**缺点:**
- 需要为每个类配置克隆方法
- 深拷贝和浅拷贝需要谨慎处理

---

## 结构型模式

### 适配器模式

**定义:** 将一个类的接口转换成客户希望的另一个接口,使得原本由于接口不兼容而不能一起工作的类可以一起工作。

**使用场景:**
- 系统需要使用现有的类,但其接口不符合需求
- 想创建一个可复用的类,与不相关或不可预见的类协同工作
- 第三方库集成

**实现示例(Java):**

```java
// 目标接口
interface MediaPlayer {
    void play(String audioType, String fileName);
}

// 被适配的类
class VLCPlayer {
    public void playVLC(String fileName) {
        System.out.println("Playing VLC file: " + fileName);
    }
}

class MP4Player {
    public void playMP4(String fileName) {
        System.out.println("Playing MP4 file: " + fileName);
    }
}

// 适配器类
class MediaAdapter implements MediaPlayer {
    private VLCPlayer vlcPlayer;
    private MP4Player mp4Player;
    
    public MediaAdapter(String audioType) {
        if (audioType.equalsIgnoreCase("vlc")) {
            vlcPlayer = new VLCPlayer();
        } else if (audioType.equalsIgnoreCase("mp4")) {
            mp4Player = new MP4Player();
        }
    }
    
    @Override
    public void play(String audioType, String fileName) {
        if (audioType.equalsIgnoreCase("vlc")) {
            vlcPlayer.playVLC(fileName);
        } else if (audioType.equalsIgnoreCase("mp4")) {
            mp4Player.playMP4(fileName);
        }
    }
}

// 使用适配器的类
class AudioPlayer implements MediaPlayer {
    private MediaAdapter mediaAdapter;
    
    @Override
    public void play(String audioType, String fileName) {
        if (audioType.equalsIgnoreCase("mp3")) {
            System.out.println("Playing MP3 file: " + fileName);
        } else if (audioType.equalsIgnoreCase("vlc") 
                   || audioType.equalsIgnoreCase("mp4")) {
            mediaAdapter = new MediaAdapter(audioType);
            mediaAdapter.play(audioType, fileName);
        } else {
            System.out.println("Invalid media type: " + audioType);
        }
    }
}
```

**优点:**
- 提高类的复用性
- 增加类的透明性
- 灵活性好

**缺点:**
- 过多使用会使系统凌乱
- 增加系统复杂度

---

### 装饰器模式

**定义:** 动态地给一个对象添加一些额外的职责,就增加功能来说,装饰器模式比生成子类更为灵活。

**使用场景:**
- 需要动态地给对象添加功能
- 需要为一批类添加相同的功能
- Java I/O流、GUI组件

**实现示例(Java):**

```java
// 组件接口
interface Coffee {
    String getDescription();
    double getCost();
}

// 具体组件
class SimpleCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Simple Coffee";
    }
    
    @Override
    public double getCost() {
        return 5.0;
    }
}

// 抽象装饰器
abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription();
    }
    
    @Override
    public double getCost() {
        return coffee.getCost();
    }
}

// 具体装饰器
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription() + ", Milk";
    }
    
    @Override
    public double getCost() {
        return coffee.getCost() + 1.5;
    }
}

class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription() + ", Sugar";
    }
    
    @Override
    public double getCost() {
        return coffee.getCost() + 0.5;
    }
}

// 使用示例
Coffee coffee = new SimpleCoffee();
coffee = new MilkDecorator(coffee);
coffee = new SugarDecorator(coffee);
System.out.println(coffee.getDescription() + " costs $" + coffee.getCost());
```

**Python装饰器实现:**

```python
# 使用Python装饰器语法
def authenticate(func):
    def wrapper(*args, **kwargs):
        print("Authenticating user...")
        return func(*args, **kwargs)
    return wrapper

def log(func):
    def wrapper(*args, **kwargs):
        print(f"Calling function: {func.__name__}")
        result = func(*args, **kwargs)
        print(f"Function {func.__name__} completed")
        return result
    return wrapper

@authenticate
@log
def process_data(data):
    print(f"Processing: {data}")
    return data.upper()

# 使用
result = process_data("hello world")
```

**优点:**
- 比继承更灵活
- 遵循开闭原则
- 可以动态组合功能

**缺点:**
- 会产生很多小对象
- 装饰链过长时调试困难

---

### 代理模式

**定义:** 为其他对象提供一种代理以控制对这个对象的访问。

**代理类型:**
- 远程代理: 为远程对象提供本地代表
- 虚拟代理: 延迟创建开销大的对象
- 保护代理: 控制对原始对象的访问权限
- 智能引用: 在访问对象时执行额外操作

**使用场景:**
- 远程服务调用(RPC、RMI)
- 延迟加载
- 访问控制
- 日志记录、性能监控

**实现示例(Java):**

```java
// 主题接口
interface Image {
    void display();
}

// 真实主题
class RealImage implements Image {
    private String filename;
    
    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk();
    }
    
    private void loadFromDisk() {
        System.out.println("Loading image: " + filename);
        // 模拟耗时操作
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    
    @Override
    public void display() {
        System.out.println("Displaying image: " + filename);
    }
}

// 代理类
class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;
    
    public ProxyImage(String filename) {
        this.filename = filename;
    }
    
    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename);
        }
        realImage.display();
    }
}

// 使用示例
Image image = new ProxyImage("photo.jpg");
// 第一次调用会加载图片
image.display();
// 第二次调用不会重新加载
image.display();
```

**Python动态代理:**

```python
class Subject:
    def request(self):
        pass

class RealSubject(Subject):
    def request(self):
        return "RealSubject handling request"

class Proxy(Subject):
    def __init__(self, real_subject):
        self._real_subject = real_subject
    
    def request(self):
        if self.check_access():
            result = self._real_subject.request()
            self.log_access()
            return result
    
    def check_access(self):
        print("Proxy: Checking access")
        return True
    
    def log_access(self):
        print("Proxy: Logging access time")
```

**优点:**
- 职责清晰
- 扩展性好
- 智能化处理

**缺点:**
- 增加系统复杂度
- 可能降低处理速度

---

### 外观模式

**定义:** 为子系统中的一组接口提供一个一致的界面,外观模式定义了一个高层接口,使得子系统更加容易使用。

**使用场景:**
- 为复杂的模块或子系统提供简单接口
- 客户端与多个子系统之间存在很大依赖性
- 分层结构中,定义每层的入口点

**实现示例(Java):**

```java
// 子系统类
class CPU {
    public void freeze() {
        System.out.println("CPU: Freezing...");
    }
    
    public void jump(long position) {
        System.out.println("CPU: Jumping to " + position);
    }
    
    public void execute() {
        System.out.println("CPU: Executing...");
    }
}

class Memory {
    public void load(long position, byte[] data) {
        System.out.println("Memory: Loading data at " + position);
    }
}

class HardDrive {
    public byte[] read(long lba, int size) {
        System.out.println("HardDrive: Reading " + size + " bytes from " + lba);
        return new byte[size];
    }
}

// 外观类
class ComputerFacade {
    private CPU cpu;
    private Memory memory;
    private HardDrive hardDrive;
    
    public ComputerFacade() {
        this.cpu = new CPU();
        this.memory = new Memory();
        this.hardDrive = new HardDrive();
    }
    
    public void start() {
        System.out.println("Starting computer...");
        cpu.freeze();
        memory.load(0, hardDrive.read(0, 1024));
        cpu.jump(0);
        cpu.execute();
        System.out.println("Computer started successfully!");
    }
}

// 使用示例
ComputerFacade computer = new ComputerFacade();
computer.start();
```

**优点:**
- 简化接口调用
- 减少系统依赖
- 更好的层次划分

**缺点:**
- 不符合开闭原则
- 可能成为上帝对象

---

### 桥接模式

**定义:** 将抽象部分与它的实现部分分离,使它们都可以独立地变化。

**使用场景:**
- 不希望抽象和实现之间有固定绑定关系
- 抽象和实现都需要独立扩展
- 跨平台应用开发

**实现示例(Java):**

```java
// 实现接口
interface DrawAPI {
    void drawCircle(int radius, int x, int y);
}

// 具体实现
class RedCircle implements DrawAPI {
    @Override
    public void drawCircle(int radius, int x, int y) {
        System.out.println("Drawing Red Circle: radius=" + radius 
                           + ", x=" + x + ", y=" + y);
    }
}

class BlueCircle implements DrawAPI {
    @Override
    public void drawCircle(int radius, int x, int y) {
        System.out.println("Drawing Blue Circle: radius=" + radius 
                           + ", x=" + x + ", y=" + y);
    }
}

// 抽象类
abstract class Shape {
    protected DrawAPI drawAPI;
    
    protected Shape(DrawAPI drawAPI) {
        this.drawAPI = drawAPI;
    }
    
    public abstract void draw();
}

// 扩展抽象类
class Circle extends Shape {
    private int x, y, radius;
    
    public Circle(int x, int y, int radius, DrawAPI drawAPI) {
        super(drawAPI);
        this.x = x;
        this.y = y;
        this.radius = radius;
    }
    
    @Override
    public void draw() {
        drawAPI.drawCircle(radius, x, y);
    }
}

// 使用示例
Shape redCircle = new Circle(100, 100, 10, new RedCircle());
Shape blueCircle = new Circle(200, 200, 20, new BlueCircle());
redCircle.draw();
blueCircle.draw();
```

**优点:**
- 分离抽象和实现
- 提高可扩展性
- 实现细节对客户透明

**缺点:**
- 增加系统理解难度
- 需要正确识别变化维度

---

### 组合模式

**定义:** 将对象组合成树形结构以表示"部分-整体"的层次结构,使得用户对单个对象和组合对象的使用具有一致性。

**使用场景:**
- 需要表示对象的部分-整体层次结构
- 希望用户忽略组合对象与单个对象的不同
- 文件系统、组织架构、UI组件树

**实现示例(Java):**

```java
import java.util.*;

// 组件接口
interface Component {
    void operation();
    void add(Component component);
    void remove(Component component);
    Component getChild(int index);
}

// 叶子节点
class Leaf implements Component {
    private String name;
    
    public Leaf(String name) {
        this.name = name;
    }
    
    @Override
    public void operation() {
        System.out.println("Leaf: " + name);
    }
    
    @Override
    public void add(Component component) {
        throw new UnsupportedOperationException();
    }
    
    @Override
    public void remove(Component component) {
        throw new UnsupportedOperationException();
    }
    
    @Override
    public Component getChild(int index) {
        throw new UnsupportedOperationException();
    }
}

// 组合节点
class Composite implements Component {
    private String name;
    private List<Component> children = new ArrayList<>();
    
    public Composite(String name) {
        this.name = name;
    }
    
    @Override
    public void operation() {
        System.out.println("Composite: " + name);
        for (Component child : children) {
            child.operation();
        }
    }
    
    @Override
    public void add(Component component) {
        children.add(component);
    }
    
    @Override
    public void remove(Component component) {
        children.remove(component);
    }
    
    @Override
    public Component getChild(int index) {
        return children.get(index);
    }
}
```

**优点:**
- 定义层次结构
- 简化客户端代码
- 易于增加新类型组件

**缺点:**
- 设计较为抽象
- 限制类型时较为复杂

---

### 享元模式

**定义:** 运用共享技术有效地支持大量细粒度对象的复用。

**使用场景:**
- 系统有大量相似对象
- 对象的大部分状态可以外部化
- 字符串常量池、数据库连接池、线程池

**实现示例(Java):**

```java
import java.util.*;

// 享元接口
interface Shape {
    void draw(int x, int y);
}

// 具体享元
class Circle implements Shape {
    private String color; // 内部状态
    
    public Circle(String color) {
        this.color = color;
        System.out.println("Creating circle of color: " + color);
    }
    
    @Override
    public void draw(int x, int y) { // x, y是外部状态
        System.out.println("Drawing " + color + " circle at (" + x + "," + y + ")");
    }
}

// 享元工厂
class ShapeFactory {
    private static final Map<String, Shape> circleMap = new HashMap<>();
    
    public static Shape getCircle(String color) {
        Circle circle = (Circle) circleMap.get(color);
        
        if (circle == null) {
            circle = new Circle(color);
            circleMap.put(color, circle);
        }
        
        return circle;
    }
    
    public static int getCircleCount() {
        return circleMap.size();
    }
}

// 使用示例
for (int i = 0; i < 10; i++) {
    Circle circle = (Circle) ShapeFactory.getCircle(
        i % 2 == 0 ? "Red" : "Blue"
    );
    circle.draw(i * 10, i * 20);
}
System.out.println("Total circles created: " + ShapeFactory.getCircleCount());
```

**优点:**
- 大幅减少对象创建数量
- 降低内存占用
- 提高系统性能

**缺点:**
- 提高系统复杂度
- 需要分离内部和外部状态

---

## 行为型模式

### 策略模式

**定义:** 定义一系列算法,把它们一个个封装起来,并且使它们可以相互替换。

**使用场景:**
- 一个系统需要动态地在几种算法中选择一种
- 避免使用多重条件判断
- 支付方式选择、排序算法选择

**实现示例(Java):**

```java
// 策略接口
interface PaymentStrategy {
    void pay(int amount);
}

// 具体策略
class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;
    
    public CreditCardPayment(String cardNumber) {
        this.cardNumber = cardNumber;
    }
    
    @Override
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using Credit Card: " + cardNumber);
    }
}

class PayPalPayment implements PaymentStrategy {
    private String email;
    
    public PayPalPayment(String email) {
        this.email = email;
    }
    
    @Override
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using PayPal: " + email);
    }
}

class CryptoPayment implements PaymentStrategy {
    private String walletAddress;
    
    public CryptoPayment(String walletAddress) {
        this.walletAddress = walletAddress;
    }
    
    @Override
    public void pay(int amount) {
        System.out.println("Paid " + amount + " using Crypto: " + walletAddress);
    }
}

// 上下文类
class ShoppingCart {
    private PaymentStrategy paymentStrategy;
    
    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }
    
    public void checkout(int amount) {
        paymentStrategy.pay(amount);
    }
}

// 使用示例
ShoppingCart cart = new ShoppingCart();
cart.setPaymentStrategy(new CreditCardPayment("1234-5678-9012-3456"));
cart.checkout(100);

cart.setPaymentStrategy(new PayPalPayment("user@example.com"));
cart.checkout(200);
```

**优点:**
- 算法可以自由切换
- 避免多重条件判断
- 扩展性良好

**缺点:**
- 策略类数量增多
- 客户端必须知道所有策略

---

### 观察者模式

**定义:** 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新。

**使用场景:**
- 事件处理系统
- 消息订阅系统
- MVC架构中的模型-视图关系

**实现示例(Java):**

```java
import java.util.*;

// 观察者接口
interface Observer {
    void update(String message);
}

// 主题接口
interface Subject {
    void attach(Observer observer);
    void detach(Observer observer);
    void notifyObservers();
}

// 具体主题
class NewsAgency implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private String news;
    
    @Override
    public void attach(Observer observer) {
        observers.add(observer);
    }
    
    @Override
    public void detach(Observer observer) {
        observers.remove(observer);
    }
    
    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(news);
        }
    }
    
    public void setNews(String news) {
        this.news = news;
        notifyObservers();
    }
}

// 具体观察者
class NewsChannel implements Observer {
    private String name;
    
    public NewsChannel(String name) {
        this.name = name;
    }
    
    @Override
    public void update(String news) {
        System.out.println(name + " received news: " + news);
    }
}

// 使用示例
NewsAgency agency = new NewsAgency();
NewsChannel cnn = new NewsChannel("CNN");
NewsChannel bbc = new NewsChannel("BBC");

agency.attach(cnn);
agency.attach(bbc);

agency.setNews("Breaking: Design Patterns are awesome!");
```

**优点:**
- 降低耦合度
- 支持广播通信
- 符合开闭原则

**缺点:**
- 观察者过多时通知耗时
- 可能出现循环依赖
- 没有机制让观察者知道目标对象如何变化

---

### 命令模式

**定义:** 将一个请求封装为一个对象,从而使你可用不同的请求对客户进行参数化,对请求排队或记录请求日志,以及支持可撤销的操作。

**使用场景:**
- 需要对行为进行记录、撤销或重做
- 需要支持事务操作
- GUI按钮和菜单项

**实现示例(Java):**

```java
// 命令接口
interface Command {
    void execute();
    void undo();
}

// 接收者
class Light {
    public void on() {
        System.out.println("Light is ON");
    }
    
    public void off() {
        System.out.println("Light is OFF");
    }
}

// 具体命令
class LightOnCommand implements Command {
    private Light light;
    
    public LightOnCommand(Light light) {
        this.light = light;
    }
    
    @Override
    public void execute() {
        light.on();
    }
    
    @Override
    public void undo() {
        light.off();
    }
}

class LightOffCommand implements Command {
    private Light light;
    
    public LightOffCommand(Light light) {
        this.light = light;
    }
    
    @Override
    public void execute() {
        light.off();
    }
    
    @Override
    public void undo() {
        light.on();
    }
}

// 调用者
class RemoteControl {
    private Command command;
    private Stack<Command> history = new Stack<>();
    
    public void setCommand(Command command) {
        this.command = command;
    }
    
    public void pressButton() {
        command.execute();
        history.push(command);
    }
    
    public void pressUndo() {
        if (!history.isEmpty()) {
            Command lastCommand = history.pop();
            lastCommand.undo();
        }
    }
}

// 使用示例
Light light = new Light();
Command lightOn = new LightOnCommand(light);
Command lightOff = new LightOffCommand(light);

RemoteControl remote = new RemoteControl();
remote.setCommand(lightOn);
remote.pressButton();
remote.pressUndo();
```

**优点:**
- 降低系统耦合度
- 容易添加新命令
- 支持组合命令
- 支持撤销和重做

**缺点:**
- 可能产生大量具体命令类

---

### 模板方法模式

**定义:** 定义一个操作中的算法的骨架,而将一些步骤延迟到子类中,使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

**使用场景:**
- 多个子类有公共方法,且逻辑基本相同
- 重要、复杂的算法,可以把核心算法设计为模板方法
- 框架中的抽象类

**实现示例(Java):**

```java
// 抽象类
abstract class DataProcessor {
    // 模板方法
    public final void process() {
        readData();
        processData();
        writeData();
    }
    
    // 具体方法
    private void readData() {
        System.out.println("Reading data...");
    }
    
    // 抽象方法,由子类实现
    protected abstract void processData();
    
    // 钩子方法,子类可选择性覆盖
    protected void writeData() {
        System.out.println("Writing data...");
    }
}

// 具体类
class CSVProcessor extends DataProcessor {
    @Override
    protected void processData() {
        System.out.println("Processing CSV data");
    }
}

class XMLProcessor extends DataProcessor {
    @Override
    protected void processData() {
        System.out.println("Processing XML data");
    }
    
    @Override
    protected void writeData() {
        System.out.println("Writing XML data with special formatting");
    }
}

// 使用示例
DataProcessor csvProcessor = new CSVProcessor();
csvProcessor.process();

DataProcessor xmlProcessor = new XMLProcessor();
xmlProcessor.process();
```

**优点:**
- 封装不变部分,扩展可变部分
- 提取公共代码,便于维护
- 行为由父类控制,子类实现

**缺点:**
- 每个不同实现都需要一个子类
- 增加系统复杂度

---

### 迭代器模式

**定义:** 提供一种方法顺序访问一个聚合对象中的各个元素,而又不暴露该对象的内部表示。

**使用场景:**
- 访问聚合对象的内容而无需暴露其内部表示
- 需要为聚合对象提供多种遍历方式
- Java集合框架

**实现示例(Java):**

```java
import java.util.*;

// 迭代器接口
interface Iterator<T> {
    boolean hasNext();
    T next();
}

// 容器接口
interface Container<T> {
    Iterator<T> getIterator();
}

// 具体容器
class BookCollection implements Container<String> {
    private List<String> books = new ArrayList<>();
    
    public void addBook(String book) {
        books.add(book);
    }
    
    @Override
    public Iterator<String> getIterator() {
        return new BookIterator();
    }
    
    // 内部迭代器实现
    private class BookIterator implements Iterator<String> {
        private int index = 0;
        
        @Override
        public boolean hasNext() {
            return index < books.size();
        }
        
        @Override
        public String next() {
            if (hasNext()) {
                return books.get(index++);
            }
            return null;
        }
    }
}

// 使用示例
BookCollection collection = new BookCollection();
collection.addBook("Design Patterns");
collection.addBook("Clean Code");
collection.addBook("Refactoring");

Iterator<String> iterator = collection.getIterator();
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}
```

**优点:**
- 支持多种遍历方式
- 简化聚合类
- 同一个聚合可以有多个遍历

**缺点:**
- 增加系统复杂度
- 对于简单遍历可能过度设计

---

### 责任链模式

**定义:** 使多个对象都有机会处理请求,从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它为止。

**使用场景:**
- 多个对象可以处理同一个请求
- 动态指定处理请求的对象集合
- 审批流程、异常处理、日志记录

**实现示例(Java):**

```java
// 抽象处理者
abstract class Handler {
    protected Handler nextHandler;
    
    public void setNextHandler(Handler nextHandler) {
        this.nextHandler = nextHandler;
    }
    
    public abstract void handleRequest(int amount);
}

// 具体处理者
class Manager extends Handler {
    @Override
    public void handleRequest(int amount) {
        if (amount <= 1000) {
            System.out.println("Manager approved: $" + amount);
        } else if (nextHandler != null) {
            nextHandler.handleRequest(amount);
        }
    }
}

class Director extends Handler {
    @Override
    public void handleRequest(int amount) {
        if (amount <= 5000) {
            System.out.println("Director approved: $" + amount);
        } else if (nextHandler != null) {
            nextHandler.handleRequest(amount);
        }
    }
}

class CEO extends Handler {
    @Override
    public void handleRequest(int amount) {
        if (amount <= 10000) {
            System.out.println("CEO approved: $" + amount);
        } else {
            System.out.println("Amount too large, rejected: $" + amount);
        }
    }
}

// 使用示例
Handler manager = new Manager();
Handler director = new Director();
Handler ceo = new CEO();

manager.setNextHandler(director);
director.setNextHandler(ceo);

manager.handleRequest(500);   // Manager处理
manager.handleRequest(3000);  // Director处理
manager.handleRequest(8000);  // CEO处理
manager.handleRequest(15000); // 被拒绝
```

**优点:**
- 降低耦合度
- 增强灵活性
- 简化对象间连接

**缺点:**
- 请求可能不被处理
- 性能受影响
- 调试不便

---

### 状态模式

**定义:** 允许对象在内部状态改变时改变它的行为,对象看起来好像修改了它的类。

**使用场景:**
- 对象的行为依赖于它的状态
- 代码中包含大量与状态有关的条件语句
- 订单状态、TCP连接状态

**实现示例(Java):**

```java
// 状态接口
interface State {
    void handle(Context context);
}

// 具体状态
class ConcreteStateA implements State {
    @Override
    public void handle(Context context) {
        System.out.println("State A handling");
        context.setState(new ConcreteStateB());
    }
}

class ConcreteStateB implements State {
    @Override
    public void handle(Context context) {
        System.out.println("State B handling");
        context.setState(new ConcreteStateA());
    }
}

// 上下文
class Context {
    private State state;
    
    public Context() {
        state = new ConcreteStateA();
    }
    
    public void setState(State state) {
        this.state = state;
    }
    
    public void request() {
        state.handle(this);
    }
}

// 实际应用示例:订单状态
interface OrderState {
    void next(Order order);
    void prev(Order order);
    void printStatus();
}

class PendingState implements OrderState {
    @Override
    public void next(Order order) {
        order.setState(new ConfirmedState());
    }
    
    @Override
    public void prev(Order order) {
        System.out.println("Order is in initial state");
    }
    
    @Override
    public void printStatus() {
        System.out.println("Order Status: Pending");
    }
}

class ConfirmedState implements OrderState {
    @Override
    public void next(Order order) {
        order.setState(new ShippedState());
    }
    
    @Override
    public void prev(Order order) {
        order.setState(new PendingState());
    }
    
    @Override
    public void printStatus() {
        System.out.println("Order Status: Confirmed");
    }
}

class ShippedState implements OrderState {
    @Override
    public void next(Order order) {
        order.setState(new DeliveredState());
    }
    
    @Override
    public void prev(Order order) {
        order.setState(new ConfirmedState());
    }
    
    @Override
    public void printStatus() {
        System.out.println("Order Status: Shipped");
    }
}

class DeliveredState implements OrderState {
    @Override
    public void next(Order order) {
        System.out.println("Order is in final state");
    }
    
    @Override
    public void prev(Order order) {
        order.setState(new ShippedState());
    }
    
    @Override
    public void printStatus() {
        System.out.println("Order Status: Delivered");
    }
}

class Order {
    private OrderState state;
    
    public Order() {
        state = new PendingState();
    }
    
    public void setState(OrderState state) {
        this.state = state;
    }
    
    public void nextState() {
        state.next(this);
    }
    
    public void previousState() {
        state.prev(this);
    }
    
    public void printStatus() {
        state.printStatus();
    }
}
```

**优点:**
- 封装状态转换规则
- 枚举可能的状态
- 将与特定状态相关的行为局部化
- 使状态转换显式化

**缺点:**
- 增加系统类和对象的个数
- 结构和实现较复杂
- 对开闭原则支持不太好

---

## 设计模式的最佳实践

### 1. 选择合适的模式

**避免过度设计:**
- 不要为了使用设计模式而使用
- 简单问题用简单方案
- 根据实际需求选择

**考虑因素:**
- 问题的复杂度
- 系统的可扩展性需求
- 团队的技术水平
- 项目的时间限制

### 2. 组合使用模式

设计模式之间可以组合使用,例如:
- **工厂模式 + 单例模式**: 创建单例工厂
- **策略模式 + 工厂模式**: 工厂创建不同策略
- **装饰器模式 + 工厂模式**: 动态组装对象功能
- **观察者模式 + 单例模式**: 事件总线实现

### 3. SOLID原则

设计模式的实现应遵循SOLID原则:

**S - 单一职责原则(Single Responsibility Principle)**
- 一个类只负责一项职责
- 降低类的复杂度
- 提高可读性和可维护性

**O - 开闭原则(Open-Closed Principle)**
- 对扩展开放,对修改关闭
- 通过抽象和多态实现
- 大多数设计模式都遵循此原则

**L - 里氏替换原则(Liskov Substitution Principle)**
- 子类可以替换父类
- 继承必须确保超类所拥有的性质在子类中仍然成立

**I - 接口隔离原则(Interface Segregation Principle)**
- 客户端不应依赖它不需要的接口
- 类间的依赖关系应建立在最小的接口上

**D - 依赖倒置原则(Dependency Inversion Principle)**
- 高层模块不应依赖低层模块,都应依赖抽象
- 抽象不应依赖细节,细节应依赖抽象

### 4. 实践建议

**学习路径:**
1. 理解每种模式的意图和应用场景
2. 通过示例代码加深理解
3. 在实际项目中尝试应用
4. 总结经验,形成自己的理解

**代码审查要点:**
- 检查是否正确应用模式
- 评估是否存在过度设计
- 确认代码的可维护性
- 验证性能影响

**文档化:**
- 在代码注释中说明使用的设计模式
- 绘制UML类图辅助理解
- 记录选择该模式的原因

### 5. 常见陷阱

**避免模式滥用:**
- 不是所有问题都需要设计模式
- 简单的if-else有时比策略模式更合适
- 考虑维护成本

**注意性能影响:**
- 某些模式会增加间接层级
- 可能影响运行时性能
- 需要权衡灵活性和性能

**团队协作:**
- 确保团队成员理解所用模式
- 建立统一的编码规范
- 定期进行代码审查

---

## 常见问题解答

### Q1: 设计模式一定要严格按照书上的实现吗?

**答:** 不一定。设计模式是指导原则而非严格规范,应根据实际情况灵活应用:

- **核心思想不变:** 保持模式的核心意图和解决的问题不变
- **实现可以调整:** 根据具体语言特性和业务需求调整实现细节
- **简化复杂度:** 如果完整实现过于复杂,可以简化,但要保持模式的本质
- **语言特性:** 不同编程语言有不同特性,例如Python的装饰器语法糖使装饰器模式实现更简洁

**举例:** Java中的单例模式需要考虑线程安全,而Python可以使用元类或装饰器更简洁地实现。

### Q2: 如何判断什么时候应该使用设计模式?

**答:** 遵循以下判断标准:

**应该使用的情况:**
- 代码中出现大量重复逻辑
- 存在复杂的if-else或switch-case判断
- 需要频繁修改和扩展功能
- 对象创建过程复杂
- 需要解耦模块间的依赖关系

**不应该使用的情况:**
- 简单的业务逻辑,直接实现即可
- 项目规模很小,不需要高度抽象
- 团队成员对设计模式不熟悉,会增加维护成本
- 过度设计会降低代码可读性

**经验法则:** "三次原则"——当同样的代码出现第三次时,考虑重构;当需求变化第三次时,考虑使用设计模式。

### Q3: 单例模式在微服务架构中还适用吗?

**答:** 需要谨慎使用,原因如下:

**微服务环境的挑战:**
- **分布式环境:** 单例只在单个JVM中有效,跨服务无法保证唯一性
- **容器化部署:** 多个容器实例会创建多个"单例"
- **水平扩展:** 负载均衡下会有多个应用实例

**替代方案:**
- **分布式锁:** 使用Redis、Zookeeper等实现分布式单例
- **配置中心:** 使用Consul、Nacos等管理全局配置
- **依赖注入:** 使用Spring等框架的Bean作用域管理
- **无状态设计:** 尽量设计无状态服务,避免需要单例

**适用场景:** 单例模式在微服务中仍可用于单个服务内部的资源管理,如线程池、数据库连接池、日志记录器等。

### Q4: 策略模式和状态模式有什么区别?

**答:** 虽然结构相似,但意图和使用场景完全不同:

**策略模式(Strategy):**
- **意图:** 定义一系列算法,让它们可以互相替换
- **关注点:** 算法的实现方式
- **客户端:** 主动选择使用哪种策略
- **状态独立:** 各个策略之间相互独立
- **示例:** 支付方式选择、排序算法选择

**状态模式(State):**
- **意图:** 对象的行为随内部状态改变而改变
- **关注点:** 对象在不同状态下的行为
- **状态转换:** 状态之间有转换关系,通常由状态自己控制转换
- **状态依赖:** 状态之间存在转换逻辑
- **示例:** 订单状态流转、TCP连接状态

**代码区别:**
```java
// 策略模式:客户端选择策略
context.setStrategy(new ConcreteStrategyA());
context.execute();

// 状态模式:状态自动转换
order.nextState(); // 内部自动从Pending转到Confirmed
```

### Q5: 如何在现有代码中引入设计模式而不破坏现有功能?

**答:** 采用渐进式重构策略:

**步骤:**

1. **充分测试覆盖**
   - 为现有功能编写单元测试和集成测试
   - 确保测试覆盖率达到80%以上
   - 建立自动化测试流程

2. **小步重构**
   - 一次只重构一个模式
   - 每次重构后运行完整测试套件
   - 确保功能不受影响

3. **并行运行**
   - 保留旧代码,新代码并行运行
   - 使用特性开关(Feature Toggle)控制
   - 逐步切换到新实现

4. **逐步迁移**
   - 识别最适合重构的部分
   - 从边缘模块开始,逐步向核心迁移
   - 每个里程碑都要有验收标准

**实践技巧:**
```java
// 示例:将硬编码的工厂方法改为工厂模式

// 1. 先抽取接口
public interface Product { }

// 2. 创建工厂类,但保留原有创建逻辑
public class ProductFactory {
    @Deprecated
    public static Product createOldWay() {
        // 原有逻辑
    }
    
    public static Product create(String type) {
        // 新的工厂逻辑
    }
}

// 3. 逐步替换调用点
// 旧代码: Product p = new ConcreteProduct();
// 新代码: Product p = ProductFactory.create("concrete");

// 4. 完全迁移后删除废弃方法
```

**风险控制:**
- 使用版本控制系统,每次重构都创建分支
- 进行代码审查,确保重构质量
- 准备回滚方案,出现问题及时恢复
- 监控系统性能指标,确保重构不影响性能

**重构时机选择:**
- 选择业务相对平稳期进行
- 避免在发版前大规模重构
- 与产品团队沟通,争取重构时间
- 可以在修复Bug或添加新功能时顺带重构

---

## 总结

设计模式是软件工程中宝贵的经验总结,它们提供了经过验证的解决方案来应对常见的设计问题。掌握设计模式能够:

- **提高代码质量:** 使代码更加模块化、可维护、可扩展
- **改善团队协作:** 提供统一的技术语言,便于沟通
- **加速开发效率:** 避免重复造轮子,快速应用成熟方案
- **提升技术能力:** 深入理解面向对象设计原则

但要记住,设计模式是工具而非目的,应该:
- 根据实际需求选择合适的模式
- 避免过度设计和模式滥用
- 保持代码简洁和可读性
- 持续学习和实践

希望本文能够帮助你深入理解和灵活运用设计模式,在实际项目中写出更优雅、更健壮的代码!

---

**参考资料:**
- 《设计模式:可复用面向对象软件的基础》(GoF)
- 《Head First设计模式》
- 《重构:改善既有代码的设计》
- 各编程语言官方文档和最佳实践指南