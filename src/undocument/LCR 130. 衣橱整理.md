---
date: 2025-08-01
author: Gaaming Zhang
isOriginal: true
article: false
category: leetcode
tag:
  - leetcode
  - 深度优先搜索
---

# LCR 130. 衣橱整理

家居整理师将待整理衣橱划分为 m x n 的二维矩阵 grid，其中 grid[i][j] 代表一个需要整理的格子。整理师自 grid[0][0] 开始 逐行逐列 地整理每个格子。

整理规则为：在整理过程中，可以选择 向右移动一格 或 向下移动一格，但不能移动到衣柜之外。同时，不需要整理 digit(i) + digit(j) > cnt 的格子，其中 digit(x) 表示数字 x 的各数位之和。

请返回整理师 总共需要整理多少个格子。

示例 1：
输入：m = 4, n = 7, cnt = 5
输出：18

```cpp
class Solution {
public:
    int wardrobeFinishing(int m, int n, int cnt) {
        vector<vector<bool>> digit(m, vector<bool>(n, false));
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        getDigit(digit, m, n, cnt);
        int result = 0;
        search(digit, m, n, 0, 0, result, visited);
        return result;
    }

private:
    vector<vector<int>> direction{{0, 1}, {1, 0}};
    void search(vector<vector<bool>>& digit, int m, int n, int i, int j,
                int& result, vector<vector<bool>>& visited) {
        if (i < 0 || i >= m || j < 0 || j >= n || !digit[i][j] || visited[i][j])
            return;
        ++result;
        visited[i][j] = true;

        for (int k = 0; k < 2; ++k) {
            int nextI = i + direction[k][0];
            int nextJ = j + direction[k][1];
            search(digit, m, n, nextI, nextJ, result, visited);
        }
    }
    void getDigit(vector<vector<bool>>& digit, int m, int n, int cnt) {
        for (int i = 0; i < m; ++i) {
            int sum = 0, tmpI = i;
            while (tmpI > 0) {
                sum += tmpI % 10;
                tmpI /= 10;
            }
            for (int j = 0; j < n; ++j) {
                int tmpSum = sum, tmpJ = j;
                while (tmpJ > 0) {
                    tmpSum += tmpJ % 10;
                    tmpJ /= 10;
                }
                if (tmpSum <= cnt) {
                    digit[i][j] = true;
                }
            }
        }
    }
};
```