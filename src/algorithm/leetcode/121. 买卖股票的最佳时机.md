---
date: 2025-10-19
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 动态规划
---

# 121. 买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。
设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

示例 1：
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，
 最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价
 格；同时，你不能在买入前卖出股票。

## 解题思路

这道题需要找到买入和卖出的最佳时机，使得利润最大化。只能进行一次交易。

### 从右向左遍历

核心思路是维护两个变量：
1. **maxPrice**：从当前位置到末尾的最高价格
2. **maxProfit**：到目前为止的最大利润

从右向左遍历：
- 更新 maxPrice 为当前价格和之前 maxPrice 的较大值
- 计算当前位置买入的利润（maxPrice - 当前价格）
- 更新 maxProfit

### 为什么从右向左？

从右向左遍历时，maxPrice 始终表示"未来的最高价格"，即可以卖出的最高价格。这样在遍历到每个位置时，就能知道如果在这个位置买入，能获得的最大利润。

## 代码实现

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int maxPrice = 0;       // 从当前位置到末尾的最高价格
        int maxProfit = 0;      // 最大利润
        
        // 从右向左遍历
        for (int i = prices.size() - 1; i >= 0; --i) {
            // 更新最高价格（可以卖出的最高价格）
            maxPrice = max(maxPrice, prices[i]);
            // 计算当前买入的利润，更新最大利润
            maxProfit = max(maxProfit, maxPrice - prices[i]);
        }
        
        return maxProfit;
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组长度。只需遍历一次。
- **空间复杂度**：O(1)，只使用了常数级别的额外空间。

## 总结

本题使用**从右向左遍历**的方法，维护未来的最高价格，从而计算每个位置买入时的最大利润。

其他解法：
- **从左向右遍历**：维护最低价格，计算每个位置卖出时的最大利润
- **动态规划**：定义状态 dp[i] 表示前 i 天的最大利润

这道题是股票问题的入门题，后续还有多次交易、带手续费等变种。
