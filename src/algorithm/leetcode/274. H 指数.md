---
date: 2025-12-31
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 数组
  - 排序
---


# 274. H 指数

给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被
 引用的次数。计算并返回该研究者的 h 指数。

根据维基百科上 h 指数的定义：h 代表"高引用次数" ，一名科研人员的 h 指数 是指他（她）至少
 发表了 h 篇论文，并且 至少 有 h 篇论文被引用次数大于等于 h 。如果 h 有多种可能的值，
 h 指数 是其中最大的那个。

示例 1：
输入：citations = [3,0,6,1,5]
输出：3 
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，
 所以她的 h 指数是 3。

示例 2：
输入：citations = [1,3,1]
输出：1

## 解题思路

### 问题分析

h 指数的定义：找到一个最大的 h，使得至少有 h 篇论文的引用次数 >= h。

### 方法：排序

将引用次数按降序排列，然后从前往后找最大的 h。

**核心思想**：
- 排序后，如果 `citations[i] >= i + 1`，说明前 i+1 篇论文的引用次数都 >= i+1
- 找到最后一个满足条件的 i，h = i + 1

### 为什么这样正确？

降序排列后：
- `citations[0]` 是引用次数最高的论文
- 如果 `citations[i] >= i + 1`，说明前 i+1 篇论文的引用次数都 >= i+1
- 我们要找最大的 h，即找最大的 i 使得 `citations[i] >= i + 1`

## 代码实现

```cpp
class Solution {
public:
    int hIndex(vector<int>& citations) {
        sort(citations.begin(), citations.end(), greater<int>());
        
        int h = 0;
        while (h < citations.size() && citations[h] >= h + 1) {
            h++;
        }
        
        return h;
    }
};
```

### 代码详解

**排序**：
```cpp
sort(citations.begin(), citations.end(), greater<int>());
```
- 将引用次数按降序排列

**查找 h 指数**：
```cpp
int h = 0;
while (h < citations.size() && citations[h] >= h + 1) {
    h++;
}
```
- 从索引 0 开始，检查是否满足 `citations[h] >= h + 1`
- 满足条件则继续，直到不满足为止
- 最终 h 就是最大的 h 指数

**示例演示**（citations = [3,0,6,1,5]）：
```
排序后：[6, 5, 3, 1, 0]

h=0: citations[0]=6 >= 1, 满足, h++
h=1: citations[1]=5 >= 2, 满足, h++
h=2: citations[2]=3 >= 3, 满足, h++
h=3: citations[3]=1 >= 4, 不满足, 退出

返回 h = 3
```

## 复杂度分析

**时间复杂度**：O(n log n)，主要是排序的时间复杂度

**空间复杂度**：O(1)，只使用常数额外空间（不考虑排序的空间）

## 总结

本题的关键在于理解 h 指数的定义并转化为算法：

1. **排序降序**：将论文按引用次数从高到低排列
2. **线性查找**：找到最大的 h 使得 `citations[h-1] >= h`
3. **正确性证明**：排序后，前 h 篇论文的引用次数都 >= citations[h-1] >= h

还有一种 O(n) 的计数排序方法，适用于引用次数范围较小的情况。这道题展示了如何将实际问题转化为算法问题，并通过排序简化求解过程。
