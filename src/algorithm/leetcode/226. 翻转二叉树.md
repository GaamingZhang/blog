---
date: 2025-09-26
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 二叉树
---

# 226. 翻转二叉树

给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。

示例 1：
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]

示例 2：
输入：root = [2,1,3]
输出：[2,3,1]

示例 3：
输入：root = []
输出：[]

## 解题思路

这道题需要翻转二叉树，即将每个节点的左右子树交换。

### 递归方法

核心思路：递归地交换每个节点的左右子树。

1. 如果节点为空，返回空
2. 递归翻转左子树
3. 递归翻转右子树
4. 交换左右子树
5. 返回当前节点

### 算法流程

1. 检查当前节点是否为空
2. 递归处理左子树
3. 递归处理右子树
4. 交换左右子节点
5. 返回当前节点

### 示例分析

`[4,2,7,1,3,6,9]`：
```
    4                4
   / \              / \
  2   7    →      7   2
 / \ / \         / \ / \
1  3 6  9       9  6 3  1
```

## 代码实现

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        // 空节点直接返回
        if (root == nullptr) {
            return nullptr;
        }
        
        // 递归翻转左子树，保存结果
        TreeNode* leftInverted = invertTree(root->left);
        // 递归翻转右子树
        TreeNode* rightInverted = invertTree(root->right);
        
        // 交换左右子树
        root->left = rightInverted;
        root->right = leftInverted;
        
        return root;
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是树中节点数。每个节点只访问一次。
- **空间复杂度**：O(h)，其中 h 是树的高度。递归调用栈的深度取决于树的高度，最坏情况（链状树）为 O(n)，平均情况（平衡树）为 O(log n)。

## 总结

本题使用**递归**翻转二叉树。关键在于：

1. **递归思想**：先处理子树，再交换当前节点的左右子树
2. **后序遍历**：先处理子节点，再处理当前节点
3. **原地修改**：直接在原树上修改，不需要额外空间

其他解法：
- **迭代 BFS**：使用队列层序遍历，逐个交换
- **迭代 DFS**：使用栈进行深度优先遍历
