---
date: 2025-07-25
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 字符串
---

# 14. 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 ""。

示例 1：
输入：strs = ["flower","flow","flight"]
输出："fl"

示例 2：
输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。

## 解题思路

这道题需要找到字符串数组中所有字符串的最长公共前缀。

### 逐个比较法

核心思路是**逐个比较相邻字符串的公共前缀**：

1. 以第一个字符串为基准
2. 依次与后续每个字符串比较，更新公共前缀长度
3. 如果公共前缀长度变为 0，可以提前结束

### 比较过程

对于每个新字符串：
1. 更新公共前缀长度上限（取当前长度和该字符串长度的较小值）
2. 逐字符比较，找到不同的位置
3. 更新公共前缀长度

**示例分析**：`["flower", "flow", "flight"]`
- 初始：maxLength = 6（"flower"的长度）
- 比较 "flower" 和 "flow"：maxLength = 4（"flow"的长度），公共前缀 "flow"
- 比较 "flow" 和 "flight"：第 2 个字符不同，maxLength = 2，公共前缀 "fl"
- 结果："fl"

## 代码实现

```cpp
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        // 以第一个字符串的长度作为初始公共前缀长度
        int maxLength = strs[0].size();
        
        // 逐个与后续字符串比较
        for (int i = 1; i < strs.size() && maxLength > 0; ++i) {
            // 更新公共前缀长度上限（不能超过当前字符串长度）
            maxLength = min(maxLength, (int)strs[i].size());
            
            // 逐字符比较，找到不同的位置
            for (int j = 0; j < maxLength; ++j) {
                if (strs[i - 1][j] != strs[i][j]) {
                    // 发现不匹配，更新公共前缀长度
                    maxLength = j;
                    break;  // 提前结束内层循环
                }
            }
        }
        
        // 返回公共前缀
        return strs[0].substr(0, maxLength);
    }
};
```

## 复杂度分析

- **时间复杂度**：O(S)，其中 S 是所有字符串中字符的总数。最坏情况下需要比较所有字符。
- **空间复杂度**：O(1)，只使用了常数级别的额外空间。

## 总结

本题使用**逐个比较法**，以第一个字符串为基准，依次与后续字符串比较来更新公共前缀长度。这种方法思路直观，实现简单。

其他解法包括：
- **纵向扫描**：按列比较所有字符串的同一位置字符
- **分治法**：将数组分成两半，分别求公共前缀再合并
- **二分查找**：对公共前缀长度进行二分查找
