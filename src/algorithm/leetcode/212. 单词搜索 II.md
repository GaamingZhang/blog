---
date: 2025-09-18
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 回溯
  - 字典树
---

# 212. 单词搜索 II

给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words， 返回所有二维网格上的单词 。
单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中"相邻"单元格是那些水平相邻或垂直相邻的单元格。
 同一个单元格内的字母在一个单词中不允许被重复使用。

示例 1：
输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
输出：["eat","oath"]

示例 2：
输入：board = [["a","b"],["c","d"]], words = ["abcb"]
输出：[]

## 解题思路

这道题是单词搜索的进阶版本，需要在网格中找到多个单词。直接对每个单词进行 DFS 搜索会超时，需要使用更高效的方法。

### 方法：前缀树 + DFS 回溯

使用前缀树（Trie）来存储所有待查找的单词，然后从网格的每个位置开始 DFS，利用前缀树进行剪枝。

### 核心思想

1. **构建前缀树**：将所有单词插入前缀树，便于快速判断当前路径是否是某个单词的前缀
2. **DFS 搜索**：从网格的每个位置开始，向四个方向扩展
3. **剪枝优化**：如果当前路径不是任何单词的前缀，直接返回

### 优化策略

1. **使用哈希表存储前缀**：将所有单词的所有前缀存入哈希表，O(1) 时间判断是否是有效前缀
2. **使用集合存储完整单词**：快速判断当前路径是否构成完整单词
3. **找到单词后删除**：避免重复添加同一个单词

## 代码实现

```cpp
class Solution {
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        vector<string> result;
        
        for (int i = 0; i < words.size(); ++i) {
            for (int j = 1; j <= words[i].size(); ++j) {
                ++prefixCount[words[i].substr(0, j)];
            }
            wordSet.insert(words[i]);
        }
        
        m = board.size();
        n = board[0].size();
        vector<vector<int>> visited(m, vector<int>(n, 0));
        string current;
        
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                visited[i][j] = 1;
                dfs(board, visited, i, j, result, current);
                visited[i][j] = 0;
            }
        }
        
        return result;
    }

private:
    vector<vector<int>> directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    unordered_map<string, int> prefixCount;
    set<string> wordSet;
    int m = 0, n = 0;

    void dfs(vector<vector<char>>& board, vector<vector<int>>& visited,
             int i, int j, vector<string>& result, string current) {
        string next = current + board[i][j];
        
        if (prefixCount.find(next) == prefixCount.end()) {
            return;
        }
        
        if (wordSet.find(next) != wordSet.end()) {
            result.push_back(next);
            wordSet.erase(next);
            for (int k = 1; k <= next.size(); ++k) {
                string prefix = next.substr(0, k);
                if (--prefixCount[prefix] == 0) {
                    prefixCount.erase(prefix);
                }
            }
        }
        
        for (int k = 0; k < 4; ++k) {
            int ni = i + directions[k][0];
            int nj = j + directions[k][1];
            
            if (ni < 0 || ni >= m || nj < 0 || nj >= n || visited[ni][nj]) {
                continue;
            }
            
            visited[ni][nj] = 1;
            dfs(board, visited, ni, nj, result, next);
            visited[ni][nj] = 0;
        }
    }
};
```

### 代码详解

**预处理阶段**：
1. 遍历所有单词，将每个单词的所有前缀存入 `prefixCount` 哈希表
2. 将完整单词存入 `wordSet` 集合

**DFS 搜索**：
1. 从网格的每个位置开始搜索
2. 构建当前路径字符串 `next = current + board[i][j]`
3. 如果 `next` 不是任何单词的前缀，直接返回（剪枝）
4. 如果 `next` 是完整单词，加入结果并从集合中删除
5. 向四个方向继续搜索

**找到单词后的清理**：
- 从 `wordSet` 中删除该单词
- 减少所有相关前缀的计数，计数为 0 时删除

**访问标记**：
- 使用 `visited` 数组标记已访问的格子
- 回溯时清除标记

## 复杂度分析

**时间复杂度**：O(m × n × 4^L)，其中 m × n 是网格大小，L 是单词的最大长度。最坏情况下需要遍历所有路径。

**空间复杂度**：O(k × L)，其中 k 是单词数量，L 是单词平均长度。需要存储所有前缀和单词。

## 总结

本题结合了前缀树和 DFS 回溯两种算法思想：

1. **前缀树优化**：使用哈希表存储前缀，实现 O(1) 的前缀判断
2. **剪枝策略**：遇到无效前缀立即返回，避免无效搜索
3. **去重处理**：找到单词后删除，避免重复添加

更优化的实现可以使用真正的字典树（Trie）结构，进一步降低空间复杂度。这道题展示了如何将多种算法思想结合起来解决复杂问题。
