---
date: 2025-09-18
author: Gaaming Zhang
isOriginal: true
article: false
category: leetcode
tag:
  - leetcode
---

---

# 212. 单词搜索 II

给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words， 返回所有二维网格上的单词 。
单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中"相邻"单元格是那些水平相邻或垂直相邻的单元格。
 同一个单元格内的字母在一个单词中不允许被重复使用。

```cpp
class Solution {
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        vector<string> result;
        for (int i = 0; i < words.size(); ++i) {
            for (int j = 1; j <= words[i].size(); ++j) {
                ++availableWord[words[i].substr(0, j)];
            }
            endWord.insert(words[i]);
        }
        m = board.size();
        n = board[0].size();
        vector<vector<int>> visited(m, vector<int>(n, 0));
        string tmp;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                tmp = "";
                visited[i][j] = 1;
                dfs(board, visited, i, j, result, tmp);
                visited[i][j] = 0;
            }
        }
        return result;
    }

private:
    vector<vector<int>> directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    unordered_map<string, int> availableWord;
    set<string> endWord;
    int m = 0, n = 0;

    void dfs(vector<vector<char>>& board, vector<vector<int>>& visited,
        int i, int j,
        vector<string>& result, string tmp) {
        string currentString = tmp + board[i][j];
        if (!availableWord.contains(currentString)) {
            return;
        }
        if (endWord.contains(currentString)) {
            result.push_back(currentString);
            endWord.erase(currentString);
            for (int k = 1; k <= currentString.size(); ++k) {
                string tmpStr = currentString.substr(0, k);
                if (--availableWord[tmpStr] == 0) {
                    availableWord.erase(tmpStr);
                }
            }
        }
        for (int k = 0; k < 4; ++k) {
            int nextI = i + directions[k][0];
            int nextJ = j + directions[k][1];
            if (nextI < 0 || nextI >= m || nextJ < 0 || nextJ >= n || visited[nextI][nextJ] == 1) {
                continue;
            }
            visited[nextI][nextJ] = 1;
            dfs(board, visited, nextI, nextJ, result, currentString);
            visited[nextI][nextJ] = 0;
        }
    }
};
```
