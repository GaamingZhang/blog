---
date: 2025-10-28
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 二叉树
---

# 199. 二叉树的右视图

给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例 1：
输入：root = [1,2,3,null,5,null,4]
输出：[1,3,4]

示例 2：
输入：root = [1,2,3,4,null,null,null,5]
输出：[1,3,4,5]

示例 3：
输入：root = [1,null,3]
输出：[1,3]

示例 4：
输入：root = []
输出：[]

## 解题思路

这道题需要返回二叉树的右视图，即从右侧能看到的所有节点。

### 层序遍历（BFS）

使用广度优先搜索进行层序遍历：

1. 按层遍历二叉树
2. 每层的最后一个节点就是右视图能看到的节点
3. 将每层的最后一个节点加入结果

### 算法流程

1. 使用队列进行层序遍历
2. 对于每一层，记录节点数量
3. 遍历当前层的所有节点
4. 将每层的最后一个节点（i == size - 1）加入结果

### 示例分析

`[1,2,3,null,5,null,4]`：
- 第 1 层：[1]，最后一个节点是 1，结果 = [1]
- 第 2 层：[2,3]，最后一个节点是 3，结果 = [1,3]
- 第 3 层：[5,4]，最后一个节点是 4，结果 = [1,3,4]

## 代码实现

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        // 空树返回空数组
        if (root == nullptr) {
            return {};
        }
        
        vector<int> result;       // 存储右视图结果
        queue<TreeNode*> nodes;   // BFS 队列
        nodes.push(root);
        
        // 层序遍历
        while (!nodes.empty()) {
            int size = nodes.size();  // 当前层的节点数量
            
            // 遍历当前层的所有节点
            for (int i = 0; i < size; ++i) {
                TreeNode* curNode = nodes.front();
                nodes.pop();
                
                // 将子节点加入队列
                if (curNode->left != nullptr) {
                    nodes.push(curNode->left);
                }
                if (curNode->right != nullptr) {
                    nodes.push(curNode->right);
                }
                
                // 如果是当前层的最后一个节点，加入结果
                if (i == size - 1) {
                    result.push_back(curNode->val);
                }
            }
        }
        
        return result;
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是树中节点数。每个节点只访问一次。
- **空间复杂度**：O(w)，其中 w 是树的最大宽度。队列最多存储一层的节点。

## 总结

本题使用**层序遍历（BFS）**获取二叉树的右视图。关键在于：

1. **层序遍历**：按层遍历二叉树
2. **最后一个节点**：每层的最后一个节点就是右视图能看到的节点
3. **队列实现**：使用队列实现 BFS

其他解法：
- **DFS**：从右向左遍历，记录每层第一个访问的节点
