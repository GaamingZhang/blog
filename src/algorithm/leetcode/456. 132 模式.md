---
date: 2025-10-02
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 栈
  - 单调栈
---

# 456. 132 模式

给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i < j < k 和 nums[i] < nums[k] < nums[j] 。

如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。

示例 1：
输入：nums = [1,2,3,4]
输出：false
解释：序列中不存在 132 模式的子序列。

示例 2：
输入：nums = [3,1,4,2]
输出：true
解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。

示例 3：
输入：nums = [-1,3,2,0]
输出：true
解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。

## 解题思路

### 问题分析

132 模式要求找到三个数 nums[i]、nums[j]、nums[k]，满足：
- i < j < k（索引递增）
- nums[i] < nums[k] < nums[j]（值的关系：小 < 中 < 大）

### 方法：单调栈

从右向左遍历，维护一个单调递减的栈。

**核心思想**：
1. `nums[j]` 是三个数中最大的（"3"）
2. `nums[k]` 是中间值（"2"）
3. `nums[i]` 是最小的（"1"）

**算法流程**：
1. 从右向左遍历，使用栈维护可能的 `nums[k]` 候选值
2. `thirdValue` 记录当前找到的最大的 `nums[k]` 值
3. 如果当前元素小于 `thirdValue`，说明找到了 132 模式
4. 如果当前元素大于栈顶，弹出栈顶并更新 `thirdValue`
5. 将当前元素入栈

### 为什么从右向左遍历？

- 从右向左遍历时，当前元素就是潜在的 `nums[j]`（"3"）
- 栈中存储的是比当前元素小的元素，是潜在的 `nums[k]`（"2"）
- `thirdValue` 是已经处理过的元素中，可以作为 `nums[k]` 的最大值
- 如果当前元素小于 `thirdValue`，说明找到了满足条件的 `nums[i]`（"1"）

## 代码实现

```cpp
class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        if (nums.size() < 3) {
            return false;
        }
        
        stack<int> st;
        int thirdValue = INT_MIN;
        
        for (int i = nums.size() - 1; i >= 0; --i) {
            if (nums[i] < thirdValue) {
                return true;
            }
            
            while (!st.empty() && nums[i] > st.top()) {
                thirdValue = st.top();
                st.pop();
            }
            
            st.push(nums[i]);
        }
        
        return false;
    }
};
```

### 代码详解

**初始化**：
```cpp
stack<int> st;           // 单调递减栈
int thirdValue = INT_MIN; // 记录最大的 nums[k] 值
```

**遍历过程**：
```cpp
if (nums[i] < thirdValue) {
    return true;  // 找到满足条件的 nums[i]
}
```
- 如果当前元素小于 `thirdValue`，说明存在 132 模式

```cpp
while (!st.empty() && nums[i] > st.top()) {
    thirdValue = st.top();  // 更新 thirdValue
    st.pop();
}
```
- 弹出所有比当前元素小的栈顶元素
- 这些元素都是潜在的 `nums[k]`，更新 `thirdValue` 为最大的那个

```cpp
st.push(nums[i]);  // 当前元素入栈
```

**示例演示**（nums = [3,1,4,2]）：
```
从右向左遍历：

i=3, nums[3]=2:
  thirdValue=INT_MIN, 2 不小于 INT_MIN
  栈空，直接入栈
  st=[2], thirdValue=INT_MIN

i=2, nums[2]=4:
  thirdValue=INT_MIN, 4 不小于 INT_MIN
  4 > 2, 弹出2, thirdValue=2
  栈空，入栈4
  st=[4], thirdValue=2

i=1, nums[1]=1:
  thirdValue=2, 1 < 2, 返回 true

找到 132 模式：nums[1]=1, nums[2]=4, nums[3]=2 → 1 < 2 < 4
```

## 复杂度分析

**时间复杂度**：O(n)，每个元素最多入栈出栈各一次

**空间复杂度**：O(n)，栈最多存储 n 个元素

## 总结

本题使用单调栈巧妙地解决了 132 模式的检测：

1. **从右向左遍历**：当前元素作为潜在的"3"
2. **单调栈维护**：栈中存储比当前元素小的值，作为潜在的"2"
3. **thirdValue 记录**：记录最大的"2"值，用于判断是否存在"1"

这种单调栈的思想在解决"寻找特定模式"问题时非常有效，类似的还有"下一个更大元素"等问题。理解如何维护单调性是解决此类问题的关键。
