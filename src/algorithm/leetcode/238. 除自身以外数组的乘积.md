---
date: 2025-09-27
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 数组
  - 前缀和
---

# 238. 除自身以外数组的乘积

给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i]
 之外其余各元素的乘积 。
题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。
请 不要使用除法，且在 O(n) 时间复杂度内完成此题。

示例 1:
输入: nums = [1,2,3,4]
输出: [24,12,8,6]

示例 2:
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]

## 解题思路

### 问题分析

要求 `answer[i]` 等于除 `nums[i]` 之外所有元素的乘积，且不能使用除法。

### 核心思想

对于位置 i 的结果，可以分解为：
- **左侧乘积**：`nums[0] * nums[1] * ... * nums[i-1]`
- **右侧乘积**：`nums[i+1] * nums[i+2] * ... * nums[n-1]`

`answer[i] = 左侧乘积 × 右侧乘积`

### 方法：前缀乘积 + 后缀乘积

1. **计算后缀乘积数组**：`suffix[i]` 表示位置 i 右侧所有元素的乘积
2. **遍历时计算前缀乘积**：`prefix` 表示位置 i 左侧所有元素的乘积
3. **结果**：`answer[i] = prefix × suffix[i]`

### 空间优化

可以将后缀乘积数组省略，在第二次遍历时直接计算。

## 代码实现

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> result(n, 1);
        
        int prefix = 1;
        for (int i = 0; i < n; ++i) {
            result[i] = prefix;
            prefix *= nums[i];
        }
        
        int suffix = 1;
        for (int i = n - 1; i >= 0; --i) {
            result[i] *= suffix;
            suffix *= nums[i];
        }
        
        return result;
    }
};
```

### 代码详解

**第一次遍历（从左到右）**：
```cpp
int prefix = 1;
for (int i = 0; i < n; ++i) {
    result[i] = prefix;  // 存储左侧乘积
    prefix *= nums[i];   // 更新前缀乘积
}
```
- `result[i]` 暂存位置 i 左侧所有元素的乘积
- `prefix` 累乘左侧元素

**第二次遍历（从右到左）**：
```cpp
int suffix = 1;
for (int i = n - 1; i >= 0; --i) {
    result[i] *= suffix; // 左侧乘积 × 右侧乘积
    suffix *= nums[i];   // 更新后缀乘积
}
```
- `result[i]` 乘以右侧所有元素的乘积
- `suffix` 累乘右侧元素

**示例演示**（nums = [1,2,3,4]）：
```
第一次遍历（计算左侧乘积）：
i=0: result[0]=1, prefix=1*1=1
i=1: result[1]=1, prefix=1*2=2
i=2: result[2]=2, prefix=2*3=6
i=3: result[3]=6, prefix=6*4=24
result = [1, 1, 2, 6]

第二次遍历（乘以右侧乘积）：
i=3: result[3]=6*1=6, suffix=1*4=4
i=2: result[2]=2*4=8, suffix=4*3=12
i=1: result[1]=1*12=12, suffix=12*2=24
i=0: result[0]=1*24=24, suffix=24*1=24
result = [24, 12, 8, 6]
```

## 复杂度分析

**时间复杂度**：O(n)，两次遍历数组

**空间复杂度**：O(1)，除了输出数组外，只使用常数额外空间

## 总结

本题的关键在于将乘积分解为左右两部分：

1. **分解思想**：`answer[i] = 左侧乘积 × 右侧乘积`
2. **两次遍历**：第一次计算左侧乘积，第二次乘以右侧乘积
3. **空间优化**：利用输出数组存储中间结果，避免额外空间

这种"前缀乘积 + 后缀乘积"的思路在数组问题中很常见，类似的还有前缀和、差分数组等技巧。理解如何将问题分解为独立的部分是解决此类问题的关键。
