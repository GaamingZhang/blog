---
date: 2025-08-27
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 链表
---

# 148. 排序链表

给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表。

示例 1：
输入：head = [4,2,1,3]
输出：[1,2,3,4]

示例 2：
输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]

示例 3：
输入：head = []
输出：[]

## 解题思路

这道题需要对链表进行升序排序。由于链表不支持随机访问，需要选择合适的排序算法。

### 归并排序

归并排序是链表排序的最佳选择：

1. **时间复杂度**：O(n log n)
2. **空间复杂度**：O(log n)（递归栈）
3. **稳定性**：稳定排序

### 算法流程

1. **分割**：使用快慢指针找到链表中点，将链表分成两半
2. **递归排序**：对左右两半分别递归排序
3. **合并**：将两个有序链表合并成一个有序链表

### 快慢指针找中点

- 快指针每次走两步，慢指针每次走一步
- 当快指针到达末尾时，慢指针指向中点

### 合并两个有序链表

使用递归或迭代方式合并两个有序链表。

## 代码实现

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        return mergeSort(head);
    }

private:
    // 归并排序
    ListNode* mergeSort(ListNode* head) {
        // 空链表或单节点链表已经有序
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        
        // 使用快慢指针找到链表中点
        ListNode* mid = findMiddle(head);
        ListNode* rightHead = mid->next;
        mid->next = nullptr;  // 断开链表
        
        // 递归排序左右两半
        ListNode* left = mergeSort(head);
        ListNode* right = mergeSort(rightHead);
        
        // 合并两个有序链表
        return merge(left, right);
    }
    
    // 使用快慢指针找到链表中点
    ListNode* findMiddle(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head->next;  // fast 先走一步，确保 slow 在中点偏左
        
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        return slow;
    }
    
    // 合并两个有序链表（递归方式）
    ListNode* merge(ListNode* l1, ListNode* l2) {
        if (l1 == nullptr) return l2;
        if (l2 == nullptr) return l1;
        
        if (l1->val < l2->val) {
            l1->next = merge(l1->next, l2);
            return l1;
        } else {
            l2->next = merge(l1, l2->next);
            return l2;
        }
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n log n)，归并排序的时间复杂度。
- **空间复杂度**：O(log n)，递归调用栈的深度。可以使用迭代方式优化为 O(1)。

## 总结

本题使用**归并排序**对链表进行排序。关键在于：

1. **归并排序**：适合链表排序，时间复杂度 O(n log n)
2. **快慢指针**：找到链表中点进行分割
3. **合并有序链表**：递归或迭代合并

进阶：可以使用自底向上的归并排序，将空间复杂度优化为 O(1)。
