---
date: 2025-10-23
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 字符串
---

# 125. 验证回文串

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。
则可以认为该短语是一个 回文串 。
字母和数字都属于字母数字字符。
给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。

示例 1：
输入: s = "A man, a plan, a canal: Panama"
输出：true
解释："amanaplanacanalpanama" 是回文串。

示例 2：
输入：s = "race a car"
输出：false
解释："raceacar" 不是回文串。

示例 3：
输入：s = " "
输出：true
解释：在移除非字母数字字符之后，s 是一个空字符串 "" 。
由于空字符串正着反着读都一样，所以是回文串。

## 解题思路

这道题需要判断字符串是否是回文串，但需要先进行预处理：
1. 将所有大写字符转换为小写
2. 移除所有非字母数字字符

### 双指针法

使用双指针从两端向中间遍历：

1. 左指针从字符串开头向右移动
2. 右指针从字符串末尾向左移动
3. 跳过非字母数字字符
4. 比较左右指针指向的字符（转换为小写后）
5. 如果不相同则不是回文串

### 判断字母数字字符

一个字符是字母数字字符，当且仅当：
- 是大写字母：'A' 到 'Z'
- 是小写字母：'a' 到 'z'
- 是数字：'0' 到 '9'

## 代码实现

```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        int startIndex = 0;          // 左指针
        int endIndex = s.size() - 1; // 右指针
        
        while (startIndex < endIndex) {
            // 跳过左边的非字母数字字符
            while (startIndex < endIndex && !isChar(s[startIndex])) {
                ++startIndex;
            }
            // 跳过右边的非字母数字字符
            while (startIndex < endIndex && !isChar(s[endIndex])) {
                --endIndex;
            }
            
            // 如果只剩一个字符，是回文串
            if (startIndex == endIndex) {
                return true;
            }
            
            // 转换为小写进行比较
            char startChar = toLower(s[startIndex]);
            char endChar = toLower(s[endIndex]);
            
            // 如果不相同，不是回文串
            if (startChar != endChar) {
                return false;
            }
            
            // 移动指针
            ++startIndex;
            --endIndex;
        }
        
        return true;
    }

private:
    // 判断是否是字母数字字符
    bool isChar(char a) {
        if (a >= 'A' && a <= 'Z') {
            return true;
        }
        if (a >= 'a' && a <= 'z') {
            return true;
        }
        if (a >= '0' && a <= '9') {
            return true;
        }
        return false;
    }
    
    // 转换为小写
    char toLower(char a) {
        if (a >= 'A' && a <= 'Z') {
            return a - 'A' + 'a';
        }
        return a;
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是字符串长度。只需遍历一次。
- **空间复杂度**：O(1)，只使用了常数级别的额外空间。

## 总结

本题使用**双指针法**验证回文串。关键在于：

1. **预处理**：跳过非字母数字字符，统一转换为小写
2. **双指针**：从两端向中间遍历，比较对应位置的字符
3. **边界处理**：空字符串和单字符都是回文串

这种方法避免了创建新字符串，空间复杂度为 O(1)。
