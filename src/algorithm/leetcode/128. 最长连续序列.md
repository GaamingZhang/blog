---
date: 2025-08-03
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 哈希表
---

# 128. 最长连续序列

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

示例 1：
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

示例 2：
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9

示例 3：
输入：nums = [1,0,1,2]
输出：3

## 解题思路

这道题需要在 O(n) 时间复杂度内找到最长连续序列。

### 哈希表法

核心思路：**只从序列的起点开始计数**。

1. 将所有数字存入哈希集合
2. 遍历集合中的每个数字
3. 如果 num-1 不在集合中，说明 num 是某个连续序列的起点
4. 从起点开始，向右扩展计算序列长度

### 为什么只从起点开始？

如果一个数字 num 不是序列起点（即 num-1 存在），那么它一定会在处理 num-1 时被计算过。这样可以避免重复计算，保证每个序列只被计算一次。

### 算法流程

1. 将数组元素存入哈希集合（去重）
2. 遍历集合中的每个数字
3. 判断是否是序列起点（num-1 不存在）
4. 如果是起点，向右扩展计算序列长度
5. 更新最大长度

## 代码实现

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        // 使用哈希集合存储所有数字（自动去重）
        unordered_set<int> numExist;
        for (int i = 0; i < nums.size(); ++i) {
            numExist.insert(nums[i]);
        }
        
        int res = 0;  // 最长连续序列长度
        
        // 遍历集合中的每个数字
        for (auto num : numExist) {
            // 如果 num-1 存在，说明 num 不是序列起点，跳过
            if (numExist.contains(num - 1)) {
                continue;
            }
            
            // num 是序列起点，向右扩展计算序列长度
            int rightLength = 0;
            int rightNum = num + 1;
            while (numExist.contains(rightNum)) {
                ++rightLength;
                ++rightNum;
            }
            
            // 更新最大长度（+1 是因为要包含起点本身）
            res = max(res, rightLength + 1);
        }
        
        return res;
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组长度。虽然有两层循环，但每个数字最多被访问两次（一次作为起点，一次作为序列中的元素）。
- **空间复杂度**：O(n)，哈希集合存储所有数字。

## 总结

本题使用**哈希集合**在 O(n) 时间复杂度内找到最长连续序列。关键在于：

1. **哈希集合**：O(1) 时间判断数字是否存在
2. **起点判断**：只从序列起点开始计算，避免重复
3. **去重**：哈希集合自动处理重复元素

这道题的难点在于如何保证 O(n) 时间复杂度，核心思想是每个数字只被处理一次。
