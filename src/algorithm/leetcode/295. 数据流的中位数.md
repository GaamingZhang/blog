---
date: 2025-10-02
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 堆
  - 设计
---

# 295. 数据流的中位数

中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

例如 arr = [2,3,4] 的中位数是 3 。
例如 arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5 。
实现 MedianFinder 类:

MedianFinder() 初始化 MedianFinder 对象。

void addNum(int num) 将数据流中的整数 num 添加到数据结构中。

double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。

示例 1：
输入
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
输出
[null, null, null, 1.5, null, 2.0]

解释
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0

## 解题思路

### 问题分析

需要设计一个数据结构，支持动态添加数字和快速查询中位数。

### 方法：双堆

使用两个堆来维护数据：
- **大顶堆（maxHeap）**：存储较小的一半数字，堆顶是这部分的最大值
- **小顶堆（minHeap）**：存储较大的一半数字，堆顶是这部分的最小值

### 核心思想

1. **平衡性**：保持两个堆的大小差不超过 1
2. **有序性**：maxHeap 的所有元素 <= minHeap 的所有元素
3. **中位数计算**：
   - 如果两个堆大小相等，中位数是两个堆顶的平均值
   - 如果大小不等，中位数是较大堆的堆顶

### 添加数字的流程

1. 如果数字 <= maxHeap 堆顶，放入 maxHeap
2. 否则放入 minHeap
3. 调整两个堆的大小，保持平衡

## 代码实现

```cpp
class MedianFinder {
public:
    MedianFinder() {}
    
    void addNum(int num) {
        if (maxHeap.empty()) {
            maxHeap.push(num);
            return;
        }
        
        if (num <= maxHeap.top()) {
            maxHeap.push(num);
        } else {
            minHeap.push(num);
        }
        
        if (maxHeap.size() > minHeap.size() + 1) {
            minHeap.push(maxHeap.top());
            maxHeap.pop();
        } else if (minHeap.size() > maxHeap.size()) {
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
    }
    
    double findMedian() {
        if (maxHeap.size() == minHeap.size()) {
            return (maxHeap.top() + minHeap.top()) / 2.0;
        }
        return maxHeap.top();
    }

private:
    priority_queue<int> maxHeap;
    priority_queue<int, vector<int>, greater<int>> minHeap;
};
```

### 代码详解

**数据结构**：
```cpp
priority_queue<int> maxHeap;  // 大顶堆，存储较小的一半
priority_queue<int, vector<int>, greater<int>> minHeap;  // 小顶堆，存储较大的一半
```

**添加数字**：
1. 根据数字与 maxHeap 堆顶的比较，决定放入哪个堆
2. 调整堆的大小：
   - 如果 maxHeap 比 minHeap 多超过 1 个元素，移动一个到 minHeap
   - 如果 minHeap 比 maxHeap 多，移动一个到 maxHeap

**查询中位数**：
- 两个堆大小相等：返回两个堆顶的平均值
- 不相等：返回 maxHeap 的堆顶（maxHeap 始终保持元素数 >= minHeap）

**示例演示**：
```
添加 1: maxHeap=[1], minHeap=[]
添加 2: 2 > 1, minHeap=[2], maxHeap=[1]
       minHeap.size() > maxHeap.size(), 调整
       maxHeap=[2], minHeap=[1]
查询: (2+1)/2.0 = 1.5

添加 3: 3 > 2, minHeap=[3], maxHeap=[2,1]
查询: maxHeap.top() = 2
```

## 复杂度分析

**时间复杂度**：
- `addNum`：O(log n)，堆的插入和删除操作
- `findMedian`：O(1)，直接访问堆顶

**空间复杂度**：O(n)，存储所有添加的数字

## 总结

本题使用双堆巧妙地解决了动态中位数问题：

1. **双堆设计**：大顶堆存小半部分，小顶堆存大半部分
2. **平衡维护**：保持两个堆的大小差不超过 1
3. **高效查询**：O(1) 时间获取中位数

这种"双堆"的思想在很多场景都有应用，如滑动窗口中位数、数据流第 K 大元素等问题。理解如何用堆来维护数据的有序性是解决此类问题的关键。
