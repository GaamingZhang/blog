---
date: 2025-10-12
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 拓扑排序
---

# 210. 课程表 II

现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，
 其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。
例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。
返回你为了学完所有课程
 所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，
 返回 一个空数组 。

示例 1：
输入：numCourses = 2, prerequisites = [[1,0]]
输出：[0,1]
解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。

```cpp
class Solution {
public:
    vector<int> res;

    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> graph(numCourses);
        vector<int> inDegree(numCourses, 0);

        for (const auto& prereq : prerequisites) {
            int a = prereq[0];
            int b = prereq[1];
            graph[b].emplace_back(a);
            inDegree[a]++;
        }

        queue<int> que;

        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                que.push(i);
            }
        }

        int count = 0;

        while (!que.empty()) {
            int node = que.front();
            que.pop();
            count++;
            res.emplace_back(node);

            for (int nei : graph[node]) {
                inDegree[nei]--;
                if (inDegree[nei] == 0) {
                    que.push(nei);
                }
            }
        }

        if (count < numCourses) {
            return {};
        }

        return res;
    }
};
```
