---
date: 2025-11-17
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 二分查找
---

# 153. 寻找旋转排序数组中的最小值

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。
例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组
 [a[n-1], a[0], a[1], a[2], ..., a[n-2]]。
给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。
请你找出并返回数组中的 最小元素。
你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

示例 1：
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。

示例 2：
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。

示例 3：
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。

## 解题思路

这道题需要在旋转后的有序数组中找到最小值，要求 O(log n) 时间复杂度。

### 二分查找

旋转后的有序数组有一个特点：**最小值右侧的所有元素都小于左侧的所有元素**。

使用二分查找：
1. 如果左半部分有序（nums[left] < nums[mid]），最小值在右半部分
2. 如果右半部分有序（nums[mid] < nums[right]），最小值在左半部分（包含 mid）
3. 如果整个数组有序（nums[left] < nums[right]），最小值就是 nums[left]

### 关键观察

- 如果 nums[mid] > nums[right]，说明最小值在 mid 右侧
- 如果 nums[mid] < nums[right]，说明最小值在 mid 或 mid 左侧

### 算法流程

1. 计算中间位置 mid
2. 比较 nums[mid] 和 nums[right]：
   - 如果 nums[mid] > nums[right]，最小值在 (mid, right]
   - 否则，最小值在 [left, mid]
3. 当 left == right 时，找到最小值

## 代码实现

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        
        while (left < right) {
            // 如果整个区间有序，最小值就是 left
            if (nums[left] < nums[right]) {
                return nums[left];
            }
            
            int mid = left + (right - left) / 2;
            
            // 如果 nums[mid] > nums[right]，最小值在右半部分
            if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else {
                // 否则最小值在左半部分（包含 mid）
                right = mid;
            }
        }
        
        return nums[left];
    }
};
```

## 复杂度分析

- **时间复杂度**：O(log n)，二分查找的时间复杂度。
- **空间复杂度**：O(1)，只使用了常数级别的额外空间。

## 总结

本题使用**二分查找**在旋转有序数组中寻找最小值。关键在于：

1. **旋转数组特性**：最小值右侧的元素都小于左侧的元素
2. **比较策略**：比较 nums[mid] 和 nums[right] 确定最小值位置
3. **有序判断**：如果 nums[left] < nums[right]，整个区间有序

这道题是二分查找的经典应用，理解旋转数组的特性是解题关键。
