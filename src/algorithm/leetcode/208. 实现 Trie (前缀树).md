---
date: 2025-09-08
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 树
---

# 208. 实现 Trie (前缀树)

Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。

请你实现 Trie 类：
- Trie() 初始化前缀树对象。
- void insert(String word) 向前缀树中插入字符串 word 。
- boolean search(String word) 如果字符串 word 在前缀树中，返回 true；否则，返回 false 。
- boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

示例：
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True

## 解题思路

这道题需要实现前缀树（Trie）数据结构。

### 前缀树结构

前缀树是一种多叉树，每个节点包含：
1. **子节点数组**：26 个指针，对应 26 个小写字母
2. **结束标记**：标记是否是单词的结尾

### 核心操作

1. **insert(word)**：
   - 从根节点开始，逐字符遍历
   - 如果子节点不存在，创建新节点
   - 最后标记为单词结尾

2. **search(word)**：
   - 从根节点开始，逐字符遍历
   - 如果子节点不存在，返回 false
   - 最后检查是否是单词结尾

3. **startsWith(prefix)**：
   - 从根节点开始，逐字符遍历
   - 如果子节点不存在，返回 false
   - 遍历完成返回 true（不需要是单词结尾）

### 示例分析

插入 "apple"：
- 根节点 → 'a' → 'p' → 'p' → 'l' → 'e'（标记为结尾）

搜索 "apple"：找到路径且结尾标记为 true → true
搜索 "app"：找到路径但结尾标记为 false → false
startsWith "app"：找到路径 → true

## 代码实现

```cpp
// Trie 节点
class TrieNode {
public:
    TrieNode() {
        // 26 个子节点，对应 26 个小写字母
        nodes = vector<TrieNode*>(26, nullptr);
        // 是否是单词结尾
        isLeaf = false;
    }

    vector<TrieNode*> nodes;  // 子节点数组
    bool isLeaf;              // 单词结尾标记
};

class Trie {
public:
    Trie() {
        head = new TrieNode();  // 初始化根节点
    }
    
    // 插入单词
    void insert(string word) {
        TrieNode* tmp = head;
        
        // 逐字符遍历
        for (int i = 0; i < word.size(); ++i) {
            int wordIndex = word[i] - 'a';  // 计算索引
            
            // 如果子节点不存在，创建新节点
            if (tmp->nodes[wordIndex] == nullptr) {
                tmp->nodes[wordIndex] = new TrieNode();
            }
            
            tmp = tmp->nodes[wordIndex];  // 移动到子节点
        }
        
        tmp->isLeaf = true;  // 标记为单词结尾
    }
    
    // 搜索单词
    bool search(string word) {
        TrieNode* tmp = head;
        
        // 逐字符遍历
        for (int i = 0; i < word.size(); ++i) {
            int wordIndex = word[i] - 'a';
            
            // 如果子节点不存在，单词不存在
            if (tmp->nodes[wordIndex] == nullptr) {
                return false;
            }
            
            tmp = tmp->nodes[wordIndex];
        }
        
        // 返回是否是单词结尾
        return tmp->isLeaf;
    }
    
    // 检查前缀
    bool startsWith(string prefix) {
        TrieNode* tmp = head;
        
        // 逐字符遍历
        for (int i = 0; i < prefix.size(); ++i) {
            int wordIndex = prefix[i] - 'a';
            
            // 如果子节点不存在，前缀不存在
            if (tmp->nodes[wordIndex] == nullptr) {
                return false;
            }
            
            tmp = tmp->nodes[wordIndex];
        }
        
        // 前缀存在
        return true;
    }

private:
    TrieNode* head;  // 根节点
};
```

## 复杂度分析

- **时间复杂度**：
  - insert: O(m)，其中 m 是单词长度
  - search: O(m)
  - startsWith: O(m)

- **空间复杂度**：O(26^m × n)，其中 m 是单词平均长度，n 是单词数量。最坏情况下每个节点都有 26 个子节点。

## 总结

本题实现了**前缀树（Trie）**数据结构。关键在于：

1. **节点结构**：26 个子节点 + 结束标记
2. **插入操作**：逐字符创建节点，标记结尾
3. **搜索操作**：逐字符查找，检查结尾标记
4. **前缀操作**：逐字符查找，不需要检查结尾

前缀树常用于：
- 自动补全
- 拼写检查
- 字符串检索
