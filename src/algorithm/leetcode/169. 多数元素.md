---
date: 2025-10-04
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 数组
---

# 169. 多数元素

给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。

示例 1：
输入：nums = [3,2,3]
输出：3

示例 2：
输入：nums = [2,2,1,1,1,2,2]
输出：2

## 解题思路

这道题需要找到出现次数超过 n/2 的元素。由于多数元素一定存在，可以利用这个特性。

### Boyer-Moore 投票算法

核心思想：**多数元素的个数比其他所有元素的总和还多**。

使用投票法：
1. 维护一个候选元素和计数器
2. 遇到相同元素，计数器加 1
3. 遇到不同元素，计数器减 1
4. 当计数器为 0 时，更换候选元素

### 为什么算法有效？

由于多数元素的数量超过 n/2：
- 多数元素与其他元素的"对抗"中，多数元素一定会胜出
- 即使在最坏情况下（多数元素被其他元素抵消），最终剩下的仍然是多数元素

### 示例分析

`[2,2,1,1,1,2,2]`：
- 初始：target = 2, count = 1
- i=1: nums[1]=2, count = 2
- i=2: nums[2]=1, count = 1
- i=3: nums[3]=1, count = 0, 更换 target = nums[3] = 1, count = 1
- i=4: nums[4]=1, count = 2
- i=5: nums[5]=2, count = 1
- i=6: nums[6]=2, count = 0, 更换 target = nums[6] = 2, count = 1
- 结果：target = 2

## 代码实现

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int count = 1;       // 计数器
        int target = nums[0]; // 候选元素
        
        for (int i = 1; i < nums.size(); ++i) {
            if (nums[i] == target) {
                // 遇到相同元素，计数器加 1
                ++count;
            } else {
                // 遇到不同元素，计数器减 1
                --count;
            }
            
            // 计数器为 0 时，更换候选元素
            if (count == 0) {
                target = nums[i];
                count = 1;
            }
        }
        
        return target;
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，只需遍历一次数组。
- **空间复杂度**：O(1)，只使用了常数级别的额外空间。

## 总结

本题使用**Boyer-Moore 投票算法**找到多数元素。关键在于：

1. **投票思想**：多数元素与其他元素对抗，多数元素一定胜出
2. **O(1) 空间**：不需要哈希表统计频率
3. **一次遍历**：时间复杂度最优

其他解法：
- **哈希表**：统计每个元素的出现次数，O(n) 时间和空间
- **排序**：排序后中间元素一定是多数元素，O(n log n) 时间
