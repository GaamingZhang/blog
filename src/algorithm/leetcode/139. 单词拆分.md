---
date: 2025-08-19
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 动态规划
---

# 139. 单词拆分

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的
 一个或多个单词拼接出 s 则返回 true。
注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

示例 1：
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。

示例 2：
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。

示例 3：
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false

## 解题思路

这道题需要判断字符串是否可以由字典中的单词拼接而成。

### 动态规划

核心思路：`dp[i]` 表示字符串前 i 个字符是否可以由字典中的单词拼接而成。

1. **状态定义**：`dp[i]` 表示 s[0:i] 是否可以由字典中的单词拼接
2. **状态转移**：`dp[i] = dp[j] && s[j:i] in wordDict`，其中 j < i
3. **初始状态**：`dp[0] = true`（空字符串可以由 0 个单词组成）
4. **最终结果**：`dp[s.size()]`

### 算法流程

1. 将字典存入哈希表，方便快速查找
2. 初始化 dp 数组，dp[0] = true
3. 遍历字符串的每个位置 i
4. 对于每个 i，尝试所有可能的分割点 j
5. 如果 dp[j] 为 true 且 s[j:i] 在字典中，则 dp[i] = true
6. 返回 dp[s.size()]

### 优化技巧

- 从后向前遍历分割点 j，找到第一个满足条件的位置即可停止
- 使用哈希表存储字典，O(1) 时间判断单词是否存在

## 代码实现

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        // 将字典存入哈希表，方便快速查找
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        
        // dp[i] 表示 s[0:i] 是否可以由字典中的单词拼接而成
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;  // 空字符串可以由 0 个单词组成
        
        // 遍历字符串的每个位置
        for (int i = 1; i <= s.size(); ++i) {
            // 尝试所有可能的分割点 j
            for (int j = i - 1; j >= 0; --j) {
                // 如果 dp[j] 为 true 且 s[j:i] 在字典中
                if (dp[j] && wordSet.count(s.substr(j, i - j))) {
                    dp[i] = true;
                    break;  // 找到一个满足条件的分割点即可
                }
            }
        }
        
        return dp[s.size()];
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n²)，其中 n 是字符串长度。需要遍历所有子串。
- **空间复杂度**：O(n + m)，其中 n 是字符串长度，m 是字典中单词总长度。dp 数组和哈希表的空间。

## 总结

本题使用**动态规划**解决单词拆分问题。关键在于：

1. **状态定义**：dp[i] 表示前 i 个字符是否可以拼接
2. **状态转移**：尝试所有分割点，找到满足条件的组合
3. **优化**：从后向前遍历，找到即停止

这道题是经典的字符串分割问题，动态规划思路清晰，实现简洁。
