---
date: 2025-09-18
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 树
---

# 211. 添加与搜索单词 - 数据结构设计

请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配。

实现 WordDictionary 类：
- WordDictionary() 初始化词典对象
- void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配
- bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true；否则，返回 false。
  word 中可能包含一些 '.'，每个 . 都可以表示任何一个字母。

示例：
输入：
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
输出：
[null,null,null,null,false,true,true,true]

解释：
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord("bad");
wordDictionary.addWord("dad");
wordDictionary.addWord("mad");
wordDictionary.search("pad"); // 返回 False
wordDictionary.search("bad"); // 返回 True
wordDictionary.search(".ad"); // 返回 True
wordDictionary.search("b.."); // 返回 True

## 解题思路

这道题是第 208 题 Trie 的扩展，需要支持通配符 '.' 的搜索。

### 前缀树 + 递归搜索

基本结构与 Trie 相同，但搜索时需要处理通配符：

1. **添加单词**：与普通 Trie 相同，逐字符插入
2. **搜索单词**：
   - 普通字符：直接匹配
   - 通配符 '.'：递归搜索所有可能的子节点

### 搜索处理

对于通配符 '.'：
- 遍历所有 26 个子节点
- 对每个非空子节点递归搜索剩余字符串
- 只要有一个匹配成功就返回 true

### 算法流程

1. **addWord**：逐字符插入，标记结尾
2. **search**：
   - 遇到普通字符：移动到对应子节点
   - 遇到 '.'：递归搜索所有子节点
   - 字符串结束：检查是否是单词结尾

## 代码实现

```cpp
// Trie 节点
class TrieNode {
public:
    TrieNode() {
        // 26 个子节点，对应 26 个小写字母
        nodes = vector<TrieNode*>(26, nullptr);
        // 是否是单词结尾
        isLeaf = false;
    }

    vector<TrieNode*> nodes;  // 子节点数组
    bool isLeaf;              // 单词结尾标记
};

class WordDictionary {
public:
    WordDictionary() {
        head = new TrieNode();  // 初始化根节点
    }
    
    // 添加单词
    void addWord(string word) {
        TrieNode* tmp = head;
        
        // 逐字符插入
        for (int i = 0; i < word.size(); ++i) {
            int wordIndex = word[i] - 'a';
            if (tmp->nodes[wordIndex] == nullptr) {
                tmp->nodes[wordIndex] = new TrieNode();
            }
            tmp = tmp->nodes[wordIndex];
        }
        
        tmp->isLeaf = true;  // 标记为单词结尾
    }
    
    // 搜索单词
    bool search(string word) {
        return searchHelper(word, head);
    }

private:
    TrieNode* head;  // 根节点
    
    // 递归搜索
    bool searchHelper(string word, TrieNode* node) {
        // 空字符串：检查是否是单词结尾
        if (word.size() == 0) {
            if (node == nullptr) {
                return false;
            }
            return node->isLeaf;
        }
        
        TrieNode* tmp = node;
        
        // 逐字符匹配
        for (int i = 0; i < word.size(); ++i) {
            if (word[i] == '.') {
                // 通配符：递归搜索所有子节点
                bool result = false;
                for (int j = 0; j < 26 && result == false; ++j) {
                    if (tmp->nodes[j] != nullptr) {
                        // 递归搜索剩余字符串
                        result |= searchHelper(word.substr(i + 1), tmp->nodes[j]);
                    }
                }
                return result;
            } else {
                // 普通字符：直接匹配
                int wordIndex = word[i] - 'a';
                if (tmp->nodes[wordIndex] == nullptr) {
                    return false;
                }
                tmp = tmp->nodes[wordIndex];
            }
        }
        
        return tmp->isLeaf;
    }
};
```

## 复杂度分析

- **addWord**：
  - 时间复杂度：O(m)，其中 m 是单词长度
  - 空间复杂度：O(m)，最坏情况下需要创建 m 个新节点

- **search**：
  - 时间复杂度：O(26^m)，最坏情况下每个字符都是 '.'，需要搜索所有路径
  - 空间复杂度：O(m)，递归栈深度

## 总结

本题使用**前缀树 + 递归搜索**实现带通配符的单词搜索。关键在于：

1. **前缀树结构**：与普通 Trie 相同
2. **通配符处理**：递归搜索所有可能的子节点
3. **剪枝优化**：找到匹配就立即返回

与第 208 题的区别在于搜索时需要处理通配符 '.'，使用递归实现。
