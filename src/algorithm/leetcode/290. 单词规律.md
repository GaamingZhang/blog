---
date: 2025-10-02
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 哈希表
---

# 290. 单词规律

给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。
这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 s 中的每个非空单词之间存在
 着双向连接的对应规律。

示例1:
输入: pattern = "abba", s = "dog cat cat dog"
输出: true

示例 2:
输入:pattern = "abba", s = "dog cat cat fish"
输出: false

示例 3:
输入: pattern = "aaaa", s = "dog cat cat dog"
输出：false

## 解题思路

### 问题分析

这道题与 [205. 同构字符串](./205. 同构字符串.md) 非常相似，只是将字符对字符的映射变成了字符对单词的映射。

### 核心条件

1. **一一对应**：pattern 中的每个字符只能映射到 s 中的一个单词
2. **双向唯一**：不同的字符不能映射到同一个单词

### 解决方案

使用两个哈希表分别记录：
- `patternToWord`：记录 pattern 中的字符到 s 中单词的映射
- `wordToPattern`：记录 s 中的单词到 pattern 中字符的映射

遍历 pattern 和 s 中的单词，对于每一对（字符，单词）：
1. 如果两个都没有建立映射，则建立双向映射
2. 如果其中一个有映射而另一个没有，说明不满足一一对应，返回 false
3. 如果两个都有映射，检查映射关系是否一致

### 关键点

- 需要先分割字符串 s 得到单词列表
- pattern 的长度必须与单词数量相等
- 使用双向映射确保一一对应

## 代码实现

```cpp
class Solution {
public:
    bool wordPattern(string pattern, string s) {
        vector<string> words;
        stringstream ss(s);
        string word;
        while (ss >> word) {
            words.push_back(word);
        }
        
        if (pattern.size() != words.size()) {
            return false;
        }
        
        unordered_map<char, string> patternToWord;
        unordered_map<string, char> wordToPattern;
        
        for (int i = 0; i < pattern.size(); ++i) {
            char c = pattern[i];
            string& w = words[i];
            
            if (patternToWord.find(c) == patternToWord.end() && 
                wordToPattern.find(w) == wordToPattern.end()) {
                patternToWord[c] = w;
                wordToPattern[w] = c;
            } else if (patternToWord.find(c) == patternToWord.end() || 
                       wordToPattern.find(w) == wordToPattern.end()) {
                return false;
            } else {
                if (patternToWord[c] != w || wordToPattern[w] != c) {
                    return false;
                }
            }
        }
        
        return true;
    }
};
```

### 代码详解

**分割字符串**：
```cpp
vector<string> words;
stringstream ss(s);
string word;
while (ss >> word) {
    words.push_back(word);
}
```
- 使用 stringstream 按空格分割字符串

**长度检查**：
```cpp
if (pattern.size() != words.size()) {
    return false;
}
```
- pattern 长度必须等于单词数量

**双向映射检查**：
1. 两个都没有映射：建立双向映射
2. 只有一个有映射：返回 false
3. 两个都有映射：检查是否一致

**示例演示**（pattern = "abba", s = "dog cat cat dog"）：
```
words = ["dog", "cat", "cat", "dog"]

i=0: pattern[0]='a', words[0]="dog"
     建立映射: patternToWord['a']="dog", wordToPattern["dog"]='a'

i=1: pattern[1]='b', words[1]="cat"
     建立映射: patternToWord['b']="cat", wordToPattern["cat"]='b'

i=2: pattern[2]='b', words[2]="cat"
     patternToWord['b']="cat" == "cat", 一致

i=3: pattern[3]='a', words[3]="dog"
     patternToWord['a']="dog" == "dog", 一致

返回 true
```

## 复杂度分析

**时间复杂度**：O(n + m)，其中 n 是 pattern 的长度，m 是 s 的长度。需要遍历 pattern 和分割字符串。

**空间复杂度**：O(n)，存储单词列表和映射关系。

## 总结

本题与同构字符串问题本质相同，都是判断双向一一映射：

1. **双向映射**：需要同时维护字符→单词和单词→字符两个方向的映射
2. **一一对应**：确保不同字符不会映射到同一个单词
3. **边界处理**：检查 pattern 长度与单词数量是否相等

这种双映射的思想在处理模式匹配问题时非常有效，是解决此类问题的经典方法。
