---
date: 2025-09-29
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 双指针
---

# 228. 汇总区间

给定一个  无重复元素 的 有序 整数数组 nums 。
区间 [a,b] 是从 a 到 b（包含）的所有整数的集合。
返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个区间但不属于 nums 的数字 x 。
列表中的每个区间范围 [a,b] 应该按如下格式输出：
"a->b" ，如果 a != b
"a" ，如果 a == b

示例 1：
输入：nums = [0,1,2,4,5,7]
输出：["0->2","4->5","7"]
解释：区间范围是：
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"

示例 2：
输入：nums = [0,2,3,4,6,8,9]
输出：["0","2->4","6","8->9"]
解释：区间范围是：
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"

## 解题思路

这道题要求将有序数组中的连续数字合并成区间。

### 核心思想

1. **识别连续区间**：遍历数组，找出连续的数字序列
2. **判断连续性**：如果 `nums[i] + 1 == nums[i+1]`，则两个数字连续
3. **生成区间**：
   - 如果区间只有一个数字，输出 "a"
   - 如果区间有多个数字，输出 "a->b"

### 双指针方法

使用两个指针：
- `start`：区间起始位置
- `end`：区间结束位置

遍历数组，当遇到不连续的数字时，生成当前区间并更新起始位置。

## 代码实现

```cpp
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        vector<string> result;
        int n = nums.size();
        int i = 0;
        
        while (i < n) {
            int start = i;
            
            while (i + 1 < n && nums[i] + 1 == nums[i + 1]) {
                i++;
            }
            
            if (start == i) {
                result.push_back(to_string(nums[start]));
            } else {
                result.push_back(to_string(nums[start]) + "->" + to_string(nums[i]));
            }
            
            i++;
        }
        
        return result;
    }
};
```

### 代码详解

**变量说明**：
- `start`：当前区间的起始索引
- `i`：当前遍历位置，同时也是区间结束索引

**遍历过程**：
1. 外层循环：遍历数组的每个位置
2. 内层循环：找到连续区间的结束位置
3. 生成区间字符串：
   - `start == i`：单元素区间
   - `start != i`：多元素区间

**示例演示**（nums = [0,1,2,4,5,7]）：
```
i=0: start=0
  nums[0]+1=1 == nums[1]=1, i++
  nums[1]+1=2 == nums[2]=2, i++
  nums[2]+1=3 != nums[3]=4, 退出内层循环
  start=0, i=2, 生成 "0->2"
  i++ -> i=3

i=3: start=3
  nums[3]+1=5 == nums[4]=5, i++
  nums[4]+1=6 != nums[5]=7, 退出内层循环
  start=3, i=4, 生成 "4->5"
  i++ -> i=5

i=5: start=5
  i+1=6 >= n=6, 退出内层循环
  start=5, i=5, 生成 "7"
  i++ -> i=6

结束，结果 = ["0->2","4->5","7"]
```

## 复杂度分析

**时间复杂度**：O(n)，遍历一次数组

**空间复杂度**：O(1)，不考虑结果数组的空间，只使用常数额外空间

## 总结

本题是一道简单的区间合并问题，关键在于：

1. **识别连续性**：通过比较相邻元素判断是否连续
2. **双指针技巧**：使用 start 和 end 指针标记区间范围
3. **格式化输出**：根据区间长度选择不同的输出格式

这种"找连续区间"的思路在很多场景都有应用，比如日志分析、时间区间统计等。理解如何正确处理边界条件是解决此类问题的关键。
