---
date: 2025-09-28
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 字符串
  - 哈希表
---

# 242. 有效的字母异位词

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的 字母异位词。

示例 1:
输入: s = "anagram", t = "nagaram"
输出: true

示例 2:
输入: s = "rat", t = "car"
输出：false

## 解题思路

### 问题分析

字母异位词是指两个字符串包含相同的字符，但字符的顺序可能不同。换句话说，如果两个字符串是字母异位词，那么它们排序后应该完全相同。

### 方法一：排序

将两个字符串排序，然后比较是否相等。

### 方法二：哈希表（计数法）

统计每个字符出现的次数：
1. 遍历字符串 s，统计每个字符出现的次数
2. 遍历字符串 t，减少对应字符的计数
3. 如果所有计数都为 0，则是字母异位词

### 方法选择

方法二的时间复杂度更优（O(n) vs O(n log n)），且空间复杂度相同。

## 代码实现

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.size() != t.size()) {
            return false;
        }
        
        vector<int> count(26, 0);
        
        for (char c : s) {
            count[c - 'a']++;
        }
        
        for (char c : t) {
            count[c - 'a']--;
            if (count[c - 'a'] < 0) {
                return false;
            }
        }
        
        return true;
    }
};
```

### 代码详解

**边界检查**：
```cpp
if (s.size() != t.size()) {
    return false;
}
```
- 长度不同，不可能是字母异位词

**统计字符计数**：
```cpp
for (char c : s) {
    count[c - 'a']++;
}
```
- 使用长度为 26 的数组统计每个字母出现的次数

**验证并减少计数**：
```cpp
for (char c : t) {
    count[c - 'a']--;
    if (count[c - 'a'] < 0) {
        return false;
    }
}
```
- 遍历字符串 t，减少对应字符的计数
- 如果计数变为负数，说明 t 中有 s 没有的字符或数量过多

**示例演示**：
```
s = "anagram", t = "nagaram"

遍历 s：
count: a=3, n=1, g=1, r=1, m=1

遍历 t：
n: count['n']=0
a: count['a']=2
g: count['g']=0
a: count['a']=1
r: count['r']=0
a: count['a']=0
m: count['m']=0

所有计数都为 0，返回 true
```

## 复杂度分析

**时间复杂度**：O(n)，其中 n 是字符串的长度。需要遍历两个字符串各一次。

**空间复杂度**：O(1)，使用固定大小的数组（26 个字母）。

## 总结

本题是判断两个字符串是否为字母异位词的经典问题：

1. **核心思想**：统计字符出现次数，比较是否相同
2. **优化技巧**：在第二次遍历时同时验证，提前发现不匹配
3. **空间优化**：使用数组代替哈希表，因为字符范围固定（26 个字母）

这种"计数法"在处理字符串问题时非常常见，类似的还有判断两个字符串是否有相同字符、找出字符串中的异位词等问题。
