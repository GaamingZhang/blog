---
date: 2025-09-20
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 动态规划
---

# 213. 打家劫舍 II

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈，
 这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗统，
 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下，
 今晚能够偷窃到的最高金额。

示例 1：
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

示例 2：
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。

示例 3：
输入：nums = [1,2,3]
输出：3

## 解题思路

这道题是 [198. 打家劫舍](./198. 打家劫舍.md) 的进阶版本，房屋围成一圈，首尾相连。

### 问题分析

由于房屋围成一圈，第一个房屋和最后一个房屋相邻，不能同时偷窃。因此问题转化为两种情况：

1. **偷窃第一个房屋**：不能偷窃最后一个房屋，范围是 [0, n-2]
2. **不偷窃第一个房屋**：可以偷窃最后一个房屋，范围是 [1, n-1]

### 动态规划状态转移

对于线性排列的房屋，使用动态规划：
- `dp[i]` 表示偷窃前 i 个房屋能获得的最大金额
- 状态转移方程：`dp[i] = max(dp[i-1], dp[i-2] + nums[i-1])`
  - 不偷第 i 个房屋：`dp[i-1]`
  - 偷第 i 个房屋：`dp[i-2] + nums[i-1]`

### 解决方案

将环形问题拆分为两个线性问题：
1. 计算 [0, n-2] 范围内的最大值（不偷最后一个）
2. 计算 [1, n-1] 范围内的最大值（不偷第一个）
3. 取两者的最大值

## 代码实现

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) {
            return nums[0];
        }
        if (n == 2) {
            return max(nums[0], nums[1]);
        }
        
        int result1 = robRange(nums, 0, n - 2);
        int result2 = robRange(nums, 1, n - 1);
        
        return max(result1, result2);
    }
    
private:
    int robRange(vector<int>& nums, int start, int end) {
        int prev2 = 0;
        int prev1 = nums[start];
        
        for (int i = start + 1; i <= end; ++i) {
            int current = max(prev1, prev2 + nums[i]);
            prev2 = prev1;
            prev1 = current;
        }
        
        return prev1;
    }
};
```

### 代码详解

**边界处理**：
- 只有一间房屋：直接返回 `nums[0]`
- 只有两间房屋：返回较大值

**robRange 函数**：
- 计算线性排列房屋的最大偷窃金额
- `prev2`：前前一个位置的最大值
- `prev1`：前一个位置的最大值
- 状态转移：`current = max(prev1, prev2 + nums[i])`

**主函数逻辑**：
1. `result1`：偷窃范围 [0, n-2]，即偷第一个不偷最后一个
2. `result2`：偷窃范围 [1, n-1]，即不偷第一个偷最后一个
3. 返回两者的最大值

**示例演示**（nums = [1,2,3,1]）：
```
情况1：偷窃 [0, 2] = [1, 2, 3]
  i=1: current = max(1, 0+2) = 2, prev2=1, prev1=2
  i=2: current = max(2, 1+3) = 4, prev2=2, prev1=4
  result1 = 4

情况2：偷窃 [1, 3] = [2, 3, 1]
  i=2: current = max(2, 0+3) = 3, prev2=2, prev1=3
  i=3: current = max(3, 2+1) = 3, prev2=3, prev1=3
  result2 = 3

最终结果：max(4, 3) = 4
```

## 复杂度分析

**时间复杂度**：O(n)，需要遍历数组两次（分别计算两种情况）

**空间复杂度**：O(1)，只使用了常数级别的额外空间（空间优化的动态规划）

## 总结

本题是打家劫舍问题的环形版本，关键在于：

1. **问题转化**：将环形问题拆分为两个线性问题
2. **动态规划**：使用状态转移方程求解线性问题
3. **空间优化**：使用滚动变量代替数组，降低空间复杂度

这种"拆分环形为线性"的思路在处理环形数组问题时很常见，类似的还有环形子数组最大和等问题。核心思想是通过枚举首尾的选择情况，将复杂的环形约束转化为简单的线性约束。
