---
date: 2025-11-02
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 链表
---

# 138. 随机链表的复制

给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。
构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。
新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示
 相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。
例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y 。那么在复制链表中对应的两个节点 x 和 y ，
 同样有 x.random --> y 。返回复制链表的头节点。
用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：
val：一个表示 Node.val 的整数。
random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。
你的代码 只 接受原链表的头节点 head 作为传入参数。

示例 1：
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]

## 解题思路

这道题需要复制一个带有随机指针的链表，实现深拷贝。

### 哈希表法

核心思路：使用哈希表记录原节点到新节点的映射。

1. **第一次遍历**：创建新链表，建立原节点到新节点的映射
2. **第二次遍历**：根据映射关系，设置新节点的 random 指针

### 为什么需要两次遍历？

- 第一次遍历时，random 指向的节点可能还未创建
- 需要先创建所有节点，建立映射关系
- 然后才能正确设置 random 指针

### 算法流程

1. 遍历原链表，创建新节点，建立映射
2. 再次遍历，根据映射设置 random 指针
3. 返回新链表头节点

## 代码实现

```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        // 空链表直接返回
        if (head == nullptr) {
            return nullptr;
        }
        
        // 哈希表：原节点 -> 新节点
        unordered_map<Node*, Node*> oldToNew;
        
        // 第一次遍历：创建新链表，建立映射
        Node* newHead = createNewList(head, oldToNew);
        
        // 第二次遍历：设置 random 指针
        setRandomPointers(head, newHead, oldToNew);
        
        return newHead;
    }

private:
    // 创建新链表，建立原节点到新节点的映射
    Node* createNewList(Node* head, unordered_map<Node*, Node*>& oldToNew) {
        Node* newHead = nullptr;      // 新链表头节点
        Node* newCurrent = nullptr;   // 新链表当前节点
        Node* oldCurrent = head;      // 原链表当前节点
        
        while (oldCurrent != nullptr) {
            // 创建新节点
            Node* newNode = new Node(oldCurrent->val);
            
            // 连接到新链表
            if (newCurrent != nullptr) {
                newCurrent->next = newNode;
            }
            newCurrent = newNode;
            
            // 记录新链表头节点
            if (newHead == nullptr) {
                newHead = newNode;
            }
            
            // 建立映射
            oldToNew[oldCurrent] = newNode;
            
            // 移动到下一个节点
            oldCurrent = oldCurrent->next;
        }
        
        return newHead;
    }
    
    // 设置新链表的 random 指针
    void setRandomPointers(Node* oldHead, Node* newHead, 
                          unordered_map<Node*, Node*>& oldToNew) {
        while (oldHead != nullptr && newHead != nullptr) {
            // 根据 mapping 设置 random 指针
            if (oldHead->random != nullptr) {
                newHead->random = oldToNew[oldHead->random];
            }
            
            // 移动到下一个节点
            oldHead = oldHead->next;
            newHead = newHead->next;
        }
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是链表长度。需要遍历两次链表。
- **空间复杂度**：O(n)，哈希表存储所有节点的映射。

## 总结

本题使用**哈希表法**实现带随机指针链表的深拷贝。关键在于：

1. **两次遍历**：第一次创建节点，第二次设置 random
2. **哈希表映射**：记录原节点到新节点的对应关系
3. **深拷贝**：确保新链表完全独立于原链表

进阶解法：可以在原链表上直接插入新节点，然后拆分，实现 O(1) 空间复杂度。
