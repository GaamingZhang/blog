---
date: 2025-10-21
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 动态规划
---

# 123. 买卖股票的最佳时机 III

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，
 这笔交易所能获得利润 = 3-0 = 3 。
随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，
 这笔交易所能获得利润 = 4-1 = 3 。

示例 2：
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 
 这笔交易所能获得利润 = 5-1 = 4 。   
注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3：
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。

示例 4：
输入：prices = [1]
输出：0

## 解题思路

这道题是股票问题的进阶版，最多可以完成**两笔交易**。

### 动态规划

定义状态：
- `buy[j]`：第 j 次买入后的最大利润
- `sell[j]`：第 j 次卖出后的最大利润

状态转移：
- `buy[j] = max(buy[j], sell[j-1] - prices[i])`：第 j 次买入，可以是之前已经买入，或者是今天买入（需要先完成第 j-1 次卖出）
- `sell[j] = max(sell[j], buy[j] + prices[i])`：第 j 次卖出，可以是之前已经卖出，或者是今天卖出

### 初始状态

- `buy[j] = -prices[0]`：第一天买入
- `sell[j] = 0`：第一天无法卖出

### 算法流程

1. 初始化 buy 和 sell 数组
2. 遍历每一天，更新 buy 和 sell 状态
3. 最终结果为 `sell[k]`（k=2）

## 代码实现

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int k = 2;  // 最多两笔交易
        
        // buy[j] 表示第 j 次买入后的最大利润
        vector<int> buy(k + 1, -prices[0]);
        // sell[j] 表示第 j 次卖出后的最大利润
        vector<int> sell(k + 1, 0);
        
        // 从第二天开始遍历
        for (int i = 1; i < n; ++i) {
            // 更新每次交易的状态
            for (int j = 1; j <= k; ++j) {
                // 第 j 次买入：之前已买入 或 今天买入（需要先完成第 j-1 次卖出）
                buy[j] = max(buy[j], sell[j - 1] - prices[i]);
                // 第 j 次卖出：之前已卖出 或 今天卖出
                sell[j] = max(sell[j], buy[j] + prices[i]);
            }
        }
        
        // 返回第 k 次卖出后的最大利润
        return sell[k];
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n × k)，其中 n 是数组长度，k 是交易次数（本题 k=2）。
- **空间复杂度**：O(k)，使用两个长度为 k+1 的数组。

## 总结

本题使用**动态规划**解决最多两笔交易的股票问题。关键在于：

1. 定义状态：`buy[j]` 和 `sell[j]` 分别表示第 j 次买入和卖出后的最大利润
2. 状态转移：买入依赖于上一次卖出，卖出依赖于当前买入
3. 初始化：第一天可以买入，但不能卖出

这个解法可以推广到任意 k 次交易的情况（第 188 题）。
