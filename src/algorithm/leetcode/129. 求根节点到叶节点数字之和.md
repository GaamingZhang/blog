---
date: 2025-07-18
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 二叉树
---

# 129. 求根节点到叶节点数字之和

给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：
例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。
叶节点 是指没有子节点的节点。

示例 1：
输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25

示例 2：
输入：root = [4,9,0,5,1]
输出：1026
解释：
从根到叶子节点路径 4->9->5 代表数字 495
从根到叶子节点路径 4->9->1 代表数字 491
从根到叶子节点路径 4->0 代表数字 40
因此，数字总和 = 495 + 491 + 40 = 1026

## 解题思路

这道题需要计算从根节点到所有叶节点路径所代表的数字之和。

### 深度优先搜索（DFS）

使用递归遍历二叉树：

1. 从根节点开始，记录当前路径的数字
2. 每经过一个节点，当前数字 = 前一个数字 × 10 + 当前节点值
3. 到达叶节点时，将当前数字累加到结果中

### 数字构建方式

路径 1 -> 2 -> 3 表示数字 123：
- 初始：value = 0
- 经过 1：value = 0 × 10 + 1 = 1
- 经过 2：value = 1 × 10 + 2 = 12
- 经过 3：value = 12 × 10 + 3 = 123

### 算法流程

1. 递归遍历每个节点
2. 更新当前路径数字：value = value × 10 + node->val
3. 如果是叶节点，返回当前数字
4. 否则返回左右子树的结果之和

## 代码实现

```cpp
class Solution {
public:
    int sumNumbers(TreeNode* root) {
        return sumNumbers(root, 0);
    }

private:
    // value 表示从根节点到当前节点路径所代表的数字
    int sumNumbers(TreeNode* root, int value) {
        // 空节点返回 0
        if (root == nullptr) {
            return 0;
        }
        
        // 更新当前路径数字
        value = value * 10 + root->val;
        
        // 如果是叶节点，返回当前数字
        if (root->left == nullptr && root->right == nullptr) {
            return value;
        }
        
        // 递归计算左右子树的结果之和
        return sumNumbers(root->left, value) + sumNumbers(root->right, value);
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是树中节点数。每个节点只访问一次。
- **空间复杂度**：O(h)，其中 h 是树的高度。递归调用栈的深度取决于树的高度。

## 总结

本题使用**深度优先搜索（DFS）**递归遍历二叉树。关键在于：

1. **数字构建**：每经过一个节点，value = value × 10 + node->val
2. **叶节点判断**：左右子节点都为空时返回当前数字
3. **结果累加**：所有叶节点的数字之和

这种方法避免了存储所有路径，直接在递归过程中累加结果，空间效率高。
