---
date: 2025-07-30
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 位运算
---

# 137. 只出现一次的数字 II

给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次。
请你找出并返回那个只出现了一次的元素。
你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。

示例 1：
输入：nums = [2,2,3,2]
输出：3

示例 2：
输入：nums = [0,1,0,1,0,1,99]
输出：99

## 解题思路

这道题是第 136 题的进阶版，其他元素出现三次而不是两次，无法直接使用异或运算。

### 逐位统计法

核心思路：**统计每个二进制位上 1 出现的次数**。

1. 对于每个二进制位（共 32 位），统计所有数字在该位上 1 的个数
2. 如果某个位上 1 的个数不是 3 的倍数，说明只出现一次的数字在该位上是 1
3. 根据这个规律，逐位构建结果

### 原理解释

- 出现三次的数字，在每个二进制位上 1 的个数都是 3 的倍数
- 只出现一次的数字，会使得某些位上 1 的个数不是 3 的倍数
- 通过取模运算，可以确定只出现一次的数字在每个位上的值

### 算法流程

1. 遍历 32 个二进制位
2. 对于每个位，统计所有数字在该位上 1 的个数
3. 如果个数 % 3 != 0，则结果在该位上为 1
4. 最终构建出只出现一次的数字

## 代码实现

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int result = 0;
        
        // 遍历 32 个二进制位
        for (int i = 0; i < 32; ++i) {
            int bitCount = 0;  // 统计当前位上 1 的个数
            
            // 统计所有数字在第 i 位上 1 的个数
            for (int j = 0; j < nums.size(); ++j) {
                // 右移 i 位后与 1，得到第 i 位的值
                bitCount += ((nums[j] >> i) & 1);
            }
            
            // 如果 1 的个数不是 3 的倍数，说明结果在该位上是 1
            if (bitCount % 3) {
                result |= (1 << i);  // 将结果的第 i 位置为 1
            }
        }
        
        return result;
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组长度。需要遍历 32 次，每次遍历整个数组，但 32 是常数。
- **空间复杂度**：O(1)，只使用了常数级别的额外空间。

## 总结

本题使用**逐位统计法**解决出现三次的问题。关键在于：

1. **位运算思想**：将问题分解为每个二进制位的统计
2. **取模判断**：通过 % 3 判断只出现一次的数字在该位上的值
3. **常数空间**：不需要哈希表等额外数据结构

进阶解法：可以使用数字逻辑电路的设计思想，用两个变量记录出现一次和两次的状态，实现更优雅的解法。
