---
date: 2025-11-16
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 动态规划
---


# 188. 买卖股票的最佳时机 IV

给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，
 你最多可以买 k 次，卖 k 次。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1：
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候
 卖出，这笔交易所能获得利润 = 4-2 = 2 。

示例 2：
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候
 卖出, 这笔交易所能获得利润 = 6-2 = 4 。
随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 
 这笔交易所能获得利润 = 3-0 = 3 。

## 解题思路

这道题是买卖股票系列问题中最通用的情况，允许最多完成 k 笔交易。需要使用动态规划来解决。

### 状态定义

定义两个数组：
- `buy[j]`：表示第 j 笔交易买入后的最大收益（持有股票状态）
- `sell[j]`：表示第 j 笔交易卖出后的最大收益（不持有股票状态）

### 状态转移方程

对于每一天的价格 `prices[i]`，更新所有可能的交易状态：

1. **买入状态转移**：
   - `buy[j] = max(buy[j], sell[j-1] - prices[i])`
   - 要么保持之前的买入状态，要么在第 j 笔交易时买入（前提是第 j-1 笔交易已卖出）

2. **卖出状态转移**：
   - `sell[j] = max(sell[j], buy[j] + prices[i])`
   - 要么保持之前的卖出状态，卖出第 j 笔交易买入的股票

### 初始化

- `buy[j] = -prices[0]`：第一天买入，收益为负的股价
- `sell[j] = 0`：第一天无法卖出，收益为 0

### 关键点

1. **交易顺序**：必须先完成第 j-1 笔交易的卖出，才能进行第 j 笔交易的买入
2. **空间优化**：使用一维数组代替二维数组，降低空间复杂度
3. **边界处理**：当 k 大于等于天数的一半时，问题退化为不限交易次数的情况

## 代码实现

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        if (prices.empty() || k == 0) return 0;
        
        int n = prices.size();
        
        if (k >= n / 2) {
            return maxProfitUnlimited(prices);
        }
        
        vector<int> buy(k + 1, -prices[0]);
        vector<int> sell(k + 1, 0);
        
        for (int i = 1; i < n; ++i) {
            for (int j = 1; j <= k; ++j) {
                buy[j] = max(buy[j], sell[j - 1] - prices[i]);
                sell[j] = max(sell[j], buy[j] + prices[i]);
            }
        }
        
        return sell[k];
    }
    
private:
    int maxProfitUnlimited(vector<int>& prices) {
        int profit = 0;
        for (int i = 1; i < prices.size(); ++i) {
            if (prices[i] > prices[i - 1]) {
                profit += prices[i] - prices[i - 1];
            }
        }
        return profit;
    }
};
```

### 代码详解

**主函数 `maxProfit`**：
1. 边界检查：如果价格为空或 k 为 0，直接返回 0
2. 优化处理：当 k >= n/2 时，交易次数不受限制，调用贪心算法
3. 初始化 `buy` 数组为 `-prices[0]`，表示第一天买入
4. 初始化 `sell` 数组为 0，表示未进行任何卖出
5. 遍历每一天，更新所有交易状态
6. 返回 `sell[k]`，即完成 k 笔交易后的最大收益

**辅助函数 `maxProfitUnlimited`**：
- 当交易次数不受限时，使用贪心算法
- 只要有利润就进行交易，累加所有正收益

**状态转移过程**（以示例 2 为例）：
```
prices = [3, 2, 6, 5, 0, 3], k = 2

初始状态：
buy = [0, -3, -3]
sell = [0, 0, 0]

第 2 天 (price = 2):
buy[1] = max(-3, 0-2) = -2
sell[1] = max(0, -2+2) = 0
buy[2] = max(-3, 0-2) = -2
sell[2] = max(0, -2+2) = 0

第 3 天 (price = 6):
buy[1] = max(-2, 0-6) = -2
sell[1] = max(0, -2+6) = 4
buy[2] = max(-2, 4-6) = -2
sell[2] = max(0, -2+6) = 4

... 最终 sell[2] = 7
```

## 复杂度分析

**时间复杂度**：O(n × min(k, n))
- 外层循环遍历 n 天
- 内层循环遍历 k 次交易
- 当 k >= n/2 时，退化为 O(n)

**空间复杂度**：O(k)
- 使用两个长度为 k+1 的一维数组
- 当 k >= n/2 时，空间复杂度为 O(1)

## 总结

本题是买卖股票系列问题中最通用的形式，关键在于：

1. **状态定义**：用两个数组分别表示买入和卖出状态
2. **状态转移**：买入依赖上一次卖出，卖出依赖当前买入
3. **优化策略**：当交易次数足够大时，退化为贪心问题
4. **空间优化**：使用一维数组代替二维数组

这道题是 [123. 买卖股票的最佳时机 III](./123. 买卖股票的最佳时机 III.md) 的推广版本，将交易次数从 2 扩展到 k。理解这道题的关键是掌握动态规划状态转移的本质，以及如何根据问题特性进行优化。
