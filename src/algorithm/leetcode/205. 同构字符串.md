---
date: 2025-08-22
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 哈希表
---

# 205. 同构字符串

给定两个字符串 s 和 t ，判断它们是否是同构的。
如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。
每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，
相同字符只能映射到同一个字符上，字符可以映射到自己本身。

示例 1:
输入：s = "egg", t = "add"
输出：true

示例 2：
输入：s = "foo", t = "bar"
输出：false

示例 3：
输入：s = "paper", t = "title"
输出：true

## 解题思路

这道题要求判断两个字符串是否同构。同构的定义是：s 中的每个字符都可以通过一一映射替换为 t 中对应位置的字符。

### 核心条件

1. **一一对应**：s 中的每个字符只能映射到 t 中的一个字符
2. **双向唯一**：不同字符不能映射到同一个字符，即映射是双向唯一的

### 解决方案

使用两个哈希表分别记录：
- `s2t`：记录 s 中的字符到 t 中字符的映射
- `t2s`：记录 t 中的字符到 s 中字符的映射

遍历字符串，对于每一对字符 (s[i], t[i])：
1. 如果两个字符都没有建立映射，则建立双向映射
2. 如果其中一个有映射而另一个没有，说明不满足一一对应，返回 false
3. 如果两个都有映射，检查映射关系是否一致

### 示例分析

**示例 1：s = "egg", t = "add"**
```
i=0: s[0]='e', t[0]='a'
     s2t 和 t2s 都为空，建立映射 s2t['e']='a', t2s['a']='e'
i=1: s[1]='g', t[1]='d'
     s2t 和 t2s 都没有对应映射，建立映射 s2t['g']='d', t2s['d']='g'
i=2: s[2]='g', t[2]='d'
     s2t['g']='d', t2s['d']='g'，映射一致
结果：true
```

**示例 2：s = "foo", t = "bar"**
```
i=0: s[0]='f', t[0]='b'
     建立映射 s2t['f']='b', t2s['b']='f'
i=1: s[1]='o', t[1]='a'
     建立映射 s2t['o']='a', t2s['a']='o'
i=2: s[2]='o', t[2]='r'
     s2t['o']='a'，但 t[2]='r' != 'a'，映射不一致
结果：false
```

## 代码实现

```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        if (s.size() != t.size()) {
            return false;
        }
        
        unordered_map<char, char> s2t, t2s;
        
        for (int i = 0; i < s.size(); ++i) {
            if (s2t.find(s[i]) == s2t.end() && t2s.find(t[i]) == t2s.end()) {
                s2t[s[i]] = t[i];
                t2s[t[i]] = s[i];
            } else if (s2t.find(s[i]) == s2t.end() || t2s.find(t[i]) == t2s.end()) {
                return false;
            } else {
                if (t[i] != s2t[s[i]] || s[i] != t2s[t[i]]) {
                    return false;
                }
            }
        }
        
        return true;
    }
};
```

### 代码详解

**边界检查**：
- 如果两个字符串长度不同，直接返回 false

**双哈希表**：
- `s2t`：记录从 s 到 t 的字符映射
- `t2s`：记录从 t 到 s 的字符映射

**三种情况处理**：

1. **两个字符都没有映射**：
   ```cpp
   if (s2t.find(s[i]) == s2t.end() && t2s.find(t[i]) == t2s.end())
   ```
   建立双向映射

2. **只有一个字符有映射**：
   ```cpp
   else if (s2t.find(s[i]) == s2t.end() || t2s.find(t[i]) == t2s.end())
   ```
   说明违反了一一对应原则，返回 false

3. **两个字符都有映射**：
   ```cpp
   else {
       if (t[i] != s2t[s[i]] || s[i] != t2s[t[i]]) {
           return false;
       }
   }
   ```
   检查映射关系是否一致

## 复杂度分析

**时间复杂度**：O(n)，其中 n 是字符串的长度。只需遍历一次字符串，哈希表操作是 O(1)。

**空间复杂度**：O(k)，其中 k 是字符集的大小。最坏情况下需要存储所有字符的映射关系。

## 总结

本题的关键在于理解"同构"的含义，即字符之间的一一对应关系。使用双哈希表可以有效地检测这种双向映射：

1. **双向映射**：需要同时维护 s→t 和 t→s 两个方向的映射
2. **一一对应**：确保不同字符不会映射到同一个字符
3. **哈希表应用**：利用哈希表快速查找和更新映射关系

这种双映射的思想在处理字符串匹配、模式识别等问题中很常见，是解决此类问题的经典方法。
