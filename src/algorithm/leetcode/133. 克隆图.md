---
date: 2025-07-22
author: Gaaming Zhang
isOriginal: true
article: true
category: 
  - leetcode
tag:
  - leetcode
  - 深度优先搜索
---

# 133. 克隆图

给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。
图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。

```cpp
class Node {
    public int val;
    public List<Node> neighbors;
};
```

测试用例格式：
简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），
 以此类推。该图在测试用例中使用邻接列表表示。
邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。
给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。

示例 1：
输入：adjList = [[2,4],[1,3],[2,4],[1,3]]
输出：[[2,4],[1,3],[2,4],[1,3]]
解释：
图中有 4 个节点。
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。

## 解题思路

这道题需要克隆一个无向连通图，实现深拷贝。

### 深度优先搜索（DFS）

使用 DFS 递归遍历图，同时创建克隆节点：

1. **哈希表记录映射**：使用哈希表记录原节点到克隆节点的映射
2. **递归克隆**：对于每个节点，创建克隆节点，然后递归克隆其邻居
3. **避免重复克隆**：如果节点已经被克隆过，直接返回克隆节点

### 算法流程

1. 如果节点为空，返回空
2. 如果节点已经被克隆过，返回克隆节点
3. 创建新的克隆节点
4. 记录原节点到克隆节点的映射
5. 递归克隆所有邻居，添加到克隆节点的邻居列表
6. 返回克隆节点

## 代码实现

```cpp
class Solution {
public:
    Node* cloneGraph(Node* node) {
        // 空节点直接返回
        if (node == nullptr) {
            return nullptr;
        }
        
        // 如果节点已经被克隆过，直接返回克隆节点
        if (copyMap.contains(node)) {
            return copyMap[node];
        }
        
        // 创建新的克隆节点
        Node* copyNode = new Node(node->val);
        
        // 记录原节点到克隆节点的映射
        copyMap[node] = copyNode;
        
        // 递归克隆所有邻居
        for (int i = 0; i < node->neighbors.size(); ++i) {
            Node* neighborCopy = cloneGraph(node->neighbors[i]);
            copyNode->neighbors.push_back(neighborCopy);
        }
        
        return copyNode;
    }

private:
    // 哈希表：原节点 -> 克隆节点
    unordered_map<Node*, Node*> copyMap;
};
```

## 复杂度分析

- **时间复杂度**：O(N)，其中 N 是图中的节点数。每个节点只被访问一次。
- **空间复杂度**：O(N)，哈希表存储所有节点的映射，以及递归调用栈的深度。

## 总结

本题使用**DFS + 哈希表**实现图的深拷贝。关键在于：

1. **哈希表记录映射**：避免重复克隆同一节点
2. **递归克隆邻居**：保证图的连通性
3. **深拷贝**：创建全新的节点和连接关系

这种方法也可以用 BFS 实现，使用队列进行广度优先遍历。
