---
date: 2025-09-30
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 二叉树
  - 递归
---

# 236. 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为："对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是
 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。"

示例 1：
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。

示例 2：
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。

示例 3：
输入：root = [1,2], p = 1, q = 2
输出：1

## 解题思路

### 问题分析

最近公共祖先（LCA）是指两个节点 p 和 q 的所有公共祖先中，深度最大的那个节点。

### 递归思路

从根节点开始递归遍历，对于每个节点：

1. **终止条件**：
   - 如果当前节点为空，返回空
   - 如果当前节点等于 p 或 q，返回当前节点

2. **递归左右子树**：
   - 在左子树中查找 p 和 q
   - 在右子树中查找 p 和 q

3. **根据左右子树结果判断**：
   - 如果左右子树都找到了节点，说明 p 和 q 分别在当前节点的两侧，当前节点就是 LCA
   - 如果只有一边找到，说明 p 和 q 都在这一侧，返回找到的那一边
   - 如果两边都没找到，返回空

### 关键理解

- 如果一个节点是 p 和 q 的祖先，那么 p 和 q 要么都在它的左子树，要么都在它的右子树，要么分别在两侧
- 最近公共祖先的特点：p 和 q 分别在其左右子树中，或者该节点本身就是 p 或 q

## 代码实现

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr || root == p || root == q) {
            return root;
        }
        
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        
        if (left != nullptr && right != nullptr) {
            return root;
        }
        
        return left != nullptr ? left : right;
    }
};
```

### 代码详解

**终止条件**：
```cpp
if (root == nullptr || root == p || root == q) {
    return root;
}
```
- 遇到空节点，返回空
- 遇到 p 或 q，返回该节点

**递归查找**：
```cpp
TreeNode* left = lowestCommonAncestor(root->left, p, q);
TreeNode* right = lowestCommonAncestor(root->right, p, q);
```
- 分别在左右子树中查找 p 和 q

**结果判断**：
```cpp
if (left != nullptr && right != nullptr) {
    return root;  // p 和 q 分别在两侧，当前节点是 LCA
}
return left != nullptr ? left : right;  // 返回非空的那一边
```

**示例演示**（root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1）：
```
        3
       / \
      5   1
     / \ / \
    6  2 0  8
      / \
     7   4

递归过程：
- 节点 3：left=5(找到p), right=1(找到q)
  - 左右都不为空，返回 3
  
- 节点 5：等于 p，直接返回 5
- 节点 1：等于 q，直接返回 1

最终结果：3
```

## 复杂度分析

**时间复杂度**：O(n)，最坏情况下需要遍历所有节点

**空间复杂度**：O(n)，递归栈深度，最坏情况（树退化为链表）为 n

## 总结

本题是二叉树经典的 LCA 问题，关键在于：

1. **递归思想**：自底向上查找，找到 p 或 q 就返回
2. **判断逻辑**：
   - 左右都找到：当前节点是 LCA
   - 只有一边找到：LCA 在那一侧
   - 都没找到：返回空

3. **特殊情况处理**：
   - 一个节点是另一个的祖先
   - p 或 q 就是根节点

这种递归解法简洁优雅，是解决 LCA 问题的经典方法。对于更复杂的场景（如多次查询），可以考虑使用 Tarjan 算法或倍增法进行优化。
