---
date: 2025-11-15
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 二叉树
  - 栈
  - 设计
---


# 173. 二叉搜索树迭代器

实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：
BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数
 的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。
boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。
int next()将指针向右移动，然后返回指针处的数字。
注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。
你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。

示例：
输入
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext",
 "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
输出
[null, 3, 7, true, 9, true, 15, true, 20, false]

## 解题思路

这道题要求实现一个二叉搜索树的迭代器，按照中序遍历的顺序返回节点值。关键点在于：

1. **中序遍历的性质**：对于二叉搜索树，中序遍历的结果是升序排列的。因此迭代器实际上就是按升序返回节点值。

2. **迭代实现中序遍历**：使用栈来模拟递归的中序遍历过程。传统的递归中序遍历会一次性遍历完整棵树，而迭代器需要"暂停"和"继续"的能力。

3. **核心思想**：
   - 维护一个栈，存储从根节点到当前最左节点的路径
   - `next()` 操作时，弹出栈顶元素，然后处理其右子树（将右子树的最左路径入栈）
   - `hasNext()` 只需检查栈是否为空或当前节点是否为空

4. **为什么这样做有效**：
   - 栈中始终保存着"待访问"的节点
   - 栈顶元素就是中序遍历的下一个节点
   - 每次访问一个节点后，将其右子树的最左路径入栈，保证了正确的中序遍历顺序

## 代码实现

```cpp
class BSTIterator {
public:
    BSTIterator(TreeNode* root) {
        cur = root;
    }

    int next() {
        while (cur != nullptr) {
            stk.push(cur);
            cur = cur->left;
        }
        cur = stk.top();
        stk.pop();
        int result = cur->val;
        cur = cur->right;
        return result;
    }

    bool hasNext() {
        return cur != nullptr || !stk.empty();
    }

private:
    TreeNode* cur;
    stack<TreeNode*> stk;
};
```

### 代码详解

**成员变量**：
- `cur`：当前遍历到的节点指针
- `stk`：辅助栈，用于存储待访问的节点

**构造函数 `BSTIterator(TreeNode* root)`**：
- 初始化当前节点指针为根节点
- 不预先遍历，实现惰性求值

**`next()` 方法**：
1. 内层 `while` 循环：将当前节点的所有左子节点入栈，模拟中序遍历的"左"步骤
2. `cur = stk.top(); stk.pop();`：弹出栈顶元素，这是中序遍历的"根"步骤
3. `result = cur->val`：保存当前节点值
4. `cur = cur->right`：转向右子树，为下一次调用做准备
5. 返回结果值

**`hasNext()` 方法**：
- 如果 `cur` 不为空，说明还有节点未处理
- 如果栈不为空，说明还有节点待访问
- 两者满足其一即可继续迭代

## 复杂度分析

**时间复杂度**：
- `next()`：均摊时间复杂度为 O(1)。虽然单次调用可能需要 O(h) 的时间（h 为树高），但每个节点最多入栈出栈各一次，因此 n 次 `next()` 调用的总时间为 O(n)，均摊每次 O(1)
- `hasNext()`：O(1)

**空间复杂度**：
- O(h)，其中 h 是树的高度。栈中最多存储从根到叶子的路径上的所有节点
- 最坏情况下（树退化为链表），空间复杂度为 O(n)
- 平均情况下（平衡二叉树），空间复杂度为 O(log n)

## 总结

本题是二叉树中序遍历的迭代实现的应用。关键在于：

1. **理解中序遍历的迭代实现**：使用栈模拟递归调用栈，实现"暂停-继续"的遍历模式
2. **惰性求值**：不在构造函数中预先遍历整棵树，而是在每次调用 `next()` 时按需计算
3. **均摊复杂度分析**：理解为什么 `next()` 的均摊时间复杂度是 O(1)

这种迭代器设计模式在实际开发中很常见，特别是处理大数据集或流式数据时，可以节省内存并实现按需计算。
