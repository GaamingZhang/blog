---
date: 2025-10-06
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 哈希表
---

# 349. 两个数组的交集

给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。

示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]

示例 2：
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的

## 解题思路

### 问题分析

要求找出两个数组的交集，且结果中的元素必须唯一。

### 方法：哈希集合

使用两个哈希集合：
1. 将 nums1 的所有元素存入集合
2. 遍历 nums2，检查每个元素是否在集合中
3. 使用另一个集合记录已访问的元素，避免重复添加

### 核心思想

1. **去重**：使用集合自动去重
2. **快速查找**：集合的查找时间复杂度为 O(1)
3. **避免重复添加**：记录已访问的元素

## 代码实现

```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> nums1Set(nums1.begin(), nums1.end());
        unordered_set<int> visited;
        vector<int> result;
        
        for (int num : nums2) {
            if (visited.count(num)) {
                continue;
            }
            
            visited.insert(num);
            
            if (nums1Set.count(num)) {
                result.push_back(num);
            }
        }
        
        return result;
    }
};
```

### 代码详解

**构建集合**：
```cpp
unordered_set<int> nums1Set(nums1.begin(), nums1.end());
```
- 将 nums1 的所有元素存入集合，自动去重

**遍历 nums2**：
```cpp
for (int num : nums2) {
    if (visited.count(num)) {
        continue;  // 已访问过，跳过
    }
    
    visited.insert(num);  // 标记为已访问
    
    if (nums1Set.count(num)) {
        result.push_back(num);  // 在 nums1 中存在，加入结果
    }
}
```

**示例演示**（nums1 = [4,9,5], nums2 = [9,4,9,8,4]）：
```
nums1Set = {4, 9, 5}

遍历 nums2：
num=9: visited={}, nums1Set包含9, result=[9], visited={9}
num=4: visited={9}, nums1Set包含4, result=[9,4], visited={9,4}
num=9: visited包含9, 跳过
num=8: visited={9,4}, nums1Set不包含8, 跳过
num=4: visited包含4, 跳过

结果：[9, 4]
```

## 复杂度分析

**时间复杂度**：O(m + n)，其中 m 和 n 分别是两个数组的长度。需要遍历两个数组各一次。

**空间复杂度**：O(m + n)，最坏情况下需要存储所有元素。

## 总结

本题是集合的基本应用：

1. **集合去重**：利用集合自动去重的特性
2. **快速查找**：集合查找时间复杂度为 O(1)
3. **避免重复添加**：使用 visited 集合记录已处理的元素

这种"集合求交集"的方法在处理数组交集、并集、差集等问题中非常常见，是解决此类问题的标准方法。
