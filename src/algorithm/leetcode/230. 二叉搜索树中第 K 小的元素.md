---
date: 2025-09-29
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 二叉搜索树
  - 中序遍历
---


# 230. 二叉搜索树中第 K 小的元素

给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素
 （从 1 开始计数）。

示例 1：
输入：root = [3,1,4,null,2], k = 1
输出：1

示例 2：
输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3

## 解题思路

### 二叉搜索树的性质

二叉搜索树的一个重要性质：**中序遍历的结果是升序排列的**。因此，要找第 k 小的元素，只需要进行中序遍历，找到第 k 个访问的节点即可。

### 方法一：递归中序遍历

使用递归进行中序遍历，维护一个计数器，当计数器等于 k 时，记录当前节点值。

### 方法二：迭代中序遍历

使用栈模拟中序遍历，可以更精确地控制遍历过程，找到第 k 个元素后立即停止。

## 代码实现

### 方法一：递归中序遍历

```cpp
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        count = 0;
        inorder(root, k);
        return result;
    }

private:
    int count;
    int result;
    
    void inorder(TreeNode* root, int k) {
        if (root == nullptr || count >= k) {
            return;
        }
        
        inorder(root->left, k);
        
        count++;
        if (count == k) {
            result = root->val;
            return;
        }
        
        inorder(root->right, k);
    }
};
```

### 方法二：迭代中序遍历

```cpp
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack<TreeNode*> stk;
        TreeNode* cur = root;
        int count = 0;
        
        while (cur != nullptr || !stk.empty()) {
            while (cur != nullptr) {
                stk.push(cur);
                cur = cur->left;
            }
            
            cur = stk.top();
            stk.pop();
            count++;
            
            if (count == k) {
                return cur->val;
            }
            
            cur = cur->right;
        }
        
        return -1;
    }
};
```

### 代码详解

**方法一：递归**

1. `count`：记录当前访问的是第几个节点
2. `result`：存储第 k 小的元素
3. 中序遍历顺序：左子树 → 根节点 → 右子树
4. 当 `count == k` 时，记录结果并返回

**方法二：迭代**

1. 使用栈模拟递归调用栈
2. 先将所有左子节点入栈
3. 弹出栈顶，计数加 1
4. 如果计数等于 k，返回当前值
5. 转向右子树继续处理

**示例演示**（root = [5,3,6,2,4,null,null,1], k = 3）：
```
        5
       / \
      3   6
     / \
    2   4
   /
  1

中序遍历顺序：1, 2, 3, 4, 5, 6
第 3 小的元素：3

迭代过程：
1. 入栈：5, 3, 2, 1
2. 弹出 1，count=1
3. 弹出 2，count=2
4. 弹出 3，count=3，返回 3
```

## 复杂度分析

**时间复杂度**：O(H + k)，其中 H 是树的高度。最坏情况下需要遍历 H 个节点到达最左节点，然后遍历 k 个节点。

**空间复杂度**：
- 递归：O(H)，递归栈深度
- 迭代：O(H)，栈中最多存储 H 个节点

## 总结

本题利用了二叉搜索树中序遍历有序的性质：

1. **核心思想**：中序遍历结果是升序，第 k 个访问的节点就是第 k 小的元素
2. **两种实现**：递归简洁，迭代可以提前终止
3. **优化思路**：如果需要频繁查找，可以预先记录每个节点的排名

这道题是二叉搜索树的基本应用，理解中序遍历的性质是解决此类问题的关键。如果树会被频繁修改，可以考虑使用平衡二叉搜索树或维护节点计数来优化查询效率。
