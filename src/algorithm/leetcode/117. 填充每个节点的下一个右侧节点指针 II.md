---
date: 2025-10-17
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 二叉树
---

# 117. 填充每个节点的下一个右侧节点指针 II

给定一个二叉树：

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。
初始状态下，所有 next 指针都被设置为 NULL 。

示例 1：
输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。
序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。

## 解题思路

这道题需要填充二叉树每个节点的 next 指针，使其指向同一层的下一个右侧节点。与第 116 题不同，本题的二叉树**不一定是完美二叉树**，可能存在缺失节点。

### 层序遍历法

使用广度优先搜索（BFS）进行层序遍历：

1. 使用队列存储当前层的节点
2. 遍历每一层时，将前一个节点的 next 指向当前节点
3. 每层最后一个节点的 next 设为 nullptr

### 算法流程

1. 根节点入队
2. 按层遍历：
   - 获取当前层节点数量
   - 遍历当前层所有节点
   - 将前驱节点的 next 指向当前节点
   - 将当前节点的左右子节点入队
3. 每层结束后，将最后一个节点的 next 设为 nullptr

## 代码实现

```cpp
class Solution {
public:
    Node* connect(Node* root) {
        // 空树直接返回
        if (root == nullptr) {
            return nullptr;
        }
        
        // 使用队列进行层序遍历
        queue<Node*> nodes;
        nodes.push(root);
        
        while (!nodes.empty()) {
            // 获取当前层的节点数量
            int size = nodes.size();
            Node* prev = nullptr;  // 记录前驱节点
            
            // 遍历当前层的所有节点
            while (--size >= 0) {
                Node* currentNode = nodes.front();
                nodes.pop();
                
                // 跳过空节点
                if (currentNode == nullptr) {
                    continue;
                }
                
                // 将前驱节点的 next 指向当前节点
                if (prev != nullptr) {
                    prev->next = currentNode;
                }
                
                // 更新前驱节点
                prev = currentNode;
                
                // 将子节点入队
                nodes.push(currentNode->left);
                nodes.push(currentNode->right);
            }
            
            // 每层最后一个节点的 next 设为 nullptr
            if (prev != nullptr) {
                prev->next = nullptr;
            }
        }
        
        return root;
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是树中节点数。每个节点只访问一次。
- **空间复杂度**：O(w)，其中 w 是树的最大宽度。队列中最多存储一层的节点。

## 总结

本题使用**层序遍历（BFS）**填充 next 指针。与第 116 题不同，本题适用于任意二叉树。

关键点：
1. 使用队列按层遍历
2. 记录前驱节点，将其 next 指向当前节点
3. 每层最后一个节点的 next 设为 nullptr

进阶解法可以使用 O(1) 空间复杂度，利用已建立的 next 指针进行遍历。
