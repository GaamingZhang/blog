---
date: 2025-09-12
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 广度优先搜索
---

# 127. 单词接龙

字典 wordList 中从单词 beginWord 到 endWord 的 转换序列 是一个按下述规格形成的序列 
 beginWord -> s1 -> s2 -> ... -> sk：
每一对相邻的单词只差一个字母。
对于 1 <= i <= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。
sk == endWord
给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的
 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。 

示例 1：
输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
输出：5
解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。

## 解题思路

这道题需要找到从 beginWord 到 endWord 的最短转换序列，每次转换只能改变一个字母。

### 广度优先搜索（BFS）

将问题建模为图的最短路径问题：
- 每个单词是一个节点
- 如果两个单词只差一个字母，则它们之间有边

使用 BFS 找最短路径：
1. 从 beginWord 开始，逐层扩展
2. 对于每个单词，尝试改变每个位置的字母
3. 如果改变后的单词在字典中且未被访问，加入队列
4. 找到 endWord 时返回路径长度

### 优化技巧

1. **预处理字典**：使用哈希表存储字典中的单词，O(1) 时间判断是否存在
2. **访问标记**：使用哈希表记录已访问的单词，避免重复访问
3. **逐层遍历**：每次处理一层的所有单词，保证找到的是最短路径

## 代码实现

```cpp
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        int n = wordList.size();
        
        // 使用哈希表存储字典中的单词及其访问状态
        unordered_map<string, bool> stat;
        for (int i = 0; i < wordList.size(); ++i) {
            stat[wordList[i]] = false;  // false 表示未访问
        }
        
        // 如果 endWord 不在字典中，无法完成转换
        if (!stat.contains(endWord)) {
            return 0;
        }
        
        // BFS 队列
        queue<string> mem;
        mem.push(beginWord);
        
        int k = beginWord.size();  // 单词长度
        string f, temp;
        int cnt = 1;  // 路径长度计数
        
        while (!mem.empty()) {
            int t = mem.size();  // 当前层的节点数
            
            // 处理当前层的所有节点
            for (int i = 0; i < t; i++) {
                f = mem.front();
                
                // 如果找到 endWord，返回路径长度
                if (f == endWord) {
                    return cnt;
                }
                
                mem.pop();
                
                // 尝试改变每个位置的字母
                for (int j = 0; j < k; j++) {
                    for (char p = 'a'; p <= 'z'; p++) {
                        temp = f;
                        temp[j] = p;  // 改变第 j 个位置的字母
                        
                        // 如果新单词在字典中且未被访问
                        if (stat.contains(temp) && !stat[temp]) {
                            mem.push(temp);
                            stat[temp] = true;  // 标记为已访问
                        }
                    }
                }
            }
            
            cnt++;  // 进入下一层
        }
        
        return 0;  // 无法到达 endWord
    }
};
```

## 复杂度分析

- **时间复杂度**：O(M² × N)，其中 M 是单词长度，N 是字典中单词数。每个单词需要尝试 M × 26 种变换。
- **空间复杂度**：O(N)，存储字典和访问状态。

## 总结

本题使用**广度优先搜索（BFS）**求解最短转换序列。关键在于：

1. **图建模**：将单词转换问题建模为图的遍历问题
2. **BFS 保证最短**：逐层遍历保证找到的是最短路径
3. **状态标记**：避免重复访问同一单词

进阶优化：可以使用双向 BFS，从 beginWord 和 endWord 同时开始搜索，可以显著减少搜索空间。
