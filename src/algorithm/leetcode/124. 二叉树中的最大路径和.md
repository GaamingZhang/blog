---
date: 2025-10-22
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 二叉树
---

# 124. 二叉树中的最大路径和

二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中
 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给你一个二叉树的根节点 root ，返回其 最大路径和 。

示例 1：
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6

示例 2：
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42

## 解题思路

这道题需要找到二叉树中的最大路径和。路径可以从任意节点开始，到任意节点结束，但必须是一条连续的路径。

### 递归思路

对于每个节点，考虑两种情况：

1. **经过该节点的最大路径**：左子树贡献 + 当前节点 + 右子树贡献
2. **以该节点为起点的最大路径**：当前节点 + max(左子树贡献, 右子树贡献)

关键点：
- 如果子树贡献为负数，则不选择该子树（贡献为 0）
- 路径可以只包含一个节点

### 算法流程

1. 递归遍历每个节点
2. 计算左右子树的最大贡献值（如果为负则取 0）
3. 更新全局最大路径和：left + right + root->val
4. 返回当前节点的最大贡献值：max(left, right) + root->val

## 代码实现

```cpp
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        // 递归计算最大路径和
        maxPathSumInternal(root);
        return result;
    }

private:
    int result = INT_MIN;  // 全局最大路径和
    
    // 返回以当前节点为起点的最大路径贡献值
    int maxPathSumInternal(TreeNode* root) {
        // 空节点贡献为 0
        if (root == nullptr) {
            return 0;
        }
        
        // 计算左右子树的最大贡献值（负数则取 0）
        int left = max(0, maxPathSumInternal(root->left));
        int right = max(0, maxPathSumInternal(root->right));
        
        // 更新全局最大路径和：经过当前节点的路径
        // 路径可以是 左子树 -> 当前节点 -> 右子树
        result = max(result, left + right + root->val);
        
        // 返回以当前节点为起点的最大路径贡献值
        // 只能选择一边，因为路径不能分叉
        return max(left, right) + root->val;
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是树中节点数。每个节点只访问一次。
- **空间复杂度**：O(h)，其中 h 是树的高度。递归调用栈的深度取决于树的高度。

## 总结

本题使用**递归后序遍历**求解最大路径和。关键在于：

1. **区分两种路径**：
   - 经过当前节点的路径（可以连接左右子树）
   - 以当前节点为起点的路径（只能选择一边）

2. **负数处理**：如果子树贡献为负数，则不选择该子树

3. **全局更新**：在递归过程中更新全局最大值

这道题是二叉树路径问题的经典题目，理解"贡献值"的概念是解题关键。
