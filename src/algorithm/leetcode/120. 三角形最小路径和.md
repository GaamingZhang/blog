---
date: 2025-10-18
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 动态规划
---

# 120. 三角形最小路径和

给定一个三角形 triangle ，找出自顶向下的最小路径和。
每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 
 相同或者等于 上一层结点下标 + 1 的两个结点。
也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。
 
示例 1：
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

示例 2：
输入：triangle = [[-10]]
输出：-10

## 解题思路

这道题需要找到从三角形顶部到底部的最小路径和，每一步只能移动到相邻节点。

### 动态规划

使用动态规划自顶向下计算：

1. **状态定义**：`dp[i][j]` 表示从顶部到位置 (i, j) 的最小路径和
2. **状态转移**：
   - 边界位置（j=0 或 j=i）：只能从一个方向到达
   - 中间位置：可以从左上或右上到达，取较小值
3. **初始状态**：`dp[0][0] = triangle[0][0]`
4. **最终结果**：最后一行中的最小值

### 状态转移方程

```
dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]
```

特殊情况：
- 左边界：`dp[i][0] = dp[i-1][0] + triangle[i][0]`
- 右边界：`dp[i][i] = dp[i-1][i-1] + triangle[i][i]`

## 代码实现

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        // dp[i][j] 表示从顶部到位置 (i, j) 的最小路径和
        vector<vector<int>> dp(n, vector<int>(n, 0));
        
        // 初始状态：顶部元素
        dp[0][0] = triangle[0][0];
        
        // 从第二行开始遍历
        for (int i = 1; i < n; ++i) {
            // 左边界：只能从上方到达
            dp[i][0] = dp[i - 1][0] + triangle[i][0];
            // 右边界：只能从左上方到达
            dp[i][i] = dp[i - 1][i - 1] + triangle[i][i];
        }
        
        // 初始化最小值为最后一行的边界值
        int minValue = min(dp[n - 1][0], dp[n - 1][n - 1]);
        
        // 计算中间位置的最小路径和
        for (int i = 1; i < n; ++i) {
            for (int j = 1; j < i; ++j) {
                // 状态转移：取左上和上方的较小值
                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle[i][j];
                // 如果是最后一行，更新最小值
                if (i == n - 1) {
                    minValue = min(minValue, dp[i][j]);
                }
            }
        }
        
        return minValue;
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n²)，其中 n 是三角形的行数。需要遍历三角形中的所有元素。
- **空间复杂度**：O(n²)，使用二维数组存储状态。可以优化为 O(n) 使用一维数组。

## 总结

本题使用**动态规划**自顶向下计算最小路径和。关键在于：
1. 正确定义状态：`dp[i][j]` 表示到位置 (i, j) 的最小路径和
2. 处理边界情况：左边界和右边界只能从一个方向到达
3. 状态转移：中间位置取两个可能来源的较小值

进阶优化：可以使用一维数组，从底部向上计算，空间复杂度降为 O(n)。
