---
date: 2025-11-17
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 数组
---

# 189. 轮转数组

给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。

示例 1:
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]

示例 2:
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]

## 解题思路

这道题需要将数组向右轮转 k 个位置。

### 三次反转法

核心思路：**通过三次反转实现轮转**。

1. **第一次反转**：反转整个数组
2. **第二次反转**：反转前 k 个元素
3. **第三次反转**：反转后 n-k 个元素

### 原理解释

假设数组为 `[1,2,3,4,5,6,7]`，k = 3：

1. 反转整个数组：`[7,6,5,4,3,2,1]`
2. 反转前 3 个元素：`[5,6,7,4,3,2,1]`
3. 反转后 4 个元素：`[5,6,7,1,2,3,4]`

结果正确！

### 关键点

- k 可能大于数组长度，需要取模：`k = k % n`
- 如果 k == 0，不需要操作

## 代码实现

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        // k 可能大于数组长度，取模
        int targetK = k % n;
        
        // 如果 k == 0，不需要操作
        if (targetK == 0) {
            return;
        }
        
        // 第一次反转：反转整个数组
        reverse(nums, 0, n - 1);
        // 第二次反转：反转前 k 个元素
        reverse(nums, 0, targetK - 1);
        // 第三次反转：反转后 n-k 个元素
        reverse(nums, targetK, n - 1);
    }

private:
    // 反转数组指定区间
    void reverse(vector<int>& nums, int start, int end) {
        while (start < end) {
            // 交换首尾元素
            int tmp = nums[start];
            nums[start] = nums[end];
            nums[end] = tmp;
            ++start;
            --end;
        }
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，需要遍历数组两次（反转操作）。
- **空间复杂度**：O(1)，只使用了常数级别的额外空间。

## 总结

本题使用**三次反转法**实现数组轮转。关键在于：

1. **反转技巧**：通过三次反转实现轮转效果
2. **原地操作**：不需要额外数组，空间复杂度 O(1)
3. **边界处理**：k 取模处理，k == 0 的特殊情况

其他解法：
- **额外数组**：创建新数组，O(n) 空间
- **环状替换**：使用 GCD 优化，O(1) 空间
