---
date: 2025-09-30
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 数组
  - 模拟
---


# 289. 生命游戏

根据 百度百科 ， 生命游戏 ，简称为 生命 ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。

给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：
 1 即为 活细胞 （live），或 0 即为 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）
 的细胞都遵循以下四条生存定律：
如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是 同时 发生的。
给你 m x n 网格面板 board 的当前状态，返回下一个状态。
给定当前 board 的状态，更新 board 到下一个状态。
注意 你不需要返回任何东西。

示例 1：
输入：board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
输出：[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]

示例 2：
输入：board = [[1,1],[1,0]]
输出：[[1,1],[1,1]]

## 解题思路

### 问题分析

生命游戏是一个经典的细胞自动机问题。关键在于理解规则和"同时更新"的要求。

### 规则总结

| 当前状态 | 周围活细胞数 | 下一状态 |
|---------|------------|---------|
| 活(1)   | < 2        | 死(0)   |
| 活(1)   | 2 或 3      | 活(1)   |
| 活(1)   | > 3        | 死(0)   |
| 死(0)   | = 3        | 活(1)   |
| 死(0)   | ≠ 3        | 死(0)   |

### 方法：使用额外数组

1. 创建一个计数数组，记录每个细胞周围活细胞的数量
2. 根据计数数组和规则更新原数组

### 进阶：原地更新

使用额外的状态标记：
- 0：死细胞 → 死细胞
- 1：活细胞 → 活细胞
- 2：活细胞 → 死细胞（标记为 2，表示原来是活的）
- 3：死细胞 → 活细胞（标记为 3，表示原来是死的）

最后将 2 改为 0，3 改为 1。

## 代码实现

### 方法一：使用额外数组

```cpp
class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {
        int rows = board.size();
        int cols = board[0].size();
        
        vector<vector<int>> neighbors(rows, vector<int>(cols, 0));
        vector<vector<int>> directions = {
            {-1, -1}, {-1, 0}, {-1, 1},
            {0, -1},           {0, 1},
            {1, -1},  {1, 0},  {1, 1}
        };
        
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                if (board[i][j] == 1) {
                    for (auto& dir : directions) {
                        int ni = i + dir[0];
                        int nj = j + dir[1];
                        if (ni >= 0 && ni < rows && nj >= 0 && nj < cols) {
                            neighbors[ni][nj]++;
                        }
                    }
                }
            }
        }
        
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                if (neighbors[i][j] == 3) {
                    board[i][j] = 1;
                } else if (neighbors[i][j] < 2 || neighbors[i][j] > 3) {
                    board[i][j] = 0;
                }
            }
        }
    }
};
```

### 方法二：原地更新

```cpp
class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {
        int rows = board.size();
        int cols = board[0].size();
        vector<vector<int>> directions = {
            {-1, -1}, {-1, 0}, {-1, 1},
            {0, -1},           {0, 1},
            {1, -1},  {1, 0},  {1, 1}
        };
        
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                int liveNeighbors = 0;
                for (auto& dir : directions) {
                    int ni = i + dir[0];
                    int nj = j + dir[1];
                    if (ni >= 0 && ni < rows && nj >= 0 && nj < cols) {
                        if (board[ni][nj] == 1 || board[ni][nj] == 2) {
                            liveNeighbors++;
                        }
                    }
                }
                
                if (board[i][j] == 1) {
                    if (liveNeighbors < 2 || liveNeighbors > 3) {
                        board[i][j] = 2;
                    }
                } else {
                    if (liveNeighbors == 3) {
                        board[i][j] = 3;
                    }
                }
            }
        }
        
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                if (board[i][j] == 2) board[i][j] = 0;
                if (board[i][j] == 3) board[i][j] = 1;
            }
        }
    }
};
```

### 代码详解

**方法一**：
1. 遍历所有活细胞，更新周围细胞的计数
2. 根据计数更新每个细胞的状态

**方法二**：
1. 遍历每个细胞，计算周围活细胞数量
2. 使用额外状态标记变化
3. 最后统一更新状态

**示例演示**（board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]）：
```
初始状态：
0 1 0
0 0 1
1 1 1
0 0 0

计数数组（每个细胞周围的活细胞数）：
1 1 2
3 5 3
2 3 2
2 2 2

更新后：
0 0 0
1 0 1
0 1 1
0 1 0
```

## 复杂度分析

**时间复杂度**：O(m × n)，遍历所有细胞

**空间复杂度**：
- 方法一：O(m × n)，需要额外的计数数组
- 方法二：O(1)，原地更新

## 总结

本题是经典的细胞自动机问题：

1. **规则理解**：正确理解四条生存定律
2. **同时更新**：所有细胞同时更新，不能边遍历边修改
3. **空间优化**：使用额外状态标记实现原地更新

生命游戏展示了简单规则如何产生复杂的行为模式，是复杂系统研究的经典案例。这种"状态机"的思想在很多场景都有应用，如游戏开发、模拟仿真等。
