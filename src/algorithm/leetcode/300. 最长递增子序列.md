---
date: 2025-10-03
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 动态规划
  - 二分查找
---

# 300. 最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。
例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

示例 2：
输入：nums = [0,1,0,3,2,3]
输出：4

示例 3：
输入：nums = [7,7,7,7,7,7,7]
输出：1

## 解题思路

### 方法一：动态规划

**状态定义**：`dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。

**状态转移方程**：
- 对于每个 `i`，遍历所有 `j < i`
- 如果 `nums[j] < nums[i]`，则 `dp[i] = max(dp[i], dp[j] + 1)`
- 初始状态：`dp[i] = 1`（每个元素本身构成长度为 1 的子序列）

**时间复杂度**：O(n²)

### 方法二：贪心 + 二分查找

维护一个数组 `tails`，`tails[i]` 表示长度为 `i+1` 的递增子序列的最小末尾元素。

**核心思想**：
- 遍历数组，对于每个元素，在 `tails` 中找到第一个大于等于它的位置
- 如果找到，替换该位置的元素（使末尾元素更小，有利于后续扩展）
- 如果没找到，将当前元素追加到 `tails` 末尾

**时间复杂度**：O(n log n)

## 代码实现

### 方法一：动态规划

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1);
        int maxLen = 1;
        
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            maxLen = max(maxLen, dp[i]);
        }
        
        return maxLen;
    }
};
```

### 方法二：贪心 + 二分查找

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> tails;
        
        for (int num : nums) {
            auto it = lower_bound(tails.begin(), tails.end(), num);
            if (it == tails.end()) {
                tails.push_back(num);
            } else {
                *it = num;
            }
        }
        
        return tails.size();
    }
};
```

### 代码详解

**方法一：动态规划**

1. `dp[i]` 初始化为 1，表示每个元素本身是一个长度为 1 的子序列
2. 对于每个位置 `i`，检查所有之前的位置 `j`
3. 如果 `nums[j] < nums[i]`，说明可以将 `nums[i]` 接在以 `nums[j]` 结尾的子序列后面
4. 更新 `dp[i]` 为 `max(dp[i], dp[j] + 1)`

**方法二：贪心 + 二分查找**

1. `tails` 数组存储不同长度递增子序列的最小末尾元素
2. `lower_bound` 找到第一个大于等于 `num` 的位置
3. 如果没找到，说明 `num` 比所有元素都大，可以扩展最长子序列
4. 如果找到了，替换该位置的元素，使末尾更小

**示例演示**（nums = [10,9,2,5,3,7,101,18]）：
```
方法二：
num=10: tails=[10]
num=9:  tails=[9]      (替换10)
num=2:  tails=[2]      (替换9)
num=5:  tails=[2,5]    (追加)
num=3:  tails=[2,3]    (替换5)
num=7:  tails=[2,3,7]  (追加)
num=101: tails=[2,3,7,101] (追加)
num=18: tails=[2,3,7,18]   (替换101)

结果：tails.size() = 4
```

## 复杂度分析

**方法一：动态规划**
- 时间复杂度：O(n²)，双重循环
- 空间复杂度：O(n)，dp 数组

**方法二：贪心 + 二分查找**
- 时间复杂度：O(n log n)，遍历 n 次，每次二分查找 log n
- 空间复杂度：O(n)，tails 数组

## 总结

本题是经典的动态规划问题，有两种解法：

1. **动态规划**：直观易懂，适合理解问题本质
2. **贪心 + 二分查找**：效率更高，但理解难度较大

贪心方法的关键在于维护"最小末尾元素"，这样可以让后续的元素更容易扩展子序列。这种思想在解决 LIS 问题时非常高效，是面试中常考的优化方法。
