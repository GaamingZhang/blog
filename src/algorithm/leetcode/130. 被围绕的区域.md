---
date: 2025-11-09
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 深度优先搜索
---

# 130. 被围绕的区域

给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' 组成，捕获 所有 被围绕的区域：
连接：一个单元格与水平或垂直方向上相邻的单元格连接。
区域：连接所有 'O' 的单元格来形成一个区域。
围绕：如果您可以用 'X' 单元格 连接这个区域，并且区域中没有任何单元格位于 board 边缘，
 则该区域被 'X' 单元格围绕。
通过 原地 将输入矩阵中的所有 'O' 替换为 'X' 来 捕获被围绕的区域。你不需要返回任何值。

示例 1：
输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。

示例 2：
输入：board = [["X"]]
输出：[["X"]]

## 解题思路

这道题需要将被 'X' 围绕的 'O' 区域替换为 'X'，但边界上的 'O' 及其相连的区域不能被替换。

### 反向思考

直接找出被围绕的区域比较困难，可以反向思考：

1. **边界 'O' 及其相连区域不会被替换**
2. **其他 'O' 都会被替换**

### 算法步骤

1. **标记边界区域**：从边界的 'O' 开始 DFS，将所有相连的 'O' 标记为特殊字符（如 '#'）
2. **替换剩余 'O'**：遍历整个矩阵，将未标记的 'O' 替换为 'X'
3. **恢复标记区域**：将 '#' 恢复为 'O'

### 关键点

- 只需要处理边界上的 'O'
- DFS/BFS 可以找到所有与边界 'O' 相连的区域
- 使用特殊字符标记，避免额外空间

## 代码实现

```cpp
class Solution {
public:
    void solve(vector<vector<char>>& board) {
        int n = board.size();
        int m = board[0].size();
        
        // 访问标记数组
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        
        // 从左右边界的 'O' 开始 DFS
        for (int i = 0; i < n; ++i) {
            if (!visited[i][0] && board[i][0] == 'O') {
                dfs(board, visited, i, 0, n, m);
            }
            if (!visited[i][m - 1] && board[i][m - 1] == 'O') {
                dfs(board, visited, i, m - 1, n, m);
            }
        }
        
        // 从上下边界的 'O' 开始 DFS
        for (int i = 0; i < m; ++i) {
            if (!visited[0][i] && board[0][i] == 'O') {
                dfs(board, visited, 0, i, n, m);
            }
            if (!visited[n - 1][i] && board[n - 1][i] == 'O') {
                dfs(board, visited, n - 1, i, n, m);
            }
        }

        // 遍历整个矩阵，替换和恢复
        for (int x = 0; x < n; ++x) {
            for (int y = 0; y < m; ++y) {
                if (board[x][y] == '#') {
                    // 标记的边界区域恢复为 'O'
                    board[x][y] = 'O';
                } else if (board[x][y] == 'O') {
                    // 未标记的 'O' 被替换为 'X'
                    board[x][y] = 'X';
                }
            }
        }
    }

private:
    // 四个方向：右、左、上、下
    vector<vector<int>> directions = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};

    // DFS 标记与边界 'O' 相连的区域
    void dfs(vector<vector<char>>& board, vector<vector<bool>>& visited,
        int x, int y, int n, int m) {
        visited[x][y] = true;
        board[x][y] = '#';  // 标记为特殊字符
        
        // 遍历四个方向
        for (int i = 0; i < 4; ++i) {
            int nextX = x + directions[i][0];
            int nextY = y + directions[i][1];
            
            // 边界检查和条件判断
            if (nextX < 0 || nextY < 0 || nextX >= n || nextY >= m
                || visited[nextX][nextY] || board[nextX][nextY] != 'O') {
                continue;
            }
            
            dfs(board, visited, nextX, nextY, n, m);
        }
    }
};
```

## 复杂度分析

- **时间复杂度**：O(m × n)，其中 m 和 n 是矩阵的行数和列数。每个单元格最多被访问两次。
- **空间复杂度**：O(m × n)，访问标记数组的空间。如果不使用标记数组，可以优化为 O(1)。

## 总结

本题使用**反向思考 + DFS**解决被围绕区域问题。关键在于：

1. **反向思维**：不直接找被围绕的区域，而是找不被围绕的区域
2. **边界处理**：从边界 'O' 开始 DFS，标记所有相连区域
3. **原地修改**：使用特殊字符标记，避免额外空间

这种方法思路清晰，实现简单，是解决此类问题的经典方法。
