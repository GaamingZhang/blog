---
date: 2025-09-16
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 链表
---

# 141. 环形链表

给你一个链表的头节点 head ，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，
 评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数
 进行传递 。仅仅是为了标识链表的实际情况。
如果链表中存在环 ，则返回 true 。 否则，返回 false 。

示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。

示例 3：
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。

## 解题思路

这道题需要判断链表是否存在环。

### 快慢指针法

使用两个指针，一个快指针每次走两步，一个慢指针每次走一步：

1. 如果链表无环，快指针会先到达链表末尾（nullptr）
2. 如果链表有环，快慢指针最终会在环中相遇

### 为什么快慢指针一定会相遇？

假设链表有环：
- 快指针比慢指针快一步
- 当慢指针进入环后，快指针已经在环中
- 每次移动，快指针与慢指针的距离减少一步
- 最终快指针会追上慢指针

### 算法流程

1. 初始化快慢指针都指向头节点
2. 快指针每次走两步，慢指针每次走一步
3. 如果快慢指针相遇，说明有环
4. 如果快指针到达末尾，说明无环

## 代码实现

```cpp
class Solution {
public:
    bool hasCycle(ListNode* head) {
        // 空链表或单节点无环
        if (head == nullptr) {
            return false;
        }
        
        // 快慢指针初始化都指向头节点
        ListNode* fast = head;
        ListNode* slow = head;
        
        // 快指针每次走两步，慢指针每次走一步
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;  // 快指针走两步
            slow = slow->next;        // 慢指针走一步
            
            // 如果相遇，说明有环
            if (fast == slow) {
                return true;
            }
        }
        
        // 快指针到达末尾，无环
        return false;
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是链表节点数。如果有环，最多遍历 n 次；如果无环，遍历 n/2 次。
- **空间复杂度**：O(1)，只使用了两个指针的额外空间。

## 总结

本题使用**快慢指针法**判断链表是否有环。关键在于：

1. **快慢指针**：快指针每次两步，慢指针每次一步
2. **相遇判断**：有环则快慢指针会相遇
3. **边界处理**：空链表和单节点链表的特殊情况

这种方法是链表问题的经典技巧，空间复杂度 O(1)，是判断链表环的最优解法。
