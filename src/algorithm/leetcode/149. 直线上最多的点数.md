---
date: 2025-09-03
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 哈希表
---

# 149. 直线上最多的点数

给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。
求最多有多少个点在同一条直线上。

示例 1：
输入：points = [[1,1],[2,2],[3,3]]
输出：3

示例 2：
输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
输出：4

## 解题思路

这道题需要找到经过最多点的直线。

### 直线表示方法

两点确定一条直线，可以用斜率来表示直线的方向：

1. **斜率公式**：k = (y2 - y1) / (x2 - x1)
2. **避免浮点数精度问题**：使用最简分数表示斜率

### 斜率标准化

为了避免浮点数精度问题，使用最简分数表示斜率：

1. 计算分子 dy = y2 - y1，分母 dx = x2 - x1
2. 对 dx 和 dy 进行约分，得到最简分数
3. 使用字符串 "dy:dx" 作为哈希表的键

### 特殊情况处理

- **垂直线**：dx = 0，斜率记为 "1:0"
- **水平线**：dy = 0，斜率记为 "0:1"

### 算法流程

1. 枚举每个点作为起点
2. 计算该点与其他所有点的斜率
3. 使用哈希表统计相同斜率的点数
4. 更新最大点数

### 优化

- 如果当前最大点数已经超过剩余点数，可以提前结束
- 如果最大点数已经超过总点数的一半，可以提前结束

## 代码实现

```cpp
class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {
        int n = points.size();
        // 2个点以下一定共线
        if (n <= 2) {
            return n;
        }
        
        int result = 0;
        
        // 枚举每个点作为起点
        for (int i = 0; i < n; ++i) {
            // 优化：如果当前最大值已经超过剩余点数，提前结束
            if (result >= n - i || result > n / 2) {
                break;
            }
            
            // 哈希表：斜率 -> 点数
            unordered_map<string, int> slopeCount;
            
            // 计算点 i 与其他点的斜率
            for (int j = i + 1; j < n; ++j) {
                int dx = points[i][0] - points[j][0];
                int dy = points[i][1] - points[j][1];
                
                // 处理特殊情况
                if (dx == 0) {
                    // 垂直线
                    dy = 1;
                } else if (dy == 0) {
                    // 水平线
                    dx = 1;
                } else {
                    // 约分到最简分数
                    // 保证分母为正
                    if (dy < 0) {
                        dy = -dy;
                        dx = -dx;
                    }
                    int g = gcd(abs(dx), abs(dy));
                    dx /= g;
                    dy /= g;
                }
                
                // 使用字符串作为键
                string key = to_string(dy) + ":" + to_string(dx);
                ++slopeCount[key];
                
                // 更新最大值（+1 是因为要包含起点本身）
                result = max(result, slopeCount[key] + 1);
            }
        }
        
        return result;
    }

private:
    // 辗转相除法求最大公约数
    int gcd(int a, int b) {
        return b ? gcd(b, a % b) : a;
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n²)，其中 n 是点的数量。需要枚举所有点对。
- **空间复杂度**：O(n)，哈希表最多存储 n 个斜率。

## 总结

本题使用**哈希表 + 斜率统计**解决多点共线问题。关键在于：

1. **斜率表示**：使用最简分数避免浮点数精度问题
2. **特殊情况**：正确处理垂直线和水平线
3. **优化剪枝**：提前结束不必要的计算

这道题的难点在于如何准确表示斜率，使用最大公约数约分是关键技巧。
