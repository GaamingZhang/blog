---
date: 2025-07-11
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 栈
---

# 150. 逆波兰表达式求值

给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。
请你计算该表达式。返回一个表示表达式值的整数。
注意：
有效的算符为 '+'、'-'、'*' 和 '/' 。
每个操作数（运算对象）都可以是一个整数或者另一个表达式。
两个整数之间的除法总是 向零截断 。
表达式中不含除零运算。
输入是一个根据逆波兰表示法表示的算术表达式。
答案及所有中间计算结果可以用 32 位 整数表示。

示例 1：
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

示例 2：
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6

示例 3：
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22

## 解题思路

这道题需要计算逆波兰表达式（后缀表达式）的值。

### 逆波兰表达式

逆波兰表达式是一种后缀表达式，运算符位于操作数之后：

- **中缀表达式**：`(2 + 1) * 3`
- **后缀表达式**：`2 1 + 3 *`

优点：不需要括号，运算顺序由运算符的位置决定。

### 栈求解法

使用栈来计算逆波兰表达式：

1. 遍历每个 token
2. 如果是数字，压入栈中
3. 如果是运算符，弹出栈顶两个元素进行运算，结果压入栈中
4. 最终栈中只剩一个元素，即为结果

### 运算顺序

注意运算顺序：
- 栈顶元素是第二个操作数（右操作数）
- 栈顶下一个元素是第一个操作数（左操作数）
- 运算：左操作数 运算符 右操作数

### 示例分析

`["2","1","+","3","*"]`：
1. "2" 入栈：[2]
2. "1" 入栈：[2, 1]
3. "+"：弹出 1 和 2，计算 2 + 1 = 3，入栈：[3]
4. "3" 入栈：[3, 3]
5. "*"：弹出 3 和 3，计算 3 * 3 = 9，入栈：[9]
6. 结果：9

## 代码实现

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> stk;
        
        for (const string& token : tokens) {
            // 如果是运算符
            if (token == "+" || token == "-" || token == "*" || token == "/") {
                // 弹出两个操作数
                int right = stk.top();  // 右操作数
                stk.pop();
                int left = stk.top();   // 左操作数
                stk.pop();
                
                // 根据运算符进行计算
                int result;
                if (token == "+") {
                    result = left + right;
                } else if (token == "-") {
                    result = left - right;
                } else if (token == "*") {
                    result = left * right;
                } else {  // token == "/"
                    result = left / right;  // 向零截断
                }
                
                // 结果入栈
                stk.push(result);
            } else {
                // 如果是数字，转换为整数并入栈
                stk.push(stoi(token));
            }
        }
        
        // 栈中只剩一个元素，即为结果
        return stk.top();
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是 tokens 的长度。每个 token 只处理一次。
- **空间复杂度**：O(n)，栈最多存储 n/2 个元素。

## 总结

本题使用**栈**计算逆波兰表达式。关键在于：

1. **栈的应用**：数字入栈，运算符出栈计算
2. **运算顺序**：注意左右操作数的顺序
3. **整数除法**：C++ 中整数除法自动向零截断

逆波兰表达式是栈的经典应用，理解后缀表达式的计算过程是解题关键。
