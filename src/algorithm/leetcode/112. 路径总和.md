---
date: 2025-10-15
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 二叉树
---

# 112. 路径总和

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点
 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。
叶子节点 是指没有子节点的节点。

示例 1：
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。

## 解题思路

这道题需要判断二叉树中是否存在从根节点到叶子节点的路径，使得路径上所有节点值之和等于目标值。

### 递归思路

使用深度优先搜索（DFS）递归遍历：

1. **基本情况**：如果节点为空，返回 false
2. **叶子节点判断**：如果当前节点是叶子节点（左右子节点都为空），判断节点值是否等于剩余目标值
3. **递归检查**：对左右子树递归检查，目标值减去当前节点值

### 关键点

- **叶子节点定义**：左右子节点都为空的节点
- **路径定义**：必须从根节点到叶子节点，不能中途结束
- **递归减值**：每经过一个节点，目标值减去该节点的值

## 代码实现

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        // 空节点，不存在路径
        if (root == nullptr) {
            return false;
        }
        
        // 叶子节点：判断剩余目标值是否等于当前节点值
        if (root->left == nullptr && root->right == nullptr) {
            return root->val == targetSum;
        }
        
        // 递归检查左右子树，目标值减去当前节点值
        return hasPathSum(root->left, targetSum - root->val)
            || hasPathSum(root->right, targetSum - root->val);
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是树中节点数。最坏情况下需要遍历所有节点。
- **空间复杂度**：O(h)，其中 h 是树的高度。递归调用栈的深度取决于树的高度，最坏情况（链状树）为 O(n)，平均情况（平衡树）为 O(log n)。

## 总结

本题使用**递归 DFS**求解，核心思路是将问题分解为子问题：判断左子树或右子树中是否存在路径，使得路径和等于剩余目标值。

关键在于正确处理叶子节点的判断条件，以及递归时目标值的更新。
