---
date: 2025-11-12
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 二分查找
---

# 162. 寻找峰值

峰值元素是指其值严格大于左右相邻值的元素。
给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
你可以假设 nums[-1] = nums[n] = -∞ 。
你必须实现时间复杂度为 O(log n) 的算法来解决此问题。

示例 1：
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。

示例 2：
输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。

## 解题思路

这道题需要在 O(log n) 时间内找到数组中的峰值。

### 二分查找

关键观察：**如果 nums[mid] > nums[mid-1]，则右侧一定存在峰值**。

原因：
- 如果 nums[mid] > nums[mid-1]，说明 mid 处于上升坡
- 继续向右走，要么一直上升直到数组末尾（末尾是峰值）
- 要么遇到下降，下降的起点就是峰值

### 算法思路

1. 比较 nums[mid] 和 nums[mid-1]
2. 如果 nums[mid] > nums[mid-1]，峰值在右侧（包含 mid）
3. 如果 nums[mid] < nums[mid-1]，峰值在左侧
4. 当 left == right 时，找到峰值

### 为什么一定存在峰值？

- 数组边界外假设为 -∞
- 如果从任意位置向高处走，最终一定能到达峰值
- 因为数组是有限的，且边界外是 -∞

## 代码实现

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        
        while (left < right) {
            // 向上取整，避免 mid == 0 时访问 mid-1 越界
            int mid = left + (right - left + 1) / 2;
            
            // 如果 nums[mid] > nums[mid-1]，峰值在右侧（包含 mid）
            if (nums[mid] > nums[mid - 1]) {
                left = mid;
            } else {
                // 否则峰值在左侧
                right = mid - 1;
            }
        }
        
        return left;
    }
};
```

## 复杂度分析

- **时间复杂度**：O(log n)，二分查找的时间复杂度。
- **空间复杂度**：O(1)，只使用了常数级别的额外空间。

## 总结

本题使用**二分查找**寻找峰值。关键在于：

1. **攀爬策略**：向高处走一定能找到峰值
2. **比较方向**：比较 nums[mid] 和 nums[mid-1] 确定方向
3. **边界处理**：向上取整避免越界

这道题的难点在于理解为什么二分查找可以找到峰值，核心思想是"向高处走"。
