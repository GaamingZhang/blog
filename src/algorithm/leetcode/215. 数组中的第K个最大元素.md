---
date: 2026-01-04
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 快速选择
---

# 215. 数组中的第K个最大元素

给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。

示例 1:
输入: [3,2,1,5,6,4], k = 2
输出: 5

示例 2:
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4

## 解题思路

这道题需要找到数组中第 k 个最大的元素，要求 O(n) 时间复杂度。

### 快速选择算法

快速选择是快速排序的变种，用于找到第 k 大/小的元素：

1. 选择一个基准元素（pivot）
2. 将数组分为三部分：大于基准、等于基准、小于基准
3. 根据基准的位置判断第 k 大元素在哪一部分
4. 递归处理对应的部分

### 三路划分

使用三路划分优化：
- 左边：大于基准的元素
- 中间：等于基准的元素
- 右边：小于基准的元素

### 算法流程

1. 随机选择基准元素
2. 三路划分数组
3. 判断第 k 大元素的位置：
   - 如果 k 在中间区域，返回基准值
   - 如果 k 在左边区域，递归处理左边
   - 如果 k 在右边区域，递归处理右边

### 示例分析

`[3,2,1,5,6,4], k = 2`：
- 假设选择 4 为基准
- 划分后：[5,6,4,3,2,1]（左边 > 4，中间 = 4，右边 < 4）
- 左边有 2 个元素（5,6），k = 2 在左边
- 递归处理左边，找到第 2 大的元素是 5

## 代码实现

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        // 使用快速选择算法
        return quickSelect(nums, 0, nums.size() - 1, k);
    }

private:
    // 快速选择：找到第 k 大的元素
    int quickSelect(vector<int>& nums, int left, int right, int k) {
        if (left > right) {
            return -1;
        }
        
        // 随机选择基准元素，避免最坏情况
        int randIndex = left + rand() % (right - left + 1);
        int pivot = nums[randIndex];
        
        // 三路划分
        int leftIndex = left - 1;      // 左边界（大于基准）
        int rightIndex = right + 1;    // 右边界（小于基准）
        int index = left;              // 当前遍历位置
        
        while (index < rightIndex) {
            if (nums[index] > pivot) {
                // 大于基准，放到左边
                swap(nums[++leftIndex], nums[index++]);
            } else if (nums[index] < pivot) {
                // 小于基准，放到右边
                swap(nums[--rightIndex], nums[index]);
            } else {
                // 等于基准，跳过
                ++index;
            }
        }
        
        // 判断第 k 大元素的位置
        // leftIndex + 1 到 rightIndex - 1 是等于基准的区域
        // left 到 leftIndex 是大于基准的区域
        // rightIndex 到 right 是小于基准的区域
        
        if (leftIndex + 2 <= k && rightIndex >= k) {
            // 第 k 大元素在等于基准的区域
            return pivot;
        } else if (leftIndex + 2 > k) {
            // 第 k 大元素在大于基准的区域
            return quickSelect(nums, left, leftIndex, k);
        } else {
            // 第 k 大元素在小于基准的区域
            return quickSelect(nums, rightIndex, right, k);
        }
    }
};
```

## 复杂度分析

- **时间复杂度**：
  - 平均：O(n)
  - 最坏：O(n²)，但通过随机选择基准可以避免

- **空间复杂度**：O(log n)，递归栈深度

## 总结

本题使用**快速选择算法**找到第 k 大元素。关键在于：

1. **三路划分**：将数组分为大于、等于、小于基准三部分
2. **随机基准**：避免最坏情况
3. **递归优化**：只处理包含目标元素的部分

其他解法：
- **排序**：O(n log n)，简单但不符合要求
- **堆**：O(n log k)，使用小顶堆维护前 k 大元素
