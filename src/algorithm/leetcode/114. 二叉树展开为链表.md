---
date: 2025-10-16
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 二叉树
---

# 114. 二叉树展开为链表

给你二叉树的根结点 root ，请你将它展开为一个单链表：
展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。

示例 1：
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]

示例 2：
输入：root = []
输出：[]

示例 3：
输入：root = [0]
输出：[0]

## 解题思路

这道题需要将二叉树展开为单链表，链表的顺序与先序遍历相同。

### 先序遍历展开

使用先序遍历的顺序展开二叉树：

1. **先序遍历顺序**：根节点 → 左子树 → 右子树
2. **展开规则**：
   - 左子指针设为 null
   - 右子指针指向先序遍历的下一个节点
3. **使用前驱节点**：记录上一个访问的节点，将其右指针指向当前节点

### 算法流程

使用递归先序遍历：
1. 保存当前节点的右子树（因为后续会修改）
2. 将前驱节点的左子指针设为 null，右子指针指向当前节点
3. 更新前驱节点为当前节点
4. 递归处理左子树
5. 递归处理保存的右子树

**示例分析**：`[1,2,5,3,4,null,6]`
- 访问 1：prevNode = 1
- 访问 2：1->right = 2，1->left = null，prevNode = 2
- 访问 3：2->right = 3，2->left = null，prevNode = 3
- 访问 4：3->right = 4，3->left = null，prevNode = 4
- 访问 5：4->right = 5，4->left = null，prevNode = 5
- 访问 6：5->right = 6，5->left = null，prevNode = 6

## 代码实现

```cpp
class Solution {
public:
    void flatten(TreeNode* root) {
        // 空节点直接返回
        if (root == nullptr) {
            return;
        }
        
        // 如果存在前驱节点，将其左子指针置空，右子指针指向当前节点
        if (prevNode != nullptr) {
            prevNode->left = nullptr;
            prevNode->right = root;
        }
        
        // 更新前驱节点为当前节点
        prevNode = root;
        
        // 保存右子树（因为先序遍历会先处理左子树）
        TreeNode* tmpRight = root->right;
        
        // 先序遍历：先处理左子树
        flatten(root->left);
        
        // 再处理右子树
        flatten(tmpRight);
    }

private:
    // 记录先序遍历的上一个节点
    TreeNode* prevNode = nullptr;
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是树中节点数。每个节点只访问一次。
- **空间复杂度**：O(h)，其中 h 是树的高度。递归调用栈的深度取决于树的高度，最坏情况（链状树）为 O(n)，平均情况（平衡树）为 O(log n)。

## 总结

本题使用**先序遍历**展开二叉树，核心思路是：
1. 按先序顺序访问节点
2. 使用前驱节点记录上一个访问的节点
3. 将前驱节点的右指针指向当前节点，左指针置空

关键点在于需要先保存右子树，因为先序遍历会先处理左子树，此时右指针会被修改。
