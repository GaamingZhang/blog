---
date: 2025-09-13
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 动态规划
---

# 198. 打家劫舍

一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

示例 1：
输入：nums = [1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

示例 2：
输入：nums = [2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

## 解题思路

这道题是经典的动态规划问题，需要找到不相邻元素的最大和。

### 动态规划

定义状态：
- `dp[i]` 表示前 i 个房屋能偷窃到的最高金额

状态转移：
- 对于第 i 个房屋，有两种选择：
  1. 偷第 i 个房屋：金额 = dp[i-2] + nums[i]
  2. 不偷第 i 个房屋：金额 = dp[i-1]
- 取两者的最大值：`dp[i] = max(dp[i-1], dp[i-2] + nums[i])`

初始状态：
- `dp[0] = nums[0]`（只有一间房屋）
- `dp[1] = max(nums[0], nums[1])`（两间房屋选金额大的）

### 示例分析

`[2,7,9,3,1]`：
- dp[0] = 2
- dp[1] = max(2, 7) = 7
- dp[2] = max(7, 2+9) = 11
- dp[3] = max(11, 7+3) = 11
- dp[4] = max(11, 11+1) = 12

结果：12

## 代码实现

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        
        // 只有一间房屋
        if (n == 1) {
            return nums[0];
        }
        
        // dp[i] 表示前 i 个房屋能偷窃到的最高金额
        vector<int> dp(n, 0);
        
        // 初始状态
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        
        // 状态转移
        for (int i = 2; i < n; ++i) {
            // 选择：偷第 i 个房屋 或 不偷
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        
        return dp[n - 1];
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组长度。只需遍历一次数组。
- **空间复杂度**：O(n)，dp 数组的空间。可以优化为 O(1) 使用两个变量。

## 总结

本题使用**动态规划**解决打家劫舍问题。关键在于：

1. **状态定义**：dp[i] 表示前 i 个房屋的最大金额
2. **状态转移**：偷或不偷当前房屋，取最大值
3. **初始状态**：处理边界情况

进阶优化：可以使用滚动变量优化空间复杂度到 O(1)。
