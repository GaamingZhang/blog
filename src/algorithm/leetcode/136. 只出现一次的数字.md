---
date: 2025-10-08
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 位运算
---

# 136. 只出现一次的数字

给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。
找出那个只出现了一次的元素。
你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

示例 1 ：
输入：nums = [2,2,1]
输出：1

示例 2 ：
输入：nums = [4,1,2,1,2]
输出：4

示例 3 ：
输入：nums = [1]
输出：1

## 解题思路

这道题要求找出数组中唯一一个只出现一次的元素，其他元素都出现两次。

### 位运算：异或

利用异或运算（XOR）的性质：

1. **交换律**：a ^ b = b ^ a
2. **结合律**：(a ^ b) ^ c = a ^ (b ^ c)
3. **自反性**：a ^ a = 0
4. **恒等性**：a ^ 0 = a

### 核心思想

将数组中所有元素进行异或运算：
- 出现两次的元素会相互抵消（a ^ a = 0）
- 最终结果就是只出现一次的元素

**示例分析**：`[4, 1, 2, 1, 2]`
```
4 ^ 1 ^ 2 ^ 1 ^ 2
= 4 ^ (1 ^ 1) ^ (2 ^ 2)
= 4 ^ 0 ^ 0
= 4
```

### 算法流程

1. 初始化结果为第一个元素
2. 遍历数组，依次异或每个元素
3. 最终结果即为只出现一次的元素

## 代码实现

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        // 初始化结果为第一个元素
        int result = nums[0];
        
        // 遍历数组，依次异或每个元素
        for (int i = 1; i < nums.size(); ++i) {
            result ^= nums[i];
        }
        
        return result;
    }
};
```

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组长度。只需遍历一次数组。
- **空间复杂度**：O(1)，只使用了常数级别的额外空间。

## 总结

本题使用**异或运算**巧妙地解决了找唯一元素的问题。关键在于：

1. **异或性质**：a ^ a = 0，a ^ 0 = a
2. **成对抵消**：出现两次的元素会相互抵消
3. **线性时间**：只需遍历一次数组
4. **常数空间**：不需要额外数据结构

这是位运算的经典应用，简洁高效。
