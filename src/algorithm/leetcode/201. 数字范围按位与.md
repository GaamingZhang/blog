---
date: 2025-08-10
author: Gaaming Zhang
isOriginal: true
article: true
category: leetcode
tag:
  - leetcode
  - 位运算
---

# 201. 数字范围按位与

给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。

示例 1：
输入：left = 5, right = 7
输出：4

示例 2：
输入：left = 0, right = 0
输出：0

示例 3：
输入：left = 1, right = 2147483647
输出：0

## 解题思路

这道题要求计算区间 [left, right] 内所有数字的按位与结果。如果直接遍历所有数字进行按位与运算，当区间很大时会超时。

### 关键观察

1. **按位与的性质**：只要有一个数的某一位是 0，那么最终结果的那一位就是 0
2. **连续数字的特点**：在区间 [left, right] 中，如果 left < right，那么必然存在某些位会从 0 变成 1 或从 1 变成 0
3. **公共前缀**：最终结果的二进制表示，就是 left 和 right 的公共前缀，后面补 0

### 为什么是公共前缀？

考虑区间 [5, 7]：
```
5 = 101
6 = 110
7 = 111
```
按位与结果为 `100 = 4`

观察发现：5 和 7 的二进制表示从最高位开始，只有最高位相同（都是 1），其余位不同。按位与的结果就是公共前缀后面补 0。

### 算法思路

1. 找到 left 和 right 的公共前缀
2. 通过不断右移，直到 left == right
3. 记录右移的次数，最后将结果左移回来

### 另一种理解

当 left < right 时，区间内至少有两个数。这两个数的最低位必然一个是 0 一个是 1（或者都变化），所以最低位的按位与结果必然是 0。

因此，我们可以不断右移，去掉最低位，直到 left == right，此时剩下的就是公共前缀。

## 代码实现

```cpp
class Solution {
public:
    int rangeBitwiseAnd(int left, int right) {
        int shift = 0;
        
        while (left < right) {
            left >>= 1;
            right >>= 1;
            ++shift;
        }
        
        return right << shift;
    }
};
```

### 代码详解

**变量说明**：
- `shift`：记录右移的次数，即公共后缀的长度

**循环过程**：
1. 当 `left < right` 时，说明还有不同的位
2. 将 left 和 right 都右移一位，去掉最低位
3. `shift` 加 1，记录移除的位数
4. 当 `left == right` 时，循环结束，此时 left/right 就是公共前缀

**返回结果**：
- `right << shift`：将公共前缀左移 shift 位，低位补 0

**示例演示**（left = 5, right = 7）：
```
初始：left = 5 (101), right = 7 (111), shift = 0

第 1 次循环：
  left = 5 >> 1 = 2 (10)
  right = 7 >> 1 = 3 (11)
  shift = 1
  left(2) < right(3)，继续

第 2 次循环：
  left = 2 >> 1 = 1 (1)
  right = 3 >> 1 = 1 (1)
  shift = 2
  left(1) == right(1)，退出循环

结果：right << shift = 1 << 2 = 4 (100)
```

## 复杂度分析

**时间复杂度**：O(log n)，其中 n 是 right 的值。循环次数等于 right 的二进制位数。

**空间复杂度**：O(1)，只使用了常数级别的额外空间。

## 总结

本题的核心思想是找到区间端点的公共前缀。关键点在于：

1. **理解按位与的性质**：只要有一位出现 0，结果就是 0
2. **公共前缀法**：区间内所有数的按位与结果，等于两端点公共前缀后面补 0
3. **位运算技巧**：通过右移找公共前缀，再左移恢复位置

这种"找公共前缀"的思路在位运算问题中很常见，类似的还有判断两个数是否属于同一子网等问题。
