---
date: 2026-01-30
author: Gaaming Zhang
isOriginal: false
article: true
category:
  - Kubernetes
tag:
  - Kubernetes
  - ClaudeCode
---

# Kubernetes的探针机制

## 为什么需要探针？

想象一下这个场景：你的应用容器正在运行，进程没有崩溃，但应用已经陷入了死锁，无法处理任何请求。从Kubernetes的角度看，容器是"运行中"的，一切正常；但从用户的角度看，服务已经完全不可用了。

这就是探针要解决的问题：**让Kubernetes能够深入了解应用的真实状态，而不仅仅是容器是否在运行**。

探针就像是医生对病人的定期检查。容器在运行只能说明"人还活着"，但探针能告诉我们"这个人是否健康"、"是否能正常工作"。

## 三种探针的区别

Kubernetes提供了三种探针，它们各有不同的职责，初学者很容易混淆，所以我们来仔细区分。

### 存活探针（Liveness Probe）

**核心问题**：容器还活着吗？需要重启吗？

存活探针检测的是应用是否已经"死"了。这里的"死"不是指进程崩溃（那Kubernetes自己就能检测到），而是指应用虽然进程还在，但已经无法正常工作的情况，比如：

- 应用陷入死锁，所有线程都在等待
- 发生了无限循环
- 内存泄漏导致GC无法正常工作
- 某个关键组件挂掉但进程没退出

**如果存活探针失败**：Kubernetes会杀死容器并重新创建。这是一个"重启治百病"的策略——既然应用已经无法恢复，不如重新来过。

**重要原则**：存活探针应该只检查应用本身，不要检查外部依赖（如数据库）。如果数据库暂时不可用，重启应用容器并不能解决问题，反而会让情况更糟。

### 就绪探针（Readiness Probe）

**核心问题**：应用准备好接收流量了吗？

就绪探针检测的是应用是否能够正常提供服务。一个应用可能活着，但暂时不适合接收流量，比如：

- 刚启动，还在加载配置或预热缓存
- 正在进行内部维护或数据同步
- 依赖的服务暂时不可用
- 当前负载过高，需要减少流量

**如果就绪探针失败**：Kubernetes会将这个Pod从Service的端点列表中移除，停止向它发送流量。注意，**不会重启容器**，只是暂时不给它分配请求。

这个区别非常重要。就绪探针失败是可恢复的状态——一旦应用恢复正常，探针成功，流量就会重新导向这个Pod。

### 启动探针（Startup Probe）

**核心问题**：应用是否已经启动完成？

启动探针是专门为慢启动应用设计的。有些应用启动需要很长时间——加载大量数据、建立连接池、预热缓存等。如果用存活探针来处理这种情况，要么设置很长的初始延迟（影响快速故障检测），要么容器会在启动过程中被误杀。

**启动探针的工作方式**：在启动探针成功之前，存活探针和就绪探针都被禁用。只有启动探针成功后，其他探针才会开始工作。

这就像是说："给应用10分钟时间启动，启动完成后再按正常标准检查健康状况"。

## 探针如何工作

探针本质上是kubelet定期对容器执行的检查。你可以选择不同的检查方式。

### HTTP检查

最常用的方式。kubelet向容器发送HTTP GET请求，如果返回200-399的状态码，就认为检查成功。

这种方式适合Web应用，你可以专门实现一个健康检查端点（如`/healthz`或`/ready`），在里面做各种检查。

### TCP检查

kubelet尝试与容器的指定端口建立TCP连接。如果能成功建立连接，就认为检查成功。

这种方式更轻量，适合不提供HTTP接口的服务（如数据库、消息队列）。但它只能检查端口是否开放，无法验证应用逻辑是否正常。

### 命令检查

kubelet在容器内执行指定的命令，如果命令退出码为0，就认为检查成功。

这种方式最灵活，可以执行任何自定义的检查逻辑。但每次检查都要创建新进程，开销相对较大。

### gRPC检查

对于gRPC服务，可以使用原生的gRPC健康检查协议。这需要应用实现标准的gRPC健康检查服务。

## 关键配置参数

理解这些参数对于正确配置探针至关重要。

**initialDelaySeconds**：容器启动后等待多久才开始探测。对于需要启动时间的应用，这个值要设得足够大，否则应用还没启动完成就会被探针判定为失败。但如果使用了启动探针，存活探针和就绪探针的这个值就可以设小一点。

**periodSeconds**：探测的间隔时间。太短会给应用带来额外负担，太长会延迟发现问题。通常10秒是个不错的起点。

**timeoutSeconds**：单次探测的超时时间。如果探测在这个时间内没有响应，就算失败。默认只有1秒，对于复杂的健康检查可能不够。

**failureThreshold**：连续失败多少次才认为真的失败。设为1太敏感，可能因为网络抖动误判；设为3或5更合理，给应用一些容错空间。

**successThreshold**：从失败恢复到成功需要连续成功多少次。对于就绪探针，这个值可以大于1，确保应用真的稳定了才开始接收流量。

## 配置示例

一个典型的配置可能是这样的：

```yaml
spec:
  containers:
  - name: app
    image: myapp:1.0

    # 启动探针：给应用最多5分钟启动时间
    startupProbe:
      httpGet:
        path: /healthz
        port: 8080
      periodSeconds: 10
      failureThreshold: 30

    # 存活探针：检测应用是否还活着
    livenessProbe:
      httpGet:
        path: /healthz
        port: 8080
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 3

    # 就绪探针：检测应用是否能服务
    readinessProbe:
      httpGet:
        path: /ready
        port: 8080
      periodSeconds: 5
      failureThreshold: 3
```

注意存活探针和就绪探针可以使用不同的端点。存活探针的`/healthz`可能只检查应用本身，而就绪探针的`/ready`可能还会检查数据库连接等。

## 常见问题

### 容器频繁重启，日志显示Liveness probe failed

这通常意味着存活探针配置有问题。首先检查：

1. **应用启动时间**是否超过了`initialDelaySeconds`？如果是，增加这个值或使用启动探针。
2. **超时时间**是否足够？某些应用在高负载时响应变慢，需要增加`timeoutSeconds`。
3. **健康检查端点**是否真的能反映应用健康状态？有时候端点实现有bug。
4. **是否检查了外部依赖**？如果检查了数据库而数据库暂时不可用，会导致不必要的重启。

### Pod一直处于NotReady状态

这说明就绪探针一直失败。可能的原因：

1. 应用确实没准备好，比如依赖的服务不可用
2. 就绪探针端点返回了错误的状态码
3. 健康检查逻辑有问题
4. 网络配置问题导致探针请求无法到达

手动测试健康检查端点是个好方法：先用`kubectl port-forward`把端口转发到本地，然后用curl测试。

### 存活探针和就绪探针应该检查什么？

**存活探针应该轻量、快速、只检查应用本身**：
- 应用进程是否响应
- 关键内部状态是否正常
- 不要检查数据库、缓存等外部依赖

**就绪探针可以更全面**：
- 应用是否初始化完成
- 关键依赖是否可用
- 是否有足够资源处理请求

一个常见的错误是让两个探针使用完全相同的检查逻辑。记住：存活探针失败会重启容器，就绪探针失败只是暂停流量。这两个后果很不同，检查逻辑也应该不同。

### 滚动更新时出现服务中断

这通常是因为旧Pod被终止时还在处理请求，或者新Pod还没完全就绪就开始接收流量。解决方案：

1. 确保就绪探针正确反映应用是否真的准备好了
2. 配置`minReadySeconds`，让Pod稳定一段时间后才被视为可用
3. 实现优雅关闭：收到终止信号后，先停止接受新请求，等待现有请求完成，然后才退出
4. 使用`preStop`钩子，在容器终止前给负载均衡器时间更新端点

### 健康检查端点应该多快响应？

健康检查端点会被频繁调用，应该尽可能轻量。几个建议：

- 避免在每次检查时都访问数据库或外部服务，可以使用缓存
- 不要执行复杂的业务逻辑
- 超时时间设置要考虑最坏情况，但端点本身应该快速响应
- 可以考虑使用专门的端口来隔离健康检查流量

## 探针与其他机制的配合

探针不是孤立工作的，它和Kubernetes的其他机制紧密配合。

**与Service配合**：Service只会将流量路由到就绪探针成功的Pod。这是实现负载均衡和故障转移的基础。

**与Deployment配合**：滚动更新时，新Pod必须就绪探针成功才会替换旧Pod。这确保了更新过程中始终有足够的健康实例。

**与HPA配合**：HPA在计算Pod数量时，只考虑就绪的Pod。如果很多Pod不就绪，可能触发额外的扩容。

**与PDB配合**：PodDisruptionBudget确保在主动驱逐（如节点维护）时，始终有足够的就绪Pod。

## 小结

探针是Kubernetes实现自愈能力的关键机制。正确理解和配置探针，可以让你的应用更加健壮：

- **存活探针**确保"死掉"的应用能被重启
- **就绪探针**确保只有准备好的应用才接收流量
- **启动探针**给慢启动应用足够的时间

记住最重要的原则：存活探针只检查应用本身，就绪探针可以检查依赖；配置参数要根据应用特性调整，不要盲目使用默认值。

## 参考资源

- [Kubernetes 探针配置](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)
- [探针类型详解](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#types-of-probe)
- [应用健康检查最佳实践](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-liveness-command)
