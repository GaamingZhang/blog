---
date: 2026-01-30
author: Gaaming Zhang
isOriginal: false
article: true
category:
  - Kubernetes
tag:
  - Kubernetes
  - ClaudeCode
---

# Kubernetes核心知识测试题

本测试包含100道选择题，涵盖Kubernetes的核心知识点。答案使用剧透功能隐藏，点击可查看。

## Pod基础与生命周期

**1. Pod是Kubernetes中最小的部署单元，一个Pod可以包含多少个容器？**
- A. 只能包含1个容器
- B. 最多包含2个容器
- C. 可以包含1个或多个容器
- D. 必须包含至少2个容器

答案：!!C!!

**2. Pod的生命周期中，哪个阶段表示Pod已经被调度到节点上但容器还未创建？**
- A. Running
- B. Pending
- C. Succeeded
- D. Failed

答案：!!B!!

**3. 在Pod中，init容器的作用是什么？**
- A. 与主容器并行运行
- B. 在主容器启动之前顺序执行
- C. 在主容器退出后执行清理工作
- D. 替代主容器运行

答案：!!B!!

**4. Pod的重启策略(restartPolicy)不包括以下哪个选项？**
- A. Always
- B. OnFailure
- C. Never
- D. OnDemand

答案：!!D!!

**5. 如果Pod的重启策略设置为Never，当容器失败时会发生什么？**
- A. Pod会立即重启
- B. Pod不会重启，保持Failed状态
- C. Pod会被删除
- D. Pod会自动迁移到其他节点

答案：!!B!!

## Deployment与应用部署

**6. Deployment的主要作用是什么？**
- A. 只用于创建Pod
- B. 管理Pod的声明式更新和回滚
- C. 只用于网络配置
- D. 只用于存储管理

答案：!!B!!

**7. Deployment的滚动更新策略中，maxSurge参数表示什么？**
- A. 最大不可用Pod数量
- B. 最大超出期望副本数的Pod数量
- C. 最小可用Pod数量
- D. 最大允许的失败次数

答案：!!B!!

**8. 如何查看Deployment的滚动更新历史？** ***!***
- A. kubectl get deployment
- B. kubectl describe deployment
- C. kubectl rollout history deployment
- D. kubectl logs deployment

答案：!!C!!

**9. Deployment的更新策略(strategy)包括哪两种类型？**
- A. RollingUpdate和Recreate
- B. Update和Replace
- C. Incremental和Complete
- D. Smooth和Hard

答案：!!A!!

**10. 执行Deployment回滚到上一个版本的命令是？**
- A. kubectl rollback deployment
- B. kubectl undo deployment
- C. kubectl rollout undo deployment
- D. kubectl revert deployment

答案：!!C!!

## Service与服务发现

**11. Service的类型不包括以下哪个？**
- A. ClusterIP
- B. NodePort
- C. LoadBalancer
- D. StaticIP

答案：!!D!!

**12. ClusterIP类型的Service的特点是什么？**
- A. 在每个节点上开放端口
- B. 只在集群内部可访问
- C. 自动创建外部负载均衡器
- D. 直接映射到Pod IP

答案：!!B!!

**13. NodePort类型的Service默认端口范围是？**
- A. 1-1024
- B. 8000-9000
- C. 30000-32767
- D. 40000-50000

答案：!!C!!

**14. Service如何选择后端Pod？** ***!***
- A. 通过Pod名称
- B. 通过标签选择器(Label Selector)
- C. 通过Pod IP
- D. 通过命名空间

答案：!!B!!

**15. Headless Service的ClusterIP值是？** ***!***
- A. 0.0.0.0
- B. None
- C. 127.0.0.1
- D. 随机分配

答案：!!B!!

## ConfigMap与Secret

**16. ConfigMap的主要用途是什么？**
- A. 存储敏感数据
- B. 存储非敏感配置数据
- C. 存储持久化数据
- D. 存储日志文件

答案：!!B!!

**17. Secret中的数据默认使用什么编码方式存储？**
- A. 明文
- B. Base64
- C. AES加密
- D. RSA加密

答案：!!B!!

**18. 如何将ConfigMap挂载到Pod中？**
- A. 只能通过环境变量
- B. 只能通过Volume
- C. 可以通过环境变量或Volume
- D. 不能挂载

答案：!!C!!

**19. Secret的类型不包括以下哪个？**
- A. Opaque
- B. kubernetes.io/service-account-token
- C. kubernetes.io/dockerconfigjson
- D. kubernetes.io/plaintext

答案：!!D!!

**20. 更新ConfigMap后，已经运行的Pod中的配置会立即更新吗？**
- A. 环境变量会立即更新
- B. Volume挂载的会自动更新，环境变量不会
- C. 两者都会立即更新
- D. 两者都不会更新

答案：!!B!!

## Volume与持久化存储

**21. EmptyDir类型的Volume的生命周期与什么相同？**
- A. 与容器相同
- B. 与Pod相同
- C. 与Node相同
- D. 永久存在

答案：!!B!!

**22. PersistentVolume(PV)和PersistentVolumeClaim(PVC)的关系是？**
- A. PV是存储的消费者，PVC是提供者
- B. PV是存储的提供者，PVC是消费者
- C. PV和PVC是同一个对象
- D. PV和PVC没有关系

答案：!!B!!

**23. PV的回收策略不包括以下哪个？** ***!***
- A. Retain
- B. Recycle
- C. Delete
- D. Archive

答案：!!D!!

**24. StorageClass的作用是什么？** ***!***
- A. 定义存储的大小
- B. 动态供应存储卷
- C. 管理存储的访问权限
- D. 只用于监控存储

答案：!!B!!

**25. PVC的访问模式不包括以下哪个？** ***!***
- A. ReadWriteOnce (RWO)
- B. ReadOnlyMany (ROX)
- C. ReadWriteMany (RWX)
- D. ReadWriteAll (RWA)

答案：!!D!!

## Namespace与资源隔离

**26. Kubernetes默认创建的命名空间不包括？** ***!***
- A. default
- B. kube-system
- C. kube-public
- D. kube-user

答案：!!D!!

**27. 如何获取指定命名空间下的所有Pod？**
- A. kubectl get pods -n &lt;namespace&gt;
- B. kubectl get pods --namespace &lt;namespace&gt;
- C. 以上两者都可以
- D. 以上两者都不可以

答案：!!C!!

**28. ResourceQuota的作用是什么？**
- A. 限制命名空间中资源的使用量
- B. 只用于统计资源使用
- C. 自动扩展资源
- D. 只监控Pod数量

答案：!!A!!

**29. 以下哪个资源是命名空间级别的资源？** ***!***
- A. Node
- B. PersistentVolume
- C. Deployment
- D. Namespace

答案：!!C!!

**30. LimitRange的作用是什么？**
- A. 限制整个集群的资源
- B. 限制命名空间中单个Pod或容器的资源
- C. 只限制CPU资源
- D. 只限制内存资源

答案：!!B!!

## RBAC权限控制

**31. RBAC代表什么？**
- A. Resource-Based Access Control
- B. Role-Based Access Control
- C. Rule-Based Access Control
- D. Route-Based Access Control

答案：!!B!!

**32. Role和ClusterRole的区别是什么？**
- A. 没有区别
- B. Role是命名空间级别，ClusterRole是集群级别
- C. Role用于用户，ClusterRole用于服务账户
- D. Role权限更高

答案：!!B!!

**33. RoleBinding和ClusterRoleBinding的作用是？**
- A. 创建角色
- B. 删除角色
- C. 将角色绑定到用户或服务账户
- D. 修改角色权限

答案：!!C!!

**34. ServiceAccount主要用于什么？**
- A. 为用户提供身份认证
- B. 为Pod提供身份认证
- C. 只用于网络认证
- D. 只用于存储认证

答案：!!B!!

**35. RBAC中的权限动词(verbs)不包括以下哪个？** ***!***
- A. get
- B. list
- C. create
- D. modify

答案：!!D!!

## Ingress与网络

**36. Ingress的主要作用是什么？**
- A. 管理集群内部访问
- B. 管理集群外部访问，提供HTTP/HTTPS路由
- C. 只用于DNS解析
- D. 只用于负载均衡

答案：!!B!!

**37. 使用Ingress之前需要部署什么？**
- A. Ingress Controller
- B. Ingress Service
- C. Ingress Pod
- D. 不需要部署其他组件

答案：!!A!!

**38. Ingress支持哪些路由规则？**
- A. 只支持基于主机名的路由
- B. 只支持基于路径的路由
- C. 支持基于主机名和路径的路由
- D. 不支持任何路由规则

答案：!!C!!

**39. NetworkPolicy的作用是什么？**
- A. 配置网络速度
- B. 控制Pod之间的网络流量
- C. 只用于DNS配置
- D. 只用于负载均衡

答案：!!B!!

**40. Kubernetes的DNS服务默认使用什么组件？**
- A. Bind
- B. CoreDNS
- C. DNSMasq
- D. Unbound

答案：!!B!!

## 调度与资源管理

**41. Pod的nodeSelector字段用于什么？**
- A. 选择Pod的容器
- B. 选择Pod调度到哪些节点
- C. 选择Pod的网络
- D. 选择Pod的存储

答案：!!B!!

**42. Node Affinity相比nodeSelector的优势是？**
- A. 更简单
- B. 支持更复杂的调度规则，如软亲和性和硬亲和性
- C. 性能更好
- D. 没有优势

答案：!!B!!

**43. Taint和Toleration的作用是什么？**
- A. 加速Pod调度
- B. 允许节点排斥某些Pod
- C. 只用于资源限制
- D. 只用于网络隔离

答案：!!B!!

**44. Pod的资源请求(requests)和限制(limits)的区别是？**
- A. 没有区别
- B. requests是最小保证，limits是最大限制
- C. requests是最大限制，limits是最小保证
- D. 两者必须相同

答案：!!B!!

**45. 如果Pod的内存使用超过limits会发生什么？**
- A. 什么都不会发生
- B. Pod会被OOMKilled
- C. Pod会自动扩容
- D. 只会记录日志

答案：!!B!!

## StatefulSet与有状态应用

**46. StatefulSet与Deployment的主要区别是？**
- A. StatefulSet提供稳定的网络标识和持久化存储
- B. StatefulSet只能部署一个Pod
- C. StatefulSet不支持滚动更新
- D. 没有区别

答案：!!A!!

**47. StatefulSet中Pod的命名规则是？**
- A. 随机生成
- B. &lt;statefulset-name&gt;-&lt;ordinal&gt;，ordinal从0开始
- C. 用户自定义
- D. 使用Pod的IP地址

答案：!!B!!

**48. StatefulSet的更新策略不包括以下哪个？** ***!***
- A. RollingUpdate
- B. OnDelete
- C. Recreate
- D. Parallel

答案：!!D!!

**49. StatefulSet删除Pod的顺序是？**
- A. 随机删除
- B. 从序号大的开始删除（逆序）
- C. 从序号小的开始删除（正序）
- D. 同时删除所有Pod

答案：!!B!!

**50. StatefulSet需要配合什么来提供持久化存储？**
- A. ConfigMap
- B. Secret
- C. volumeClaimTemplates
- D. EmptyDir

答案：!!C!!

## DaemonSet与系统服务

**51. DaemonSet的主要用途是什么？**
- A. 运行普通应用
- B. 确保每个节点上运行一个Pod副本
- C. 只运行一次性任务
- D. 只用于存储管理

答案：!!B!!

**52. DaemonSet典型的使用场景不包括？**
- A. 日志收集
- B. 监控代理
- C. Web应用
- D. 网络插件

答案：!!C!!

**53. 如何让DaemonSet只在部分节点上运行？**
- A. 使用nodeSelector或亲和性
- B. 不能实现
- C. 只能手动控制
- D. 使用namespace隔离

答案：!!A!!

**54. 当新节点加入集群时，DaemonSet会自动在新节点上创建Pod吗？**
- A. 不会，需要手动创建
- B. 会自动创建
- C. 需要重启DaemonSet
- D. 需要删除后重新创建DaemonSet

答案：!!B!!

**55. DaemonSet的更新策略包括哪些？**
- A. RollingUpdate和OnDelete
- B. 只有RollingUpdate
- C. 只有OnDelete
- D. 不支持更新

答案：!!A!!

## Job与CronJob

**56. Job的作用是什么？**
- A. 运行长期服务
- B. 运行一次性任务直到成功完成
- C. 定时运行任务
- D. 只用于数据备份

答案：!!B!!

**57. Job的completions字段表示什么？**
- A. Job的超时时间
- B. 需要成功完成的Pod数量
- C. 最大重试次数
- D. 并行度

答案：!!B!!

**58. Job的parallelism字段表示什么？**
- A. 总任务数
- B. 同时运行的Pod数量
- C. 失败重试次数
- D. 超时时间

答案：!!B!!

**59. CronJob与Job的关系是？**
- A. CronJob定期创建Job
- B. Job定期创建CronJob
- C. 两者没有关系
- D. CronJob是Job的别名

答案：!!A!!

**60. CronJob的时间格式遵循什么标准？**  ***!***
- A. ISO 8601
- B. Unix Cron表达式
- C. 自定义格式
- D. RFC 3339

答案：!!B!!

## HPA与自动扩缩

**61. HPA代表什么？**
- A. Horizontal Pod Autoscaler
- B. High Performance Application
- C. Host Port Allocation
- D. HTTP Proxy Agent

答案：!!A!!

**62. HPA根据什么指标进行扩缩容？**
- A. 只能根据CPU
- B. 只能根据内存
- C. 可以根据CPU、内存或自定义指标
- D. 不支持任何指标

答案：!!C!!

**63. 使用HPA之前需要部署什么组件？** ***!***
- A. Metrics Server
- B. Prometheus
- C. Grafana
- D. 不需要任何组件

答案：!!A!!

**64. HPA的扩容和缩容策略默认如何？**
- A. 立即扩缩容
- B. 扩容较快，缩容较慢（有冷却时间）
- C. 扩容较慢，缩容较快
- D. 扩缩容速度相同

答案：!!B!!

**65. HPA可以与以下哪个控制器配合使用？**
- A. 只能与Deployment
- B. 只能与StatefulSet
- C. 可以与Deployment、ReplicaSet、StatefulSet等
- D. 不能与任何控制器配合

答案：!!C!!

## 探针与健康检查

**66. Kubernetes支持哪些类型的探针？**
- A. 只有livenessProbe
- B. 只有readinessProbe
- C. livenessProbe、readinessProbe和startupProbe
- D. 只有healthProbe

答案：!!C!!

**67. livenessProbe的作用是什么？**
- A. 检查Pod是否准备好接收流量
- B. 检查容器是否存活，失败则重启容器
- C. 检查容器是否启动完成
- D. 只用于记录日志

答案：!!B!!

**68. readinessProbe的作用是什么？**
- A. 检查容器是否存活
- B. 检查Pod是否准备好接收流量
- C. 检查容器是否启动完成
- D. 只用于监控

答案：!!B!!

**69. 探针支持哪些检查方式？**
- A. 只支持HTTP GET
- B. 只支持TCP Socket
- C. 支持HTTP GET、TCP Socket和Exec命令
- D. 不支持任何检查方式

答案：!!C!!

**70. startupProbe的作用是什么？**
- A. 加速容器启动
- B. 为慢启动容器提供足够的启动时间
- C. 检查容器是否存活
- D. 检查容器是否准备好接收流量

答案：!!B!!

## 监控与日志

**71. Kubernetes集群监控的标准方案是？**
- A. ELK
- B. Prometheus + Grafana
- C. Zabbix
- D. Nagios

答案：!!B!!

**72. 如何查看Pod的日志？**
- A. kubectl logs &lt;pod-name&gt;
- B. kubectl log &lt;pod-name&gt;
- C. kubectl get logs &lt;pod-name&gt;
- D. kubectl describe &lt;pod-name&gt;

答案：!!A!!

**73. 如何查看多容器Pod中特定容器的日志？**  ***!***
- A. kubectl logs &lt;pod-name&gt; &lt;container-name&gt;
- B. kubectl logs &lt;pod-name&gt; -c &lt;container-name&gt;
- C. 两者都可以
- D. 不能查看特定容器日志

答案：!!C!!

**74. 集群日志收集的常用方案不包括？**
- A. EFK (Elasticsearch + Fluentd + Kibana)
- B. ELK (Elasticsearch + Logstash + Kibana)
- C. Loki + Promtail + Grafana
- D. MySQL + Apache

答案：!!D!!

**75. Metrics Server提供什么功能？**  ***!***
- A. 日志收集
- B. 提供集群资源使用指标
- C. 应用性能监控
- D. 只提供网络监控

答案：!!B!!

## 安全与认证

**76. Kubernetes的认证方式不包括以下哪个？**
- A. 客户端证书
- B. Bearer Token
- C. 用户名密码
- D. 短信验证码

答案：!!D!!

**77. Pod Security Admission (PSA)的作用是什么？**（注：Pod Security Policy 在 Kubernetes 1.25+ 已移除）
- A. 管理网络安全
- B. 控制 Pod 的安全相关配置，实施 Pod 安全标准
- C. 只管理存储安全
- D. 只管理镜像安全

答案：!!B!!

**78. 如何限制容器以非root用户运行？** ***!***
- A. 无法限制
- B. 使用SecurityContext设置runAsNonRoot
- C. 只能在Dockerfile中设置
- D. 使用ConfigMap

答案：!!B!!

**79. Network Policy默认策略是什么？**
- A. 拒绝所有流量
- B. 允许所有流量
- C. 只允许同命名空间流量
- D. 只允许出站流量

答案：!!B!!

**80. Secrets在etcd中默认是如何存储的？**
- A. 明文存储
- B. Base64编码存储（未加密）
- C. AES加密存储
- D. RSA加密存储

答案：!!B!!

## 高可用与集群管理

**81. Kubernetes控制平面组件不包括以下哪个？**
- A. kube-apiserver
- B. kube-scheduler
- C. kube-controller-manager
- D. kubelet

答案：!!D!!

**82. etcd在Kubernetes中的作用是什么？**
- A. 运行容器
- B. 存储集群的所有配置和状态数据
- C. 负责网络路由
- D. 只用于日志存储

答案：!!B!!

**83. kubelet运行在哪里？**
- A. 只在Master节点
- B. 只在Worker节点
- C. 在每个节点上
- D. 不需要运行

答案：!!C!!

**84. kube-proxy的作用是什么？**
- A. 代理HTTP请求
- B. 实现Service的网络代理和负载均衡
- C. 只用于DNS解析
- D. 只用于认证

答案：!!B!!

**85. Kubernetes集群升级的推荐方式是？**
- A. 直接替换所有组件
- B. 先升级控制平面，再升级节点，遵循版本偏差策略
- C. 只升级Master节点
- D. 同时升级所有节点

答案：!!B!!

## 最佳实践

**86. 在生产环境中，建议如何设置Pod的资源requests和limits？**
- A. 不设置
- B. 只设置requests
- C. 只设置limits
- D. 同时设置requests和limits

答案：!!D!!

**87. 多环境部署（开发、测试、生产）的推荐做法是？**
- A. 使用同一个集群的不同命名空间
- B. 使用不同的集群
- C. 根据需求选择，通常生产环境独立集群
- D. 必须使用同一个集群

答案：!!C!!

**88. 容器镜像的最佳实践不包括？**
- A. 使用latest标签
- B. 使用特定版本标签
- C. 使用多阶段构建减小镜像大小
- D. 定期扫描镜像漏洞

答案：!!A!!

**89. 如何确保关键应用的高可用？**
- A. 只运行一个副本
- B. 运行多个副本，并使用Pod反亲和性分布在不同节点
- C. 只依赖自动重启
- D. 不需要特殊配置

答案：!!B!!

**90. ConfigMap和Secret的使用建议是？**
- A. 所有配置都用ConfigMap
- B. 敏感信息使用Secret，非敏感配置使用ConfigMap
- C. 所有配置都用Secret
- D. 不使用这两个资源

答案：!!B!!

## 故障排查

**91. Pod一直处于Pending状态，可能的原因不包括？**
- A. 资源不足
- B. 没有可用节点
- C. PVC未绑定
- D. 容器内应用崩溃

答案：!!D!!

**92. 如何查看Pod的详细信息和事件？**
- A. kubectl get pod &lt;pod-name&gt;
- B. kubectl describe pod &lt;pod-name&gt;
- C. kubectl logs &lt;pod-name&gt;
- D. kubectl exec &lt;pod-name&gt;

答案：!!B!!

**93. Pod处于CrashLoopBackOff状态表示什么？**
- A. Pod正常运行
- B. 容器反复启动失败并进入重启循环
- C. Pod正在删除
- D. Pod正在更新

答案：!!B!!

**94. 如何进入正在运行的容器进行调试？**
- A. kubectl exec -it &lt;pod-name&gt; -- /bin/sh
- B. kubectl attach &lt;pod-name&gt;
- C. kubectl debug &lt;pod-name&gt;
- D. kubectl ssh &lt;pod-name&gt;

答案：!!A!!

**95. Service无法访问后端Pod，如何排查？**
- A. 只检查Service配置
- B. 检查Service的标签选择器是否与Pod标签匹配
- C. 只检查网络配置
- D. 删除后重新创建

答案：!!B!!

## 进阶特性

**96. Operator模式的主要作用是什么？**
- A. 只用于监控
- B. 将运维知识编码，自动化管理复杂应用
- C. 只用于备份
- D. 只用于网络管理

答案：!!B!!

**97. Custom Resource Definition (CRD)的作用是什么？**
- A. 修改现有资源
- B. 扩展Kubernetes API，定义自定义资源
- C. 只用于配置管理
- D. 只用于权限控制

答案：!!B!!

**98. Admission Controller的作用是什么？** ***!***
- A. 控制集群访问
- B. 拦截和修改API请求
- C. 只用于认证
- D. 只用于授权

答案：!!B!!

**99. InitContainer和SideCar容器的区别是？**
- A. 没有区别
- B. InitContainer在主容器之前运行并退出，SideCar与主容器并行运行
- C. InitContainer与主容器并行运行
- D. SideCar在主容器之前运行

答案：!!B!!

**100. PodDisruptionBudget (PDB)的作用是什么？**
- A. 限制Pod的资源使用
- B. 在自愿中断期间保证最少可用Pod数量
- C. 只用于调度
- D. 只用于监控

答案：!!B!!

---

## 评分标准

- 90-100分：优秀，对Kubernetes核心概念掌握扎实
- 80-89分：良好，大部分核心知识点已掌握
- 70-79分：中等，需要加强部分知识点的学习
- 60-69分：及格，建议系统复习相关文档
- 60分以下：需要重新学习Kubernetes基础知识

---

## 题目解析

### 第8题：查看Deployment滚动更新历史
**正确答案：C** - `kubectl rollout history deployment`

**解析：**`kubectl rollout history` 是专门用于查看资源滚动更新历史记录的命令，可以显示所有版本记录及变更原因。

---

### 第14题：Service如何选择后端Pod
**正确答案：B** - 通过标签选择器(Label Selector)

**解析：**Service 通过 `selector` 字段定义的标签选择器来匹配后端 Pod。只有标签完全匹配的 Pod 才会被加入 Service 的 Endpoints。

---

### 第15题：Headless Service的ClusterIP值
**正确答案：B** - None

**解析：**Headless Service 不需要 ClusterIP，因此在 Service 定义中设置 `clusterIP: None`。这样可以直接返回 Pod IP 而不是虚拟 IP。

---

### 第23题：PV回收策略
**正确答案：D** - Archive（不存在此策略）

**解析：**PV 的回收策略只有三种：
- **Retain**：保留数据，需手动清理
- **Recycle**：已废弃，执行基本清理（rm -rf）
- **Delete**：删除底层存储资源

---

### 第24题：StorageClass的作用
**正确答案：B** - 动态供应存储卷

**解析：**StorageClass 允许管理员定义不同"类别"的存储，当 PVC 请求存储时，StorageClass 会自动创建 PV，无需手动预先创建。

---

### 第25题：PVC访问模式
**正确答案：D** - ReadWriteAll（不存在此模式）

**解析：**PVC 的访问模式只有三种：
- **ReadWriteOnce (RWO)**：单节点读写
- **ReadOnlyMany (ROX)**：多节点只读
- **ReadWriteMany (RWX)**：多节点读写

---

### 第26题：Kubernetes默认命名空间
**正确答案：D** - kube-user（不存在）

**解析：**Kubernetes 默认创建的命名空间包括：
- **default**：默认命名空间
- **kube-system**：系统组件命名空间
- **kube-public**：公开可读的命名空间
- **kube-node-lease**（新版本）：节点心跳命名空间

---

### 第29题：命名空间级别的资源
**正确答案：C** - Deployment

**解析：**Deployment 是命名空间级别的资源，必须在特定命名空间中创建。而 Node、PersistentVolume 和 Namespace 本身都是集群级别资源。

---

### 第35题：RBAC权限动词
**正确答案：D** - modify（不存在）

**解析：**RBAC 标准权限动词包括：
- **get、list、watch**：读权限
- **create、update、patch、delete**：写权限
- **deletecollection**：批量删除

没有 `modify` 这个动词，修改操作使用 `update` 或 `patch`。

---

### 第48题：StatefulSet更新策略
**正确答案：D** - Parallel（不存在）

**解析：**StatefulSet 只有两种更新策略：
- **RollingUpdate**：滚动更新，按顺序更新 Pod
- **OnDelete**：手动删除 Pod 时才更新

---

### 第60题：CronJob时间格式
**正确答案：B** - Unix Cron表达式

**解析：**CronJob 使用标准的 Unix Cron 表达式（5个字段）：`分 时 日 月 周`，例如 `0 2 * * *` 表示每天凌晨2点执行。

---

### 第63题：使用HPA的前置要求
**正确答案：A** - Metrics Server

**解析：**HPA 需要 Metrics Server 提供资源使用指标（CPU/内存）。Metrics Server 从 kubelet 收集指标，HPA 根据这些指标做出扩缩容决策。

---

### 第73题：查看多容器Pod特定容器日志
**正确答案：C** - 两者都可以

**解析：**两种语法都支持：
- `kubectl logs <pod-name> <container-name>`
- `kubectl logs <pod-name> -c <container-name>`

推荐使用 `-c` 参数，更清晰明确。

---

### 第75题：Metrics Server功能
**正确答案：B** - 提供集群资源使用指标

**解析：**Metrics Server 是集群级别的资源使用数据聚合器，提供：
- CPU 和内存使用指标
- 支持 `kubectl top` 命令
- 为 HPA/VPA 提供数据源

---

### 第78题：限制容器以非root用户运行
**正确答案：B** - 使用SecurityContext设置runAsNonRoot

**解析：**在 Pod 或容器的 `securityContext` 中设置：
```yaml
securityContext:
  runAsNonRoot: true
  runAsUser: 1000  # 指定用户ID
```
这会确保容器不能以 root 用户运行。

---

### 第98题：Admission Controller作用
**正确答案：B** - 拦截和修改API请求

**解析：**Admission Controller 在请求持久化到 etcd 之前拦截 API 请求，可以：
- **验证**（Validating）：拒绝不符合规则的请求
- **修改**（Mutating）：自动修改请求内容（如注入 sidecar）

常见的 Admission Controller 包括 PodSecurityPolicy、ResourceQuota 等。

## 简答

### K8s 的核心架构是什么？请分别说明 Master 节点（控制平面）和 Node 节点（工作节点）的核心组件及职责。

Kubernetes (K8s) 采用主从架构模式，分为控制平面（Master 节点）和工作节点（Node 节点）两部分。

#### Master 节点（控制平面）核心组件

**kube-apiserver**
- 提供 Kubernetes API，是整个集群的统一入口
- 处理所有 REST 请求，进行认证、授权和准入控制
- 是唯一与 etcd 交互的组件

**etcd**
- 分布式键值存储数据库
- 保存集群的所有配置信息和状态数据
- 提供数据的持久化存储和一致性保证

**kube-scheduler**
- 负责 Pod 的调度决策
- 根据资源需求、约束条件、亲和性等因素为 Pod 选择合适的 Node
- 将调度结果写入 etcd，由 kubelet 执行

**kube-controller-manager**
- 运行各种控制器进程，包括 Node Controller、Replication Controller、Endpoints Controller、Service Account Controller 等
- 监控集群状态并进行调谐，确保实际状态与期望状态一致

**cloud-controller-manager（可选）**
- 与云平台交互的控制器
- 管理云服务相关的资源，如负载均衡器、存储卷等

#### Node 节点（工作节点）核心组件

**kubelet**
- 运行在每个 Node 上的主要代理
- 负责 Pod 的生命周期管理，确保容器按照 PodSpec 运行
- 向 apiserver 汇报节点和 Pod 状态
- 管理存储卷的挂载

**kube-proxy**
- 实现 Kubernetes Service 的网络代理
- 维护节点上的网络规则，实现服务发现和负载均衡
- 支持 iptables、ipvs 等多种代理模式

**Container Runtime**
- 容器运行时环境，负责容器的实际运行
- 支持 containerd、CRI-O 等符合 CRI（Container Runtime Interface）标准的运行时
- 负责镜像管理和容器生命周期操作

这种架构设计实现了控制平面与数据平面的分离，保证了集群的高可用性和可扩展性。

Pod 是什么？为什么 K8s 最小调度单元是 Pod 而不是容器？Pod 的核心组成部分有哪些？

### Pod 是什么？为什么 K8s 最小调度单元是 Pod 而不是容器？Pod 的核心组成部分有哪些?

#### Pod 的定义

Pod 是 Kubernetes 中最小的可部署和可管理的计算单元。它是一个或多个容器的集合，这些容器共享网络、存储等资源，并且作为一个整体进行调度和管理。可以将 Pod 理解为一个"逻辑主机"，其中运行着紧密耦合的应用容器。

#### 为什么最小调度单元是 Pod 而不是容器

Kubernetes 选择 Pod 而不是容器作为最小调度单元，主要基于以下几个原因:

**资源共享需求** - 在实际应用中，经常需要多个容器紧密协作，它们需要共享网络命名空间(如 localhost 通信)、存储卷、进程间通信等资源。如果以单个容器为调度单元，这种共享会变得复杂且难以保证原子性。

**原子性调度** - Pod 中的所有容器会被调度到同一个节点上，要么全部成功，要么全部失败。这保证了紧密耦合的容器始终在一起运行，避免了跨节点通信的复杂性和性能问题。

**设计模式支持** - Pod 支持 sidecar、adapter、ambassador 等容器设计模式。例如，主应用容器配合日志收集容器、代理容器等辅助容器共同工作，这些辅助容器为主容器提供支撑功能。

**生命周期管理** - Pod 作为一个整体有统一的生命周期，所有容器共享相同的启动、停止、重启策略，简化了管理复杂度。

#### Pod 的核心组成部分

**容器(Containers)** - 包括一个或多个应用容器，以及可选的初始化容器(Init Containers)和临时容器(Ephemeral Containers)。初始化容器在主容器启动前运行完成，通常用于准备工作；临时容器用于调试目的。

**网络** - Pod 内的所有容器共享同一个网络命名空间，拥有相同的 IP 地址和端口空间。容器之间可以通过 localhost 相互通信，对外则通过 Pod IP 访问。

**存储卷(Volumes)** - Pod 可以定义多个存储卷，供其内部容器挂载使用。这些卷的生命周期与 Pod 相同，实现了容器间的数据共享和持久化。

**元数据(Metadata)** - 包括 Pod 的名称、命名空间、标签(Labels)、注解(Annotations)等信息，用于标识和组织 Pod。

**规约(Spec)** - 定义 Pod 的期望状态，包括容器配置、资源需求(CPU、内存)、调度策略、重启策略、安全上下文等。

**状态(Status)** - 反映 Pod 的当前实际状态，包括所处阶段(Pending、Running、Succeeded、Failed 等)、容器状态、IP 地址、调度信息等运行时数据。

### 请解释 K8s 的控制循环（Control Loop） 思想，以及它如何保证集群的期望状态与实际状态一致。

#### 控制循环的核心思想

Kubernetes 的控制循环是一种声明式系统设计模式，其核心思想是持续监控系统的实际状态，并不断将其调整到用户声明的期望状态。这个过程类似于恒温器的工作原理：设定目标温度后，恒温器会持续检测当前温度，并通过加热或制冷来维持目标温度。

在 K8s 中，控制循环遵循以下基本流程：

1. **观察（Observe）**：通过 API Server 获取资源的当前实际状态
2. **分析（Diff）**：对比期望状态与实际状态的差异
3. **执行（Act）**：采取必要的操作来消除差异
4. **循环（Loop）**：持续重复上述过程

#### 工作机制

**Controller Manager 的角色**

Kubernetes 通过 Controller Manager 运行多个控制器，每个控制器负责特定类型资源的协调工作。常见的控制器包括：

- Deployment Controller：管理 Deployment 资源
- ReplicaSet Controller：确保 Pod 副本数量符合预期
- Node Controller：监控节点健康状态
- Job Controller：管理批处理任务

**Watch 机制**

控制器通过 Watch 机制监听 API Server 中资源对象的变化，而不是轮询。当资源发生变化时，API Server 会主动推送事件通知，这种机制保证了高效性和实时性。

**Reconcile 调谐过程**

当控制器接收到事件通知后，会触发 Reconcile（调谐）函数，该函数的主要逻辑是：

```
期望状态（Desired State）来自用户定义的 YAML 规范
实际状态（Actual State）来自集群当前运行情况

if 实际状态 != 期望状态:
    执行操作使实际状态趋向期望状态
```

#### 保证状态一致性的机制

**持续协调**

控制循环不是一次性操作，而是持续运行的。即使系统达到期望状态，控制器仍会定期检查，确保状态不会因外部因素而偏离。这种设计使 K8s 具有自愈能力。

**幂等性设计**

控制器的操作被设计为幂等的，无论执行多少次都会产生相同的结果。这意味着即使重复调谐，也不会对系统造成副作用。

**乐观并发控制**

K8s 使用 ResourceVersion 机制实现乐观锁。每次更新资源时，都会检查版本号，如果版本不匹配说明资源已被其他操作修改，需要重新获取最新状态后再次尝试。

**事件驱动 + 定期同步**

虽然主要依赖事件驱动，但控制器也会定期（默认每 10 小时）执行全量同步，防止因 Watch 机制丢失事件而导致的状态不一致。

#### 实际案例

假设用户创建一个 Deployment，要求运行 3 个 Nginx Pod：

1. 用户提交 YAML，API Server 存储期望状态（replicas: 3）
2. Deployment Controller 监听到创建事件，创建对应的 ReplicaSet
3. ReplicaSet Controller 发现当前 Pod 数量为 0，期望为 3
4. 控制器调用 API Server 创建 3 个 Pod
5. Scheduler 为 Pod 分配节点，Kubelet 启动容器
6. 如果某个 Pod 意外终止，ReplicaSet Controller 检测到实际副本数变为 2
7. 控制器立即创建新 Pod，将副本数恢复到 3

这个过程展示了控制循环如何通过持续监控和自动修正来保证集群状态与用户期望保持一致。

### K8s 的 Service 资源有什么作用?ClusterIP、NodePort、LoadBalancer、ExternalName 四种类型分别适用于什么场景?

#### Service 资源的作用

Kubernetes 中的 Service 是一个抽象层,用于定义一组 Pod 的访问策略。它解决了以下核心问题:

**服务发现与负载均衡**: Pod 的 IP 地址是动态变化的,当 Pod 重启或扩缩容时 IP 会改变。Service 提供了一个稳定的虚拟 IP 和 DNS 名称,屏蔽了后端 Pod 的变化,并在多个 Pod 副本之间自动进行负载均衡。

**解耦应用组件**: 前端应用不需要知道后端 Pod 的具体地址,只需通过 Service 名称访问即可,这使得应用组件之间松耦合,便于独立部署和扩展。

#### 四种 Service 类型及其适用场景

#### ClusterIP

ClusterIP 是默认的 Service 类型,它为 Service 分配一个集群内部的虚拟 IP 地址,只能在集群内部访问。

适用场景包括集群内部微服务之间的通信,比如前端服务调用后端 API 服务、应用层访问数据库服务等。这种类型提供了基本的服务发现和负载均衡功能,是最常用的内部通信方式。

#### NodePort

NodePort 类型在 ClusterIP 的基础上,还会在每个 Node 节点上开放一个静态端口(范围通常是 30000-32767)。通过访问任意节点的 IP 加上这个端口,流量会被转发到对应的 Service。

这种类型适合需要从集群外部访问服务的场景,例如开发测试环境中快速暴露服务、没有 LoadBalancer 的本地或私有云环境、需要通过防火墙规则精确控制外部访问的情况。不过由于需要记住端口号且端口范围有限,通常不推荐在生产环境大规模使用。

#### LoadBalancer

LoadBalancer 类型会自动创建一个云服务商提供的外部负载均衡器(如 AWS ELB、GCP Load Balancer、Azure Load Balancer),并将流量分发到后端的 NodePort Service。

这种类型主要用于公有云环境中对外暴露服务,适合生产环境中需要高可用、自动故障转移的场景,比如对外提供的 Web 应用、API 网关等。它提供了专业的负载均衡能力和健康检查机制,但会产生额外的云服务费用。

#### ExternalName

ExternalName 类型比较特殊,它不提供负载均衡,而是通过返回 CNAME 记录的方式将 Service 映射到一个外部的 DNS 名称。

适用场景包括将集群内的服务请求重定向到集群外部的服务,比如访问外部的数据库、第三方 API 服务、或者在服务迁移过程中作为过渡方案。这种方式可以让集群内的应用无需修改代码就能访问外部资源,只需通过 Service 名称即可。

### 什么是 K8s 的 Ingress？它和 Service 的区别是什么？Ingress Controller 的核心作用是什么？

#### 什么是 Ingress

Ingress 是 Kubernetes 中的一个 API 对象，用于管理集群外部到集群内服务的 HTTP 和 HTTPS 访问。它提供了负载均衡、SSL 终止和基于名称的虚拟主机等功能。简单来说，Ingress 定义了外部流量如何路由到集群内的服务。

一个典型的 Ingress 资源可以根据 URL 路径或域名将流量分发到不同的后端服务，例如：
- `example.com/api` 路由到 API 服务
- `example.com/web` 路由到前端服务
- `blog.example.com` 路由到博客服务

#### Ingress 和 Service 的区别

**Service 的特点：**
- Service 是 Kubernetes 中服务发现和负载均衡的基础抽象
- 工作在 L4 层（传输层），主要处理 TCP/UDP 流量
- 类型包括 ClusterIP（集群内访问）、NodePort（节点端口访问）、LoadBalancer（云厂商负载均衡器）
- 每个对外暴露的服务通常需要一个独立的负载均衡器（LoadBalancer 类型）或端口（NodePort 类型）

**Ingress 的特点：**
- 工作在 L7 层（应用层），专门处理 HTTP/HTTPS 流量
- 可以通过单一入口点管理多个服务的访问规则
- 支持基于域名、路径的智能路由
- 提供 SSL/TLS 终止、URL 重写等高级功能
- 更经济高效，一个负载均衡器可以服务多个应用

**核心区别：**
- Service 是服务的网络抽象，Ingress 是访问规则的集合
- Service 可以独立存在，Ingress 必须依赖 Service 作为后端
- 对于需要 HTTP 路由的场景，通常的架构是：外部流量 → Ingress → Service → Pod

#### Ingress Controller 的核心作用

Ingress Controller 是实现 Ingress 规则的实际组件，它的核心作用包括：

**1. 规则实现**
- 监听 Kubernetes API 中的 Ingress 资源变化
- 将 Ingress 定义的抽象规则转换为具体的配置
- 动态更新负载均衡和路由配置

**2. 流量管理**
- 接收外部流量并根据 Ingress 规则进行路由
- 执行负载均衡，将请求分发到对应的后端 Service
- 处理 SSL/TLS 加密和证书管理

**3. 常见实现**
常见的 Ingress Controller 包括 Nginx Ingress Controller、Traefik、HAProxy、Kong 等。不同的实现可能提供额外的功能，如速率限制、认证、日志记录等。

需要注意的是，Kubernetes 集群默认不包含 Ingress Controller，需要单独部署。没有 Ingress Controller，Ingress 资源只是一个配置定义，不会产生实际效果。

### 简述 K8s 的 Namespace 资源,它的设计目的是什么?如何在 Namespace 间隔离资源?

#### Namespace 概述

Namespace 是 Kubernetes 中用于实现多租户资源隔离的一种机制,它将集群内部的资源对象划分到不同的虚拟分区中。可以将 Namespace 理解为 Kubernetes 集群内部的虚拟集群。

#### 设计目的

Namespace 的主要设计目的包括:

1. **资源隔离**: 为不同的项目、团队或环境(如开发、测试、生产)提供逻辑上隔离的工作空间。

2. **资源配额管理**: 通过 ResourceQuota 对象限制每个 Namespace 可使用的计算资源(CPU、内存)和对象数量,避免资源过度消耗。

3. **访问控制**: 配合 RBAC(基于角色的访问控制)实现细粒度的权限管理,限制用户只能访问特定 Namespace 中的资源。

4. **命名空间**: 避免不同团队或项目之间的资源命名冲突,同一个资源名称可以在不同 Namespace 中重复使用。

#### Namespace 间资源隔离方式

Kubernetes 通过以下机制实现 Namespace 间的资源隔离:

**1. 对象级隔离**

大部分 Kubernetes 资源都是 Namespace 级别的,包括 Pod、Service、Deployment、ConfigMap、Secret 等。这些资源只能在所属的 Namespace 内可见和访问。

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  namespace: dev  # 指定 Namespace
spec:
  containers:
  - name: nginx
    image: nginx
```

**2. 网络隔离**

通过 NetworkPolicy 可以实现 Namespace 间的网络隔离,控制跨 Namespace 的流量访问:

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-from-other-namespaces
  namespace: prod
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector: {}  # 只允许同 Namespace 内的 Pod 访问
```

**3. 资源配额限制**

使用 ResourceQuota 限制 Namespace 的资源使用:

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: compute-quota
  namespace: dev
spec:
  hard:
    requests.cpu: "10"
    requests.memory: 20Gi
    pods: "50"
```

**4. 访问权限控制**

通过 RBAC 的 Role 和 RoleBinding 将权限限制在特定 Namespace:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: dev
  name: pod-reader
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
```

**5. LimitRange 资源限制**

为 Namespace 中的每个容器或 Pod 设置默认的资源请求和限制:

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: mem-limit-range
  namespace: dev
spec:
  limits:
  - default:
      memory: 512Mi
    defaultRequest:
      memory: 256Mi
    type: Container
```

#### 注意事项

- 并非所有资源都是 Namespace 级别的,例如 Node、PersistentVolume、StorageClass 等是集群级资源,不受 Namespace 限制。
- Namespace 删除时,其中的所有资源也会被级联删除,操作需谨慎。
- 默认情况下,Kubernetes 集群会创建 `default`、`kube-system`、`kube-public` 和 `kube-node-lease` 四个初始 Namespace。

### 请说明 K8s 中 ConfigMap 和 Secret 的区别？Secret 有哪些类型？如何安全地将配置 / 密钥注入到 Pod 中？

#### ConfigMap 和 Secret 的区别

ConfigMap 和 Secret 都用于存储配置数据并注入到 Pod 中，但它们有以下关键区别：

**存储内容的性质**：ConfigMap 用于存储非敏感的配置数据，如应用配置文件、环境变量等；Secret 专门用于存储敏感数据，如密码、token、密钥等。

**数据编码**：ConfigMap 以明文形式存储数据；Secret 使用 Base64 编码存储数据（注意这不是加密，只是编码）。

**安全特性**：Secret 在 etcd 中可以配置加密存储，且 Kubernetes 会对 Secret 的访问进行更严格的控制，比如只将 Secret 数据挂载到需要它的节点上。

**使用场景**：ConfigMap 适合存储应用配置、配置文件模板等；Secret 适合存储数据库密码、API 密钥、TLS 证书等敏感信息。

#### Secret 的类型

Kubernetes 支持多种 Secret 类型，主要包括：

**Opaque**：默认类型，用于存储任意用户定义的数据，最常用的通用 Secret 类型。

**kubernetes.io/service-account-token**：用于 ServiceAccount 的身份认证 token，由 Kubernetes 自动创建和管理。

**kubernetes.io/dockercfg** 和 **kubernetes.io/dockerconfigjson**：用于存储 Docker 镜像仓库的认证信息，dockerconfigjson 是新版格式。

**kubernetes.io/basic-auth**：用于存储基本认证的用户名和密码。

**kubernetes.io/ssh-auth**：用于存储 SSH 私钥。

**kubernetes.io/tls**：用于存储 TLS 证书和私钥，包含 tls.crt 和 tls.key 两个字段。

**bootstrap.kubernetes.io/token**：用于节点引导时的 token。

#### 安全地将配置 / 密钥注入到 Pod 中

有以下几种推荐的安全注入方式：

**环境变量注入**：通过 `envFrom` 或 `env` 字段将 ConfigMap 或 Secret 注入为环境变量。这种方式简单直接，但环境变量可能会被子进程继承或在日志中泄露，因此对于高敏感数据需谨慎使用。

**Volume 挂载**：将 ConfigMap 或 Secret 挂载为文件到容器的文件系统中，这是最推荐的方式。挂载的文件默认权限为 0644（ConfigMap）或 0400（Secret），可以通过 `defaultMode` 调整。Secret 以 tmpfs 形式挂载，不会写入磁盘。

**使用 RBAC 控制访问**：通过 Role 和 RoleBinding 限制哪些 ServiceAccount 可以访问特定的 Secret，实现最小权限原则。

**启用 etcd 加密**：在集群层面配置 EncryptionConfiguration，对存储在 etcd 中的 Secret 进行加密，防止直接访问 etcd 数据库造成的泄露。

**使用外部密钥管理系统**：集成 HashiCorp Vault、AWS Secrets Manager、Azure Key Vault 等外部密钥管理服务，通过 CSI Driver 或 Sidecar 容器动态获取密钥，避免在 Kubernetes 中直接存储敏感数据。

**限制 Secret 的作用域**：使用 namespace 隔离 Secret，确保 Secret 只在需要的 namespace 中可见。

**定期轮换密钥**：建立密钥轮换机制，定期更新 Secret 内容，并通过滚动更新方式重启 Pod 以使用新密钥。

**避免在代码或镜像中硬编码**：永远不要将敏感信息硬编码在应用代码或容器镜像中，始终通过外部配置注入。

通过组合使用这些方法，可以显著提高 Kubernetes 集群中配置和密钥管理的安全性。

### 简述 K8s 的HPA（水平 Pod 自动扩缩容） 原理，如何基于 CPU / 内存使用率或自定义指标实现 HPA？

#### HPA 工作原理

HPA（Horizontal Pod Autoscaler）通过持续监控 Pod 的资源指标，自动调整 Deployment、ReplicaSet 或 StatefulSet 中的 Pod 副本数量。其核心工作流程如下：

HPA Controller 定期（默认15秒）从 Metrics Server 获取 Pod 的资源使用情况，根据目标值计算期望的副本数。计算公式为：期望副本数 = ceil[当前副本数 × (当前指标值 / 目标指标值)]。控制器会在满足条件时调整副本数，但为避免频繁抖动，HPA 设置了冷却时间（扩容3分钟，缩容5分钟）。

#### 基于 CPU/内存使用率实现 HPA

**前置条件：**
- 集群部署 Metrics Server
- Pod 必须设置 resource requests

**CPU 使用率示例：**

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70  # 目标CPU使用率70%
```

**内存使用率示例：**

```yaml
metrics:
- type: Resource
  resource:
    name: memory
    target:
      type: Utilization
      averageUtilization: 80  # 目标内存使用率80%
```

#### 基于自定义指标实现 HPA

**方案一：使用 Prometheus Adapter**

部署 Prometheus 和 Prometheus Adapter，将自定义指标暴露给 K8s Custom Metrics API。

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: custom-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-app
  minReplicas: 2
  maxReplicas: 20
  metrics:
  - type: Pods
    pods:
      metric:
        name: http_requests_per_second
      target:
        type: AverageValue
        averageValue: "1000"  # 每个Pod平均1000 RPS
```

**方案二：使用外部指标**

基于集群外部系统的指标（如消息队列长度）：

```yaml
metrics:
- type: External
  external:
    metric:
      name: queue_messages_ready
      selector:
        matchLabels:
          queue_name: "tasks"
    target:
      type: AverageValue
      averageValue: "30"  # 每个Pod处理30条消息
```

#### 实施要点

**指标采集链路：** 应用暴露指标 → Prometheus 采集 → Prometheus Adapter 转换 → HPA 消费

**注意事项：** 合理设置 minReplicas 和 maxReplicas 防止资源耗尽或浪费，调整 behavior 配置控制扩缩容速率避免抖动，监控 HPA 事件排查扩缩容异常，自定义指标需要确保稳定性和准确性。

通过命令 `kubectl get hpa` 可以实时查看 HPA 状态和当前指标值，帮助调优配置参数。

### Kubernetes 常用命令汇总

#### 1. 查看所有命名空间的资源

```bash
# 查看所有命名空间的 Pod
kubectl get pods --all-namespaces
# 或使用简写
kubectl get pods -A

# 查看所有命名空间的 Deployment
kubectl get deployments --all-namespaces
kubectl get deploy -A

# 查看所有命名空间的 Service
kubectl get services --all-namespaces
kubectl get svc -A

# 同时查看多种资源
kubectl get pods,deployments,services -A
```

#### 2. 查看 Pod 的详细信息

```bash
# 查看 Pod 详细信息（包括 IP、节点、状态等）
kubectl describe pod <pod-name> -n <namespace>

# 查看 Pod 的详细 YAML 配置（包含所有字段）
kubectl get pod <pod-name> -n <namespace> -o yaml

# 查看 Pod 的关键信息（IP、节点、状态）
kubectl get pod <pod-name> -n <namespace> -o wide

# 查看 Pod 事件
kubectl get events -n <namespace> --field-selector involvedObject.name=<pod-name>
```

#### 3. 进入 Pod 内部执行命令

```bash
# 进入 Pod 的交互式 Shell（单容器 Pod）
kubectl exec -it <pod-name> -n <namespace> -- /bin/bash
# 或使用 sh（如果容器没有 bash）
kubectl exec -it <pod-name> -n <namespace> -- /bin/sh

# 在 Pod 中执行单条命令
kubectl exec <pod-name> -n <namespace> -- ls -la /app

# 指定容器名称（多容器 Pod）
kubectl exec -it <pod-name> -n <namespace> -c <container-name> -- /bin/bash
```

#### 4. 查看 Pod 日志

```bash
# 查看 Pod 日志（单容器）
kubectl logs <pod-name> -n <namespace>

# 查看指定容器的日志（多容器 Pod）
kubectl logs <pod-name> -n <namespace> -c <container-name>

# 查看 Sidecar 容器的日志
kubectl logs <pod-name> -n <namespace> -c <sidecar-container-name>

# 同时查看多个容器的日志（使用 --all-containers）
kubectl logs <pod-name> -n <namespace> --all-containers=true

# 实时追踪日志
kubectl logs -f <pod-name> -n <namespace>

# 查看最近 100 行日志
kubectl logs --tail=100 <pod-name> -n <namespace>

# 查看过去 1 小时的日志
kubectl logs --since=1h <pod-name> -n <namespace>

# 查看之前崩溃的容器日志
kubectl logs <pod-name> -n <namespace> --previous
```

#### 5. 扩容 / 缩容 Deployment

```bash
# 扩容到 5 个副本
kubectl scale deployment <deployment-name> -n <namespace> --replicas=5

# 缩容到 2 个副本
kubectl scale deployment <deployment-name> -n <namespace> --replicas=2

# 查看当前副本数
kubectl get deployment <deployment-name> -n <namespace>
```

#### 6. 回滚 Deployment 版本

```bash
# 查看 Deployment 的历史版本
kubectl rollout history deployment <deployment-name> -n <namespace>

# 查看特定版本的详细信息
kubectl rollout history deployment <deployment-name> -n <namespace> --revision=2

# 回滚到上一个版本
kubectl rollout undo deployment <deployment-name> -n <namespace>

# 回滚到指定版本
kubectl rollout undo deployment <deployment-name> -n <namespace> --to-revision=3

# 查看回滚状态
kubectl rollout status deployment <deployment-name> -n <namespace>

# 暂停发布（用于金丝雀发布）
kubectl rollout pause deployment <deployment-name> -n <namespace>

# 恢复发布
kubectl rollout resume deployment <deployment-name> -n <namespace>
```

#### 7. 查看集群节点资源使用情况

```bash
# 查看节点基本信息
kubectl get nodes

# 查看节点详细信息（包括资源容量和可分配量）
kubectl describe nodes

# 查看特定节点详细信息
kubectl describe node <node-name>

# 查看节点资源使用情况（需要安装 Metrics Server）
kubectl top nodes

# 查看所有 Pod 的资源使用情况
kubectl top pods -A

# 查看特定命名空间的 Pod 资源使用
kubectl top pods -n <namespace>

# 按内存使用排序
kubectl top pods -A --sort-by=memory

# 按 CPU 使用排序
kubectl top pods -A --sort-by=cpu
```

#### 补充：常用组合命令

```bash
# 监控 Pod 状态变化
watch kubectl get pods -n <namespace>

# 快速删除并重建 Pod（通过删除 Pod，Deployment 会自动创建新的）
kubectl delete pod <pod-name> -n <namespace>

# 强制删除卡住的 Pod
kubectl delete pod <pod-name> -n <namespace> --grace-period=0 --force

# 编辑 Deployment 配置
kubectl edit deployment <deployment-name> -n <namespace>

# 应用配置文件
kubectl apply -f deployment.yaml
```

这些命令涵盖了日常 Kubernetes 运维的主要场景。需要注意的是，`kubectl top` 命令需要集群中安装了 Metrics Server 才能使用。