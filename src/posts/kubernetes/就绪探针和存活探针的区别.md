---
date: 2025-07-01
author: Gaaming Zhang
isOriginal: false
article: true
category:
  - Kubernetes
tag:
  - Kubernetes
---

# 就绪探针和存活探针的区别

## 核心概念对比

在Kubernetes中，探针（Probes）是用于监控容器健康状态的关键机制，确保应用程序的可靠性和高可用性。存活探针和就绪探针是最常用的两种探针，它们分别解决不同的问题场景：

**存活探针（Liveness Probe）**：
- **目的**：检测容器是否还活着（是否死锁、假死）
- **失败后果**：重启容器
- **使用场景**：检测应用程序是否陷入死锁、无限循环等无法自动恢复的状态

**就绪探针（Readiness Probe）**：
- **目的**：检测容器是否准备好接收流量
- **失败后果**：从Service的Endpoints中移除，不会重启容器
- **使用场景**：应用启动需要时间、依赖服务未就绪、临时不可用

| 对比项       | 存活探针（Liveness） | 就绪探针（Readiness） |
| ------------ | -------------------- | --------------------- |
| **检测目标** | 容器是否存活         | 容器是否准备好服务    |
| **失败动作** | 重启容器             | 从Service移除         |
| **影响范围** | 单个容器             | 流量路由              |
| **检测频率** | 持续检测             | 持续检测              |
| **启动延迟** | initialDelaySeconds  | initialDelaySeconds   |
| **适用场景** | 死锁、假死           | 启动慢、临时不可用    |
| **Pod状态**  | 影响容器重启         | 影响Ready状态         |

### 失败行为的差异

探针的失败行为是两种探针的核心差异，这直接影响了Kubernetes如何管理和调度容器：

```yaml
# 存活探针失败流程
livenessProbe失败 → kubelet杀死容器 → 根据restartPolicy重启容器

# 就绪探针失败流程
readinessProbe失败 → 标记Pod为NotReady → 从Service Endpoints移除 → 不接收流量
```

### 对Pod状态的影响

```bash
# 查看Pod状态
kubectl get pod myapp-pod

# 存活探针正常，就绪探针失败
NAME         READY   STATUS    RESTARTS   AGE
myapp-pod    0/1     Running   0          5m
# READY显示0/1，但STATUS是Running

# 存活探针失败
NAME         READY   STATUS             RESTARTS   AGE
myapp-pod    0/1     CrashLoopBackOff   3          5m
# STATUS显示CrashLoopBackOff，RESTARTS次数增加
```

### 对Service流量的影响

```
存活探针：
- 失败 → 容器重启 → 短暂中断服务
- 不直接影响Service的Endpoints

就绪探针：
- 失败 → Pod从Endpoints移除 → 立即停止接收流量
- 容器继续运行，不会重启
```

## 探针类型与执行顺序

Kubernetes 1.16+引入了**启动探针（Startup Probe）**，与存活探针和就绪探针共同构成完整的探针体系：

### 三种探针对比

| 探针类型            | 作用               | 失败后果      | 典型场景                                |
| ------------------- | ------------------ | ------------- | --------------------------------------- |
| **Startup Probe**   | 检测容器是否已启动 | 重启容器      | 慢启动应用（避免livenessProbe过早杀死） |
| **Liveness Probe**  | 检测容器是否存活   | 重启容器      | 死锁、假死、内存泄漏                    |
| **Readiness Probe** | 检测容器是否就绪   | 从Service移除 | 依赖服务未就绪、临时不可用              |

### 探针执行顺序

探针按照以下顺序执行：
```
1. Startup Probe（如果配置）
   ↓ 成功后才开始
2. Liveness Probe（持续检测）
   和
3. Readiness Probe（持续检测）
```

## 探针配置详解

### 完整探针配置示例

以下是一个包含三种探针的完整Pod配置示例：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: probe-demo
spec:
  containers:
  - name: myapp
    image: myapp:v1
    ports:
    - containerPort: 8080
    
    # 启动探针：用于慢启动应用
    startupProbe:
      httpGet:
        path: /startup
        port: 8080
      initialDelaySeconds: 0      # 可以设为0，因为是专门检测启动
      periodSeconds: 10            # 每10秒检测一次
      failureThreshold: 30         # 允许失败30次（5分钟启动时间）
      successThreshold: 1          # 成功1次即可
      timeoutSeconds: 5            # 超时时间
    
    # 存活探针：检测死锁
    livenessProbe:
      httpGet:
        path: /health
        port: 8080
        httpHeaders:
        - name: Custom-Header
          value: Liveness
      initialDelaySeconds: 30      # 启动后30秒开始检测
      periodSeconds: 10            # 每10秒检测一次
      timeoutSeconds: 5            # 超时5秒算失败
      successThreshold: 1          # 成功1次即可
      failureThreshold: 3          # 连续失败3次才重启
    
    # 就绪探针：检测是否可以接收流量
    readinessProbe:
      httpGet:
        path: /ready
        port: 8080
      initialDelaySeconds: 5       # 启动后5秒开始检测
      periodSeconds: 5             # 每5秒检测一次
      timeoutSeconds: 3            # 超时3秒算失败
      successThreshold: 1          # 成功1次即Ready
      failureThreshold: 3          # 连续失败3次标记为NotReady
```

## 探针检测方法

**1. HTTP GET**（最常用）：

```yaml
livenessProbe:
  httpGet:
    path: /health        # 健康检查路径
    port: 8080           # 端口
    scheme: HTTP         # HTTP或HTTPS
    httpHeaders:         # 可选的HTTP头
    - name: Authorization
      value: Bearer token
  initialDelaySeconds: 30
  periodSeconds: 10
```

**HTTP探针注意事项**：
- 成功状态码：2xx（如200, 201）或3xx（如301, 302）
- 失败状态码：4xx（如404, 403）或5xx（如500, 503）
- 确保探针端点轻量，不消耗过多资源（避免复杂计算或数据库查询）
- 避免使用重定向（3xx状态码），除非有明确需求
- 探针端点应与业务代码隔离，避免业务逻辑错误影响探针准确性
- 对于高并发应用，探针端点应具有足够的线程池资源
- 可使用专用的探针服务（如Spring Boot Actuator的/actuator/health端点）来实现标准化的健康检查

**应用端实现**（Go示例）：
```go
// 健康检查端点
http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
    // 检查应用状态
    if appHealthy() {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("OK"))
    } else {
        w.WriteHeader(http.StatusServiceUnavailable)
        w.Write([]byte("Unhealthy"))
    }
})

// 就绪检查端点
http.HandleFunc("/ready", func(w http.ResponseWriter, r *http.Request) {
    // 检查依赖服务
    if databaseConnected() && cacheAvailable() {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("Ready"))
    } else {
        w.WriteHeader(http.StatusServiceUnavailable)
        w.Write([]byte("Not Ready"))
    }
})
```

**2. TCP Socket**（适用于TCP服务）：

```yaml
livenessProbe:
  tcpSocket:
    port: 3306           # MySQL端口
  initialDelaySeconds: 15
  periodSeconds: 10
```

**使用场景**：
- 数据库（MySQL、PostgreSQL）
- 缓存（Redis、Memcached）
- 消息队列（不提供HTTP接口的服务）

**3. Exec Command**（执行命令）：

```yaml
livenessProbe:
  exec:
    command:
    - cat
    - /tmp/healthy
  initialDelaySeconds: 5
  periodSeconds: 5

# 更复杂的检查脚本
readinessProbe:
  exec:
    command:
    - /bin/sh
    - -c
    - |
      # 检查进程
      if ! pgrep -f myapp > /dev/null; then
        exit 1
      fi
      # 检查文件
      if [ ! -f /tmp/ready ]; then
        exit 1
      fi
      exit 0
  initialDelaySeconds: 10
  periodSeconds: 5
```

**使用场景**：
- 无HTTP接口的应用
- 需要复杂逻辑判断
- 检查文件或进程状态

## 探针参数详解

探针配置包含以下核心参数：

```yaml
probe:
  # 初始延迟：容器启动后多久开始探测
  initialDelaySeconds: 30
  
  # 探测周期：多久探测一次
  periodSeconds: 10
  
  # 超时时间：单次探测的超时时间
  timeoutSeconds: 5
  
  # 成功阈值：连续成功多少次才算成功
  # Liveness和Startup只能是1
  # Readiness可以大于1
  successThreshold: 1
  
  # 失败阈值：连续失败多少次才算失败
  failureThreshold: 3
```

### 参数配置建议

| 场景             | initialDelay | period | timeout | failureThreshold |
| ---------------- | ------------ | ------ | ------- | ---------------- |
| **快速启动应用** | 5-10s        | 5-10s  | 3-5s    | 3                |
| **慢启动应用**   | 60-120s      | 10-20s | 5-10s   | 3-5              |
| **数据库**       | 30-60s       | 10s    | 5s      | 3                |
| **微服务**       | 10-30s       | 10s    | 5s      | 3                |

## 实际使用场景

**场景1：Web应用启动过程**

```
时间线：
t=0s    : 容器启动，应用开始初始化
t=5s    : Readiness开始检测 → 失败（应用还在启动）
t=15s   : 数据库连接成功
t=20s   : 缓存预热完成
t=25s   : Readiness检测 → 成功
          Pod标记为Ready，加入Service Endpoints，开始接收流量
t=30s   : Liveness开始检测 → 成功
t=40s   : Liveness检测 → 成功（持续监控）
```

**配置**：
```yaml
containers:
- name: webapp
  readinessProbe:
    httpGet:
      path: /ready
    initialDelaySeconds: 5   # 很快开始检测
    periodSeconds: 5
  livenessProbe:
    httpGet:
      path: /health
    initialDelaySeconds: 30  # 等应用完全启动后再检测
    periodSeconds: 10
```



## 最佳实践总结

**1. 探针端点设计**：
```
/livez   - Liveness检查：只检查应用本身
/readyz  - Readiness检查：检查应用和依赖
/startupz - Startup检查：简单检查，确认启动完成
```

**2. 参数配置原则**：
- **initialDelaySeconds**：根据应用启动时间设置，留出足够余量
- **periodSeconds**：不要太频繁（避免性能影响），10秒是常见值
- **timeoutSeconds**：略大于网络延迟，3-5秒合理
- **failureThreshold**：至少3次，给应用临时波动的容错

**3. 检查逻辑原则**：
- **Liveness**：只检查应用自身（避免级联失败）
- **Readiness**：可以检查依赖（影响流量路由）
- **轻量级**：避免复杂查询或计算
- **幂等性**：多次调用不影响应用状态

**4. 慢启动应用**：
- 使用Startup Probe（Kubernetes 1.18+）
- 或设置较大的initialDelaySeconds
- failureThreshold × periodSeconds ≥ 启动时间

**5. 分离关注点**：
```yaml
# 不同的检查路径
startupProbe:
  httpGet:
    path: /startupz    # 简单检查
livenessProbe:
  httpGet:
    path: /livez       # 检查应用存活
readinessProbe:
  httpGet:
    path: /readyz      # 检查是否就绪
```

## 调试和监控

**查看探针状态**：

```bash
# 查看Pod详情
kubectl describe pod <pod-name>

# 关键信息：
# - Conditions: 查看Ready状态
# - Containers.State: 查看容器状态
# - Events: 查看探针失败事件

# 示例输出：
Conditions:
  Type              Status
  Initialized       True
  Ready             False      # Readiness失败
  ContainersReady   False
  PodScheduled      True

Events:
  Warning  Unhealthy  Readiness probe failed: HTTP probe failed with statuscode: 503
  Warning  Unhealthy  Liveness probe failed: Get http://10.244.1.10:8080/health: dial tcp 10.244.1.10:8080: connect: connection refused
```

**查看探针指标（Prometheus）**：

```yaml
# Readiness探针失败
kube_pod_status_ready{pod="myapp"}

# Liveness探针导致的重启
rate(kube_pod_container_status_restarts_total[5m])

# 容器状态
kube_pod_container_status_ready
```

**临时禁用探针（调试用）**：

```bash
# 编辑Deployment，注释掉探针
kubectl edit deployment myapp

# 或者使用patch
kubectl patch deployment myapp --type=json -p='[
  {"op": "remove", "path": "/spec/template/spec/containers/0/livenessProbe"},
  {"op": "remove", "path": "/spec/template/spec/containers/0/readinessProbe"}
]'
```

---

## 常见问题

### 1. 为什么Liveness探针不应该检查依赖服务？

**答案**：

**原因**：
1. **避免级联失败**：如果依赖服务（如数据库）故障，会导致所有Pod被重启，重启后问题依然存在，造成无意义的重启循环
2. **扩大故障影响**：一个服务的问题会传播到所有依赖它的服务
3. **无法解决问题**：重启容器无法修复外部依赖的问题

**正确做法**：
```yaml
# Liveness：只检查应用本身
livenessProbe:
  exec:
    command:
    - pgrep
    - -f
    - myapp
  # 或简单的HTTP检查
  httpGet:
    path: /livez
    port: 8080

# Readiness：可以检查依赖
readinessProbe:
  httpGet:
    path: /readyz    # 检查DB、Redis等依赖
    port: 8080
```

**示例场景**：
```
数据库故障 → 如果Liveness检查DB：
1. Liveness失败 → 所有Pod重启
2. Pod重启后DB仍故障 → 继续失败
3. 进入CrashLoopBackOff → 服务完全不可用

正确做法（只Readiness检查DB）：
1. Readiness失败 → Pod从Service移除
2. 容器继续运行，定期重试
3. DB恢复后 → Readiness成功 → 自动恢复服务
```

### 2. Startup Probe的作用是什么？什么时候需要使用？

**答案**：

**作用**：
- 专门用于检测容器是否已启动完成
- 在Startup成功之前，Liveness和Readiness不会执行
- 避免慢启动应用被Liveness过早杀死

**适用场景**：
1. **Java应用**：JVM启动、类加载需要时间
2. **大型应用**：数据初始化、缓存预热
3. **数据库**：启动、恢复、索引重建
4. **机器学习模型**：模型加载需要时间

**配置示例**：
```yaml
# 慢启动应用（启动需要5分钟）
startupProbe:
  httpGet:
    path: /startup
  periodSeconds: 10
  failureThreshold: 30      # 10s × 30 = 300s = 5分钟
  # 在这期间Liveness不会检测

livenessProbe:
  httpGet:
    path: /health
  periodSeconds: 10
  failureThreshold: 3       # Startup成功后才生效
```

**优势**：
- 不需要设置很大的initialDelaySeconds
- 启动后立即开始正常的健康检查
- 更精确地控制启动检测逻辑

### 3. 如何处理滚动更新时的流量无缝切换？

**答案**：

**问题场景**：
滚动更新时，旧Pod被删除前如果还在处理请求，会导致连接中断。

**解决方案：使用preStop + Readiness**

```yaml
apiVersion: apps/v1
kind: Deployment
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0    # 确保总是有Pod可用
  template:
    spec:
      containers:
      - name: myapp
        lifecycle:
          preStop:
            exec:
              command:
              - /bin/sh
              - -c
              - sleep 15   # 等待15秒
        
        readinessProbe:
          httpGet:
            path: /ready
          periodSeconds: 5
        
        terminationGracePeriodSeconds: 30
```

**完整流程**：
```
1. 新Pod创建 → Readiness检测 → 成功后加入Endpoints
2. kubectl delete pod → Pod进入Terminating状态
3. Pod的Readiness立即失败 → 从Endpoints移除（停止接收新流量）
4. 执行preStop钩子（sleep 15秒）→ 等待现有请求完成
5. 发送SIGTERM信号
6. 等待terminationGracePeriodSeconds
7. 如果仍未退出，发送SIGKILL强制终止
```

**应用端配置**：
```go
// 优雅关闭
func gracefulShutdown() {
    // 设置为NotReady（可选，K8s会自动处理）
    isReady = false
    
    // 等待现有请求完成
    time.Sleep(10 * time.Second)
    
    // 关闭服务器
    server.Shutdown(context.Background())
}

// 监听信号
signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)
go func() {
    <-sigChan
    gracefulShutdown()
}()
```

### 4. 探针失败率很高，如何排查和优化？

**答案**：

**排查步骤**：

```bash
# 1. 查看失败原因
kubectl describe pod <pod-name> | grep -A 10 "Events"

# 2. 查看探针配置
kubectl get pod <pod-name> -o yaml | grep -A 20 "Probe"

# 3. 手动测试探针
kubectl exec <pod-name> -- curl -f http://localhost:8080/health

# 4. 查看应用日志
kubectl logs <pod-name> | grep -i "health\|ready"

# 5. 检查资源使用
kubectl top pod <pod-name>
```

**常见原因和解决方案**：

| 原因             | 解决方案                                  |
| ---------------- | ----------------------------------------- |
| **超时时间太短** | 增大timeoutSeconds（建议5-10秒）          |
| **检查逻辑太重** | 简化检查逻辑，避免复杂查询                |
| **资源不足**     | 增加CPU/内存limits                        |
| **网络延迟**     | 增大timeoutSeconds和failureThreshold      |
| **应用负载高**   | 优化应用性能或扩容                        |
| **探测频率太高** | 增大periodSeconds（10-15秒）              |
| **启动时间长**   | 使用startupProbe或增大initialDelaySeconds |

**优化配置示例**：

```yaml
# 优化前（探针失败率高）
livenessProbe:
  httpGet:
    path: /health
  initialDelaySeconds: 10   # 太短
  periodSeconds: 5          # 太频繁
  timeoutSeconds: 1         # 太短
  failureThreshold: 1       # 太严格
```

### 5. 什么是探针的失败阈值（failureThreshold）和成功阈值（successThreshold）？

**答案**：

- **失败阈值（failureThreshold）**：
  - 定义：连续探测失败多少次后，才认为探针真正失败
  - 默认为3次
  - 应用：防止临时网络波动或应用短暂响应超时导致误判

- **成功阈值（successThreshold）**：
  - 定义：连续探测成功多少次后，才认为探针真正成功
  - Liveness和Startup Probe默认为1次
  - Readiness Probe默认为1次
  - 应用：确保应用稳定恢复后才接收流量

**配置示例**：
```yaml
readinessProbe:
  httpGet:
    path: /ready
  failureThreshold: 5      # 连续5次失败才标记为NotReady
  successThreshold: 2      # 连续2次成功才标记为Ready
```