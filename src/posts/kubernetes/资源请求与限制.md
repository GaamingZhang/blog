---
date: 2026-01-30
author: Gaaming Zhang
isOriginal: false
article: true
category:
  - Kubernetes
tag:
  - Kubernetes
  - ClaudeCode
---

# 资源请求与限制

## 为什么要配置资源？

在Kubernetes集群中，多个应用共享同一组服务器。如果不做任何限制，就像合租房里没有规矩——一个室友可能把客厅堆满杂物，另一个可能24小时放音乐。最终，大家都不好过。

资源配置要解决两个核心问题：
1. **保证**：确保你的应用能获得足够的资源运行
2. **限制**：防止你的应用吃掉太多资源，影响其他应用

这就是requests（请求）和limits（限制）的作用。

## Requests和Limits是什么？

用租房来比喻：

- **Requests（请求）**：你需要的最小空间。就像说"我至少需要一个10平米的房间"。调度器会确保你分到的节点至少有这么多空闲资源。
- **Limits（限制）**：你能使用的最大空间。就像说"我最多只能用20平米"。即使房子很大，你也不能超过这个限制。

```yaml
resources:
  requests:
    memory: "256Mi"   # 最少需要256MB内存
    cpu: "250m"       # 最少需要0.25个CPU核心
  limits:
    memory: "512Mi"   # 最多使用512MB内存
    cpu: "500m"       # 最多使用0.5个CPU核心
```

## 资源单位怎么理解？

### CPU单位

CPU用"核心数"来衡量，支持小数：
- `1` = 1个CPU核心
- `500m` = 0.5个核心（m是millicores，千分之一核心）
- `100m` = 0.1个核心

在云环境中，1个CPU核心通常等于1个vCPU或1个超线程。

### 内存单位

内存用字节来衡量，常用单位：
- `Mi`（Mebibyte）= 1024 * 1024 字节，约等于1MB
- `Gi`（Gibibyte）= 1024 Mi，约等于1GB

```yaml
# 常见配置示例
resources:
  requests:
    memory: "128Mi"    # 128MB
    cpu: "100m"        # 0.1个核心
  limits:
    memory: "256Mi"
    cpu: "500m"
```

## CPU和内存的本质区别

这是理解资源管理的关键！

### CPU是"可压缩"资源

CPU就像网络带宽——不够用时可以排队等待，不会出大问题。

当你的容器CPU使用超过limits时，系统会"限流"（throttle）它：让它等待，把CPU时间让给别人。这会导致你的应用变慢，但不会被杀掉。

### 内存是"不可压缩"资源

内存就像实体仓库——满了就是满了，没法压缩。

当你的容器内存使用超过limits时，系统会直接杀掉它（OOM Killed）。这就是为什么内存配置更加关键。

## 超出限制会怎样？

### CPU超限：变慢但不死

```
容器请求1个CPU，限制2个CPU
实际使用想要3个CPU
↓
系统只给2个CPU，容器变慢但继续运行
```

### 内存超限：直接被杀

```
容器限制512MB内存
实际使用达到520MB
↓
触发OOM Killer，容器被终止
```

你可以通过以下方式确认容器是否被OOM杀掉：

```bash
kubectl describe pod <pod-name>
# 查看 Last State 是否显示 OOMKilled
```

## QoS：服务质量等级

Kubernetes会根据你的资源配置，自动给Pod分配一个"服务质量等级"。当节点资源紧张需要驱逐Pod时，低等级的先走。

### 三个等级

**Guaranteed（保障级）**—— 最高优先级，最后被驱逐

条件：所有容器都设置了requests和limits，且requests等于limits

```yaml
resources:
  requests:
    memory: "256Mi"
    cpu: "500m"
  limits:
    memory: "256Mi"    # 等于requests
    cpu: "500m"        # 等于requests
```

适用于：数据库、核心业务服务等不能中断的应用

**Burstable（突发级）**—— 中等优先级

条件：设置了资源配置，但requests不等于limits

```yaml
resources:
  requests:
    memory: "128Mi"
    cpu: "100m"
  limits:
    memory: "256Mi"    # 大于requests
    cpu: "500m"
```

适用于：大多数Web应用，平时用不了那么多，忙时需要更多资源

**BestEffort（尽力级）**—— 最低优先级，最先被驱逐

条件：没有设置任何资源配置

```yaml
containers:
  - name: app
    image: myapp:1.0
    # 没有resources字段
```

适用于：不重要的任务，用集群的"边角料"资源

### 驱逐顺序

当节点内存不足时：

```
BestEffort先走 → Burstable其次 → Guaranteed最后
```

在Burstable中，使用超出requests比例最多的先被驱逐。

## 如何确定合适的资源配置？

这是最实际的问题。配置太低，应用可能被杀；配置太高，浪费资源。

### 方法一：观察法

先不设限制，让应用跑一段时间，观察实际使用：

```bash
# 查看实时使用
kubectl top pod <pod-name>

# 示例输出
NAME         CPU(cores)   MEMORY(bytes)
my-app-xxx   45m          180Mi
```

然后根据观察结果设置：
- requests = 平均使用量 * 1.2（留20%余量）
- limits = 峰值使用量 * 1.5（留50%余量应对突发）

### 方法二：按应用类型估算

| 应用类型 | CPU建议 | 内存建议 |
|----------|---------|----------|
| 小型Web服务 | requests: 100m, limits: 500m | requests: 128Mi, limits: 256Mi |
| 中型Web应用 | requests: 250m, limits: 1000m | requests: 256Mi, limits: 512Mi |
| Java应用 | requests: 500m, limits: 2000m | requests: 1Gi, limits: 2Gi |
| 数据库 | requests=limits: 1000m | requests=limits: 2Gi |

```yaml
env:
  - name: JAVA_OPTS
    value: "-Xmx800m -Xms800m"    # JVM堆最大800MB
resources:
  limits:
    memory: "1Gi"                 # 容器限制1GB，留200MB给非堆
```

## 最佳实践

### 1. 一定要设置内存limits

内存不可压缩，不设限制可能拖垮整个节点。

### 2. CPU limits可以考虑不设

有争议的建议：有些团队选择不设CPU limits，让应用可以使用空闲CPU。这样做的好处是提高资源利用率，坏处是可能影响其他Pod。

### 3. 数据库等关键应用用Guaranteed

让requests等于limits，确保资源稳定：

```yaml
resources:
  requests:
    memory: "2Gi"
    cpu: "1000m"
  limits:
    memory: "2Gi"      # 等于requests
    cpu: "1000m"       # 等于requests
```

### 4. 用LimitRange设置默认值

如果担心有人忘记配置资源，可以为命名空间设置默认值：

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: default-limits
spec:
  limits:
    - type: Container
      default:            # 默认limits
        cpu: "500m"
        memory: "256Mi"
      defaultRequest:     # 默认requests
        cpu: "100m"
        memory: "128Mi"
```

## 常见问题

### Q1: Pod频繁被OOMKilled怎么办？

这说明内存限制太低了。排查步骤：

1. 查看实际内存使用：`kubectl top pod <pod-name>`
2. 适当提高limits
3. 如果内存持续增长不下降，可能是内存泄漏，需要检查代码

### Q2: requests设置太高会怎样？

两个问题：
- **调度失败**：如果没有节点满足requests，Pod会一直Pending
- **资源浪费**：预留了资源但实际没用那么多

建议：requests设置为实际使用的1.2-1.5倍就够了

### Q3: 不设置limits有什么影响？

- CPU：可以使用节点上所有空闲CPU，可能影响其他Pod
- 内存：可以使用任意多内存，可能触发节点级OOM，影响整个节点的所有Pod

**强烈建议**：至少要设置内存limits

### Q4: 怎么知道应用是否被CPU限流了？

CPU限流不会杀死容器，但会让应用变慢。如果你发现应用响应变慢，可以检查：

```bash
# 查看是否有CPU限流
# cgroup v2（Kubernetes 1.25+默认）
kubectl exec <pod-name> -- cat /sys/fs/cgroup/cpu.stat
# cgroup v1
kubectl exec <pod-name> -- cat /sys/fs/cgroup/cpu/cpu.stat
# 关注 nr_throttled 和 throttled_time
```

如果限流严重，考虑提高CPU limits。

### Q5: Guaranteed和Burstable怎么选？

- 关键业务、数据库、有状态服务 → Guaranteed（稳定第一）
- 普通Web应用、可以短暂中断的服务 → Burstable（效率优先）

## 小结

- **requests**是"保证给你的"，影响调度决策
- **limits**是"最多给你的"，防止资源滥用
- **CPU可压缩**（超限变慢），**内存不可压缩**（超限被杀）
- 通过requests和limits的配置方式决定**QoS等级**
- **内存limits必须设**，CPU limits可以根据情况决定
- 先观察实际使用，再调整配置

## 参考资源

- [Kubernetes 资源管理](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/)
- [资源请求与限制](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits)
- [QoS 服务质量](https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/)
