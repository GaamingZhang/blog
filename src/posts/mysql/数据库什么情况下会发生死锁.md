---
date: 2026-01-07
author: Gaaming Zhang
isOriginal: false
article: true
category:
  - 数据库
tag:
  - 数据库
---

# 数据库什么情况下会发生死锁

## 1. 死锁的基本概念

死锁（Deadlock）是指两个或多个事务在执行过程中，因争夺资源而造成的一种互相等待的现象。当多个事务同时访问相同的资源并以不同的顺序锁定这些资源时，就可能导致死锁的发生。

### 1.1 死锁的定义

在数据库系统中，死锁是指两个或多个事务各自持有对方所需的资源（如行锁、表锁等），并且都在等待对方释放这些资源，从而导致所有事务都无法继续执行的状态。

### 1.2 死锁的简单示例

以MySQL数据库为例，假设有两个事务A和B，它们同时操作两张表：`accounts`和`transactions`。

**事务A的操作顺序：**
1. 锁定`accounts`表中id=1的行
2. 等待锁定`transactions`表中id=1的行

**事务B的操作顺序：**
1. 锁定`transactions`表中id=1的行
2. 等待锁定`accounts`表中id=1的行

此时，事务A持有`accounts.id=1`的锁，等待`transactions.id=1`的锁；而事务B持有`transactions.id=1`的锁，等待`accounts.id=1`的锁。两个事务互相等待对方释放资源，形成了死锁。

### 1.3 死锁与普通锁等待的区别

死锁与普通的锁等待有明显区别：

1. **普通锁等待**：一个事务等待另一个事务释放锁资源，但不存在循环等待关系，最终会在超时后失败或成功获得锁
2. **死锁**：存在循环等待关系，若没有外部干预，所有参与死锁的事务将永远等待下去

### 1.4 死锁的影响

死锁的发生会对数据库系统产生以下影响：

1. **事务失败**：参与死锁的事务中至少有一个会被回滚，导致该事务的所有修改都被撤销
2. **性能下降**：死锁监测和处理过程会消耗数据库资源
3. **用户体验受影响**：用户可能需要重新执行操作
4. **系统稳定性风险**：频繁发生的死锁可能导致系统不稳定

## 2. 死锁的形成条件

死锁的发生必须同时满足以下四个条件，这四个条件被称为死锁的必要条件。只有当这四个条件同时成立时，死锁才会发生。

### 2.1 互斥条件

**互斥条件**是指资源不能被共享，一次只能被一个事务使用。在数据库中，锁就是一种互斥资源，同一时间只能有一个事务持有某一资源的写锁。

**数据库中的例子**：
- 行锁：同一时间只能有一个事务持有某一行的排他锁（X锁）
- 表锁：同一时间只能有一个事务持有某一表的排他锁（X锁）
- 元数据锁：同一时间只能有一个事务对表结构进行修改

### 2.2 请求与保持条件

**请求与保持条件**是指事务已经持有了至少一个资源（锁），但又提出了新的资源请求，而该资源已被其他事务占有。此时请求事务被阻塞，但对已获得的资源保持不放。

**数据库中的例子**：
事务A已经持有了表`users`中id=1的行锁，现在尝试获取表`orders`中id=1的行锁，而表`orders`中id=1的行锁已被事务B持有。事务A在等待事务B释放锁的同时，不会释放已持有的表`users`中id=1的行锁。

### 2.3 不剥夺条件

**不剥夺条件**是指事务已获得的资源，在未使用完之前，不能被强制剥夺。数据库系统通常不会主动剥夺事务已获得的锁，而是等待事务自行释放。

**数据库中的例子**：
事务A持有了表`products`中id=1的行锁，正在执行更新操作。此时事务B请求该锁，数据库系统不会强制事务A释放锁，而是让事务B等待。

### 2.4 循环等待条件

**循环等待条件**是指若干事务之间形成一种头尾相接的循环等待资源关系。例如，事务A等待事务B持有的资源，事务B等待事务C持有的资源，而事务C又等待事务A持有的资源。

**数据库中的例子**：
- 事务A持有资源X，等待资源Y
- 事务B持有资源Y，等待资源Z
- 事务C持有资源Z，等待资源X

这三个事务之间形成了A→B→C→A的循环等待关系，满足循环等待条件。

### 2.5 四个条件的关系

死锁的四个必要条件是相互关联的，只有当这四个条件同时成立时，死锁才会发生。因此，要避免死锁的发生，只需要破坏其中任何一个条件即可。

## 3. 数据库发生死锁的常见场景

在实际的数据库应用中，死锁的发生往往遵循一定的模式。了解这些常见场景可以帮助我们更好地预防和处理死锁问题。

### 3.1 多个事务以不同顺序访问多个资源

这是最常见的死锁场景。当两个或多个事务以相反的顺序访问相同的资源时，就容易发生死锁。

**示例：**

事务A：
```sql
-- 步骤1：更新账户A的余额
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- 步骤2：更新账户B的余额
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
```

事务B：
```sql
-- 步骤1：更新账户B的余额
UPDATE accounts SET balance = balance - 50 WHERE id = 2;
-- 步骤2：更新账户A的余额
UPDATE accounts SET balance = balance + 50 WHERE id = 1;
```

**死锁分析：**
- 事务A执行步骤1，获得账户A的排他锁
- 同时，事务B执行步骤1，获得账户B的排他锁
- 事务A执行步骤2，尝试获取账户B的排他锁，但此时账户B已被事务B锁定
- 事务B执行步骤2，尝试获取账户A的排他锁，但此时账户A已被事务A锁定
- 两个事务互相等待对方释放锁，形成死锁

### 3.2 事务中使用范围锁（Range Locks）

在使用`SELECT ... FOR UPDATE`或`SELECT ... LOCK IN SHARE MODE`等语句时，数据库可能会使用范围锁来锁定数据范围。当多个事务在重叠的范围内使用这些语句时，容易发生死锁。

**示例：**

事务A：
```sql
-- 步骤1：锁定ID大于5的账户
SELECT * FROM accounts WHERE id > 5 FOR UPDATE;
-- 步骤2：更新ID为3的账户
UPDATE accounts SET balance = balance - 200 WHERE id = 3;
```

事务B：
```sql
-- 步骤1：更新ID为3的账户
UPDATE accounts SET balance = balance + 200 WHERE id = 3;
-- 步骤2：锁定ID大于5的账户
SELECT * FROM accounts WHERE id > 5 FOR UPDATE;
```

**死锁分析：**
- 事务A执行步骤1，获得ID>5范围的排他锁
- 同时，事务B执行步骤1，获得ID=3的排他锁
- 事务A执行步骤2，尝试获取ID=3的排他锁，但被事务B锁定
- 事务B执行步骤2，尝试获取ID>5范围的排他锁，但被事务A锁定
- 形成死锁

### 3.3 长事务持有锁资源

长时间运行的事务会持有锁资源很长时间，增加了死锁发生的概率。

**示例：**

事务A：
```sql
-- 步骤1：开始事务
START TRANSACTION;
-- 步骤2：更新账户信息
UPDATE accounts SET name = 'New Name' WHERE id = 1;
-- 步骤3：执行耗时的业务逻辑（如API调用、文件处理等）
-- 步骤4：更新订单信息
UPDATE orders SET status = 'completed' WHERE account_id = 1;
-- 步骤5：提交事务
COMMIT;
```

事务B：
```sql
-- 步骤1：开始事务
START TRANSACTION;
-- 步骤2：更新订单信息
UPDATE orders SET amount = 100 WHERE account_id = 1;
-- 步骤3：更新账户信息
UPDATE accounts SET balance = balance + 100 WHERE id = 1;
-- 步骤4：提交事务
COMMIT;
```

**死锁分析：**
- 事务A执行步骤2，获得账户1的排他锁
- 事务B执行步骤2，获得订单表中account_id=1的排他锁
- 事务A完成耗时操作后执行步骤4，尝试获取订单表中account_id=1的排他锁，但被事务B锁定
- 事务B执行步骤3，尝试获取账户1的排他锁，但被事务A锁定
- 形成死锁

### 3.4 外键约束导致的死锁

外键约束会导致数据库自动添加额外的锁，这些锁可能会导致死锁的发生。

**示例：**

假设有两个表：`orders`和`order_items`，`order_items`表有一个指向`orders`表的外键`order_id`。

事务A：
```sql
-- 步骤1：删除订单
DELETE FROM orders WHERE id = 1;
-- 步骤2：删除订单项
DELETE FROM order_items WHERE order_id = 1;
```

事务B：
```sql
-- 步骤1：删除订单项
DELETE FROM order_items WHERE order_id = 1;
-- 步骤2：删除订单
DELETE FROM orders WHERE id = 1;
```

**死锁分析：**
- 事务A执行步骤1，为了验证外键约束，数据库会锁定order_items表中order_id=1的记录
- 事务B执行步骤1，获得order_items表中order_id=1的排他锁
- 事务A继续执行步骤2，但此时order_items表中order_id=1的记录已被事务B锁定
- 事务B执行步骤2，尝试删除订单，但此时数据库需要锁定order_items表中的相关记录来验证外键约束，而这些记录已被事务A锁定
- 形成死锁

### 3.5 批量操作导致的死锁

批量更新或删除操作可能会持有多个锁资源，增加了死锁发生的概率。

**示例：**

事务A：
```sql
-- 批量更新账户1和账户2的余额
UPDATE accounts SET balance = balance * 1.05 WHERE id IN (1, 2);
```

事务B：
```sql
-- 批量更新账户2和账户1的余额
UPDATE accounts SET balance = balance * 1.03 WHERE id IN (2, 1);
```

**死锁分析：**
- MySQL在执行`IN`条件的更新时，会按照索引顺序锁定记录
- 如果accounts表的id是主键，MySQL会按照id的升序锁定记录
- 事务A执行时，会先锁定id=1，再锁定id=2
- 事务B执行时，同样会先锁定id=1，再锁定id=2（尽管IN条件中的顺序是2,1）
- 因此，在这种情况下可能不会发生死锁

**注意：**
如果批量操作不是基于索引顺序，或者使用了不同的锁定策略，仍然可能发生死锁。例如，如果使用了表扫描而不是索引扫描，锁定顺序可能会变得不可预测。

## 4. 如何检测和分析死锁

数据库系统通常会自动检测死锁的发生，并采取措施解决死锁问题。作为数据库管理员或开发人员，我们需要了解如何检测和分析死锁，以便更好地预防和处理死锁问题。

### 4.1 数据库的死锁自动检测机制

大多数现代数据库系统都内置了死锁检测机制。以MySQL为例，InnoDB存储引擎使用**等待图（Wait-for Graph）**算法来检测死锁：

1. **构建等待图**：数据库会维护一个有向图，其中节点代表事务，边代表事务之间的等待关系（例如，事务A等待事务B持有的锁，就会在图中添加一条从A指向B的边）
2. **检测循环**：定期检查等待图中是否存在循环。如果存在循环，则说明发生了死锁
3. **处理死锁**：当检测到死锁时，数据库会选择一个代价最小的事务进行回滚，以打破死锁

**死锁处理策略**：
- MySQL通常会选择**占用资源最少的事务**进行回滚
- 或者选择**执行时间最短的事务**进行回滚
- 回滚的事务会收到"Deadlock found when trying to get lock; try restarting transaction"错误

### 4.2 查看死锁信息

在MySQL中，可以通过以下方法查看死锁信息：

#### 4.2.1 使用`SHOW ENGINE INNODB STATUS`命令

这是查看死锁信息最常用的方法：

```sql
SHOW ENGINE INNODB STATUS;
```

该命令会输出详细的InnoDB状态信息，其中包含最近一次死锁的详细信息。

**死锁日志示例**：

```
LATEST DETECTED DEADLOCK
------------------------
2026-01-07 10:30:45 0x7f8b9c034700

*** (1) TRANSACTION:
TRANSACTION 123456, ACTIVE 3 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s)
MySQL thread id 10, OS thread handle 140231979323136, query id 12345 localhost root updating
UPDATE accounts SET balance = balance - 100 WHERE id = 1

*** (1) HOLDS THE LOCK(S):
RECORD LOCKS space id 1024 page no 3 n bits 72 index PRIMARY of table `test`.`accounts` trx id 123456 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 4; hex 80000001; asc     ;; 1: len 6; hex 00000001e240; asc     @;; 2: len 7; hex b60000019d0110; asc        ;; 3: len 4; hex 800003e8; asc     ;;  

*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 1024 page no 4 n bits 72 index PRIMARY of table `test`.`accounts` trx id 123456 lock_mode X locks rec but not gap
Record lock, heap no 3 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 4; hex 80000002; asc     ;; 1: len 6; hex 00000001e241; asc     A;; 2: len 7; hex b60000019e0110; asc        ;; 3: len 4; hex 800001f4; asc     ;;  

*** (2) TRANSACTION:
TRANSACTION 123457, ACTIVE 2 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s)
MySQL thread id 11, OS thread handle 140231978278656, query id 12346 localhost root updating
UPDATE accounts SET balance = balance + 50 WHERE id = 2

*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 1024 page no 4 n bits 72 index PRIMARY of table `test`.`accounts` trx id 123457 lock_mode X locks rec but not gap
Record lock, heap no 3 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 4; hex 80000002; asc     ;; 1: len 6; hex 00000001e241; asc     A;; 2: len 7; hex b60000019e0110; asc        ;; 3: len 4; hex 800001f4; asc     ;;  

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 1024 page no 3 n bits 72 index PRIMARY of table `test`.`accounts` trx id 123457 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 4; hex 80000001; asc     ;; 1: len 6; hex 00000001e240; asc     @;; 2: len 7; hex b60000019d0110; asc        ;; 3: len 4; hex 800003e8; asc     ;;  

*** WE ROLL BACK TRANSACTION (2)
```

#### 4.2.2 启用死锁日志

可以通过配置MySQL来记录所有死锁信息：

```sql
-- 在MySQL配置文件中添加
innodb_print_all_deadlocks = ON
```

启用后，所有死锁信息都会被记录到MySQL的错误日志中，便于长期分析。

#### 4.2.3 使用Performance Schema

MySQL 5.7及以上版本可以使用Performance Schema来监控死锁：

```sql
-- 启用死锁监控
UPDATE performance_schema.setup_instruments SET ENABLED = 'YES' WHERE NAME LIKE '%wait/lock/%';
UPDATE performance_schema.setup_consumers SET ENABLED = 'YES' WHERE NAME LIKE '%events_waits%';

-- 查看死锁相关的事件
SELECT * FROM performance_schema.events_waits_history_long WHERE OBJECT_SCHEMA = 'your_database';
```

### 4.3 分析死锁日志

分析死锁日志是解决死锁问题的关键。以下是分析死锁日志的步骤：

#### 4.3.1 识别参与死锁的事务

死锁日志会列出所有参与死锁的事务（如上面示例中的TRANSACTION 123456和TRANSACTION 123457）。

#### 4.3.2 查看事务持有的锁

每个事务的"HOLDS THE LOCK(S)"部分会显示该事务已持有的锁信息，包括：
- 锁的类型（如行锁、表锁）
- 锁的模式（如X锁、S锁）
- 锁定的资源（如表名、索引名、记录位置）

#### 4.3.3 查看事务等待的锁

每个事务的"WAITING FOR THIS LOCK TO BE GRANTED"部分会显示该事务正在等待的锁信息。

#### 4.3.4 确定死锁的原因

通过分析事务持有的锁和等待的锁，可以确定死锁的形成原因：
- 是否是因为事务以不同的顺序访问资源？
- 是否是因为使用了范围锁？
- 是否是因为长事务持有锁资源？

#### 4.3.5 查看被回滚的事务

死锁日志的最后会显示哪个事务被回滚（如上面示例中的"WE ROLL BACK TRANSACTION (2)"）。

### 4.4 死锁分析工具

除了手动分析死锁日志外，还可以使用一些工具来帮助分析死锁：

1. **MySQL Workbench**：提供了图形化的死锁分析功能
2. **pt-deadlock-logger**：Percona Toolkit中的工具，可以监控和记录死锁信息
3. **MySQL Enterprise Monitor**：企业级监控工具，提供死锁检测和分析功能
4. **Zabbix、Prometheus等监控系统**：可以配置死锁告警和监控

### 4.5 死锁分析示例

让我们通过一个实际的死锁日志示例来分析死锁：

**死锁日志：**
```
*** (1) TRANSACTION:
TRANSACTION 12345, ACTIVE 10 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 5 lock struct(s), heap size 1136, 3 row lock(s), undo log entries 1
MySQL thread id 8, OS thread handle 140231977234176, query id 1234 localhost root insert
INSERT INTO order_items (order_id, product_id, quantity) VALUES (1, 1, 1)

*** (1) HOLDS THE LOCK(S):
RECORD LOCKS space id 1025 page no 4 n bits 72 index idx_order_id of table `test`.`order_items` trx id 12345 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 4; hex 80000001; asc     ;; 1: len 4; hex 80000002; asc     ;;  

*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 1026 page no 3 n bits 72 index PRIMARY of table `test`.`orders` trx id 12345 lock_mode S locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 4; hex 80000001; asc     ;; 1: len 6; hex 00000001e240; asc     @;; 2: len 7; hex b60000019d0110; asc        ;; 3: len 4; hex 800003e8; asc     ;;  

*** (2) TRANSACTION:
TRANSACTION 12346, ACTIVE 8 sec updating
mysql tables in use 1, locked 1
LOCK WAIT 4 lock struct(s), heap size 1136, 2 row lock(s)
MySQL thread id 9, OS thread handle 140231976189696, query id 1235 localhost root update
UPDATE orders SET status = 'cancelled' WHERE id = 1

*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 1026 page no 3 n bits 72 index PRIMARY of table `test`.`orders` trx id 12346 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 4; hex 80000001; asc     ;; 1: len 6; hex 00000001e240; asc     @;; 2: len 7; hex b60000019d0110; asc        ;; 3: len 4; hex 800003e8; asc     ;;  

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 1025 page no 4 n bits 72 index idx_order_id of table `test`.`order_items` trx id 12346 lock_mode X locks gap before rec insert intention waiting
Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 4; hex 80000001; asc     ;; 1: len 4; hex 80000002; asc     ;;  

*** WE ROLL BACK TRANSACTION (1)
```

**分析：**
1. **参与死锁的事务**：事务12345（插入订单项）和事务12346（更新订单状态）
2. **事务12345持有**：order_items表中order_id=1的行锁（X锁）
3. **事务12345等待**：orders表中id=1的行锁（S锁，用于外键约束验证）
4. **事务12346持有**：orders表中id=1的行锁（X锁）
5. **事务12346等待**：order_items表中order_id=1的间隙锁（插入意向锁）
6. **死锁原因**：外键约束导致的死锁。事务12345在插入订单项时需要验证外键约束，因此尝试获取orders表的共享锁；而事务12346已经持有orders表的排他锁，正在尝试获取order_items表的锁。
7. **被回滚的事务**：事务12345（插入操作）

## 5. 如何避免和解决死锁

了解了死锁的形成条件和常见场景后，我们可以采取一系列措施来避免和解决死锁问题。这些措施主要分为两类：**预防死锁**（避免死锁的发生）和**处理死锁**（当死锁发生时如何解决）。

### 5.1 破坏死锁的必要条件

根据死锁的四个必要条件，我们可以通过破坏其中任何一个条件来避免死锁的发生：

#### 5.1.1 破坏互斥条件

互斥条件是指资源不能被共享，一次只能被一个事务使用。在数据库中，锁就是一种互斥资源，因此破坏互斥条件通常是不可行的，因为这会影响数据的一致性。

#### 5.1.2 破坏请求与保持条件

**请求与保持条件**是指事务已经持有了至少一个资源，但又提出了新的资源请求。可以通过以下方式破坏这个条件：

1. **一次性请求所有资源**：事务在开始执行前，一次性请求所需的所有资源。如果无法获取所有资源，则不执行任何操作，直到所有资源都可用。

2. **资源预分配策略**：在系统设计阶段，为每个事务预分配所需的资源。

**示例**：
```sql
-- 不推荐的方式（可能导致死锁）
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- 推荐的方式（一次性请求所有资源）
START TRANSACTION;
-- 先锁定所有需要的资源
SELECT * FROM accounts WHERE id IN (1, 2) FOR UPDATE;
-- 然后执行更新操作
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

#### 5.1.3 破坏不剥夺条件

**不剥夺条件**是指事务已获得的资源，在未使用完之前，不能被强制剥夺。可以通过以下方式破坏这个条件：

1. **超时机制**：为事务设置超时时间，如果事务等待锁的时间超过阈值，则自动释放已持有的锁。

2. **优先级机制**：为事务设置优先级，当高优先级事务等待低优先级事务持有的锁时，低优先级事务自动释放锁。

**示例**：
```sql
-- 设置事务超时时间为5秒
SET innodb_lock_wait_timeout = 5;
```

#### 5.1.4 破坏循环等待条件

**循环等待条件**是指若干事务之间形成一种头尾相接的循环等待资源关系。可以通过以下方式破坏这个条件：

1. **统一资源访问顺序**：所有事务按照相同的顺序访问资源。

2. **资源编号机制**：为每个资源分配一个唯一的编号，事务必须按照编号的升序或降序访问资源。

**示例**：
```sql
-- 事务A（按照id升序访问）
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- 事务B（同样按照id升序访问）
START TRANSACTION;
UPDATE accounts SET balance = balance - 50 WHERE id = 1;
UPDATE accounts SET balance = balance + 50 WHERE id = 2;
COMMIT;
```

### 5.2 预防死锁的策略

除了破坏死锁的必要条件外，还可以采取以下策略来预防死锁的发生：

#### 5.2.1 统一资源访问顺序

这是预防死锁最有效的策略之一。确保所有事务按照相同的顺序访问资源，可以避免循环等待条件的发生。

**实施建议**：
- 为所有表和索引分配一个逻辑顺序
- 事务必须按照这个顺序访问资源
- 对于多表操作，按照表名的字典顺序访问
- 对于行级操作，按照主键或唯一索引的升序访问

#### 5.2.2 减少事务持有锁的时间

事务持有锁的时间越长，发生死锁的概率就越高。可以通过以下方式减少事务持有锁的时间：

1. **缩短事务长度**：将长事务拆分为多个短事务。

2. **避免在事务中执行非数据库操作**：不要在事务中执行API调用、文件操作等耗时的非数据库操作。

3. **及时提交或回滚事务**：在完成数据库操作后，立即提交或回滚事务。

**示例**：
```sql
-- 不推荐的方式（长事务）
START TRANSACTION;
UPDATE accounts SET name = 'New Name' WHERE id = 1;
-- 执行耗时的API调用
CALL external_api();
UPDATE orders SET status = 'completed' WHERE account_id = 1;
COMMIT;

-- 推荐的方式（短事务）
-- 事务1：更新账户信息
START TRANSACTION;
UPDATE accounts SET name = 'New Name' WHERE id = 1;
COMMIT;

-- 执行耗时的API调用
CALL external_api();

-- 事务2：更新订单信息
START TRANSACTION;
UPDATE orders SET status = 'completed' WHERE account_id = 1;
COMMIT;
```

#### 5.2.3 合理使用锁粒度

锁粒度是指锁定资源的大小（如行锁、页锁、表锁）。锁粒度越细，并发度越高，但发生死锁的概率也越高；锁粒度越粗，并发度越低，但发生死锁的概率也越低。

**实施建议**：
- 优先使用行锁，提高并发度
- 对于频繁访问的表，可以考虑使用表锁，减少死锁的发生
- 合理设计索引，确保锁的范围尽可能小

#### 5.2.4 避免使用范围锁

范围锁（如`SELECT ... FOR UPDATE`）会锁定一个范围内的所有资源，增加了死锁的发生概率。可以通过以下方式避免使用范围锁：

1. **使用精确的条件**：尽量使用精确的条件（如主键或唯一索引）来访问资源，避免使用范围条件。

2. **使用行锁代替范围锁**：如果必须使用锁，可以考虑使用行锁代替范围锁。

**示例**：
```sql
-- 不推荐的方式（使用范围锁）
SELECT * FROM accounts WHERE balance > 1000 FOR UPDATE;

-- 推荐的方式（使用精确条件）
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
```

#### 5.2.5 适当设置事务隔离级别

不同的事务隔离级别会影响锁的行为。可以根据业务需求，选择适当的事务隔离级别：

1. **READ UNCOMMITTED**：最低的隔离级别，不会加锁，并发度最高，但可能导致脏读。

2. **READ COMMITTED**：读已提交，只锁定当前读取的行，并发度较高。

3. **REPEATABLE READ**：可重复读，锁定读取的行和范围，并发度较低。

4. **SERIALIZABLE**：最高的隔离级别，锁定整个表，并发度最低，但可以避免死锁。

**实施建议**：
- 对于并发度要求较高的系统，推荐使用`READ COMMITTED`隔离级别
- 对于数据一致性要求较高的系统，推荐使用`REPEATABLE READ`或`SERIALIZABLE`隔离级别

**示例**：
```sql
-- 设置事务隔离级别为READ COMMITTED
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

### 5.3 处理死锁的策略

即使采取了预防措施，死锁仍然可能发生。当死锁发生时，可以采取以下策略来处理：

#### 5.3.1 事务重试机制

这是处理死锁最常用的策略。当事务遇到死锁错误时，自动重试该事务。

**实施建议**：
- 设置最大重试次数，避免无限重试
- 每次重试前，增加随机的延迟时间，避免多个事务同时重试导致再次死锁

**示例代码（伪代码）**：
```python
def execute_with_retry(sql, max_retries=3):
    for i in range(max_retries):
        try:
            # 执行SQL语句
            cursor.execute(sql)
            connection.commit()
            return True
        except Exception as e:
            if "Deadlock found" in str(e):
                # 发生死锁，重试
                connection.rollback()
                time.sleep(random.uniform(0.1, 1.0))
                continue
            else:
                # 其他错误，不重试
                connection.rollback()
                raise e
    return False
```

#### 5.3.2 死锁超时设置

为事务设置锁等待超时时间，当事务等待锁的时间超过阈值时，自动回滚。

**示例**：
```sql
-- 设置锁等待超时时间为10秒
SET innodb_lock_wait_timeout = 10;
```

#### 5.3.3 手动干预

当死锁频繁发生且自动处理无效时，可以采取手动干预的方式：

1. **查看死锁信息**：使用`SHOW ENGINE INNODB STATUS`命令查看死锁信息

2. **终止占用资源的事务**：使用`KILL`命令终止导致死锁的事务

**示例**：
```sql
-- 查看当前运行的事务
SHOW PROCESSLIST;

-- 终止指定的事务
KILL 12345;
```

### 5.4 最佳实践

1. **设计合理的数据库架构**：合理设计表结构、索引和外键约束，减少锁的竞争。

2. **使用乐观锁**：对于并发度要求较高的场景，可以考虑使用乐观锁（如版本号机制）代替悲观锁。

**示例**：
```sql
-- 乐观锁示例
UPDATE accounts SET balance = balance - 100, version = version + 1 WHERE id = 1 AND version = 1;
```

3. **监控死锁**：定期监控数据库的死锁情况，及时发现和解决问题。

4. **测试并发场景**：在开发和测试阶段，模拟高并发场景，验证系统是否会发生死锁。

5. **培训开发人员**：对开发人员进行培训，提高他们对死锁的认识和预防意识。

## 6. 常见问题

### 6.1 死锁一定会导致事务回滚吗？

是的，当数据库检测到死锁时，会选择一个代价最小的事务进行回滚，以打破死锁。回滚的事务会收到"Deadlock found when trying to get lock; try restarting transaction"错误。

### 6.2 如何确定哪个事务会被回滚？

数据库通常会选择**代价最小的事务**进行回滚。代价的计算通常考虑以下因素：
- 事务占用的资源数量
- 事务执行的时间长度
- 事务已执行的操作数量
- 事务的优先级

在MySQL中，默认选择**执行时间最短的事务**进行回滚。

### 6.3 死锁和锁等待有什么区别？

- **死锁**：存在循环等待关系，若没有外部干预，所有参与死锁的事务将永远等待下去。
- **锁等待**：一个事务等待另一个事务释放锁资源，但不存在循环等待关系，最终会在超时后失败或成功获得锁。

### 6.4 如何避免在批量操作中发生死锁？

1. **按照统一顺序处理数据**：在批量操作中，按照相同的顺序处理数据（如按照主键升序）。

2. **使用较小的批次**：将大批次拆分为小批次，减少事务持有锁的时间。

3. **使用乐观锁**：对于并发度要求较高的场景，可以考虑使用乐观锁代替悲观锁。

**示例**：
```sql
-- 不推荐的方式（可能导致死锁）
START TRANSACTION;
UPDATE accounts SET balance = balance * 1.05 WHERE id IN (1, 2, 3, ..., 1000);
COMMIT;

-- 推荐的方式（使用小批次）
for i in range(0, 1000, 100):
    START TRANSACTION;
    UPDATE accounts SET balance = balance * 1.05 WHERE id BETWEEN i+1 AND i+100;
    COMMIT;
```

### 6.5 死锁会影响数据库性能吗？

是的，死锁会对数据库性能产生以下影响：

1. **资源消耗**：死锁检测和处理过程会消耗数据库资源。

2. **事务回滚**：死锁导致的事务回滚会浪费已执行的操作。

3. **用户体验受影响**：用户可能需要重新执行操作。

4. **系统稳定性风险**：频繁发生的死锁可能导致系统不稳定。

## 7. 总结

死锁是数据库系统中常见的并发问题，它的发生必须同时满足四个必要条件：互斥条件、请求与保持条件、不剥夺条件和循环等待条件。了解死锁的形成条件和常见场景，是预防和处理死锁的基础。

为了避免死锁的发生，我们可以采取一系列措施，如统一资源访问顺序、减少事务持有锁的时间、合理使用锁粒度、避免使用范围锁、适当设置事务隔离级别等。当死锁发生时，可以通过事务重试机制、死锁超时设置、手动干预等方式来处理。

作为数据库管理员或开发人员，我们需要加强对死锁的认识和预防意识，设计合理的数据库架构，监控死锁情况，及时发现和解决问题，以确保数据库系统的稳定性和性能。