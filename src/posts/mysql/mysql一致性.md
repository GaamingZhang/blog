---
date: 2026-01-15
author: Gaaming Zhang
isOriginal: true
article: true
category:
  - 数据库
tag:
  - 数据库
---

# MySQL 的一致性：从约束到MVCC的完整机制

## 什么是一致性？

一致性（Consistency）是 ACID 中最容易被误解的特性。很多人认为它指的是"数据不会丢失"或"读到的数据是最新的"，但这些实际上是持久性和隔离性的范畴。

**一致性的真正含义**：数据库从一个**有效状态**转换到另一个**有效状态**。

什么是"有效状态"？就是数据满足你定义的所有规则：
- 业务规则：账户余额不能为负数
- 数据约束：主键唯一、外键引用有效
- 数据关联：订单总额等于明细之和

举个例子：转账操作
```
转账前（有效状态）：A账户1000元，B账户500元，总额1500元
转账中（可能无效）：A账户扣了100元，B账户还没加
转账后（有效状态）：A账户900元，B账户600元，总额1500元
```

一致性确保你永远不会看到"转账中"这种无效状态——要么转账成功（新的有效状态），要么失败回滚（恢复到旧的有效状态）。

## 一致性的三个层次

### 1. 数据库层：约束一致性

数据库通过各种约束机制来保证数据的结构有效性。

**主键约束的工作原理**

主键约束不只是"值不能重复"这么简单。在 InnoDB 中：
- 主键值用于构建 B+ 树索引（聚簇索引）
- 插入时，MySQL 会在 B+ 树中查找该键是否存在
- 如果存在，操作被拒绝；如果不存在，找到插入位置
- 这个检查在**事务提交前**完成，失败则整个事务回滚

**外键约束的级联机制**

外键约束维护表之间的引用完整性。工作流程：
1. 插入子表记录时，MySQL 会在父表中查找对应的主键
2. 如果父表记录不存在，插入失败
3. 删除父表记录时，检查子表是否有引用
4. 根据配置（RESTRICT/CASCADE/SET NULL）决定行为

**为什么外键的性能影响大？**
- 每次操作都需要额外的索引查找
- 涉及多个表，可能产生锁等待
- 级联操作可能触发连锁反应

这就是为什么很多互联网公司不使用外键，而是在应用层保证一致性——牺牲了数据库级别的强制保证，换取了更高的性能和灵活性。

### 2. 事务层：操作一致性

**原子性保证一致性的基础**

考虑转账的两个步骤：
```
UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- 扣款
UPDATE accounts SET balance = balance + 100 WHERE id = 2;  -- 入账
```

如果只执行了第一条语句，数据就不一致了（钱凭空消失）。原子性确保：
- 要么两条都执行（新的一致状态）
- 要么都不执行（保持旧的一致状态）

**原子性的实现：Undo Log**

MySQL 通过 Undo Log 来实现原子性：
```
执行扣款操作前：
    记录 Undo Log: "账户1的余额原本是1000"

执行扣款：
    账户1余额改为900

如果需要回滚：
    读取 Undo Log，将账户1余额恢复为1000
```

关键点：
- Undo Log 在修改数据**之前**记录
- 回滚时按**相反顺序**应用 Undo Log
- Undo Log 本身的写入也是原子的（通过 Redo Log 保证）

### 3. 读取层：一致性读

**MVCC：多版本并发控制**

一致性不仅是写入的问题，还涉及读取。在 Read Committed 和 Repeatable Read 隔离级别下，MySQL 使用 MVCC 提供一致性读（Consistent Read）。

核心思想：**每个事务读取的是数据的某个一致性快照，而不是实时的最新版本**。

**MVCC 的工作机制**

每行数据实际上有多个版本，通过隐藏列标记：

```
实际存储的数据行：
┌─────────┬────────┬─────────────┬──────────────┬──────────┐
│ user_id │ balance│   DB_TRX_ID │  DB_ROLL_PTR │ 其他列... │
│  (主键)  │ (数据) │ (创建版本号) │ (回滚指针)   │           │
└─────────┴────────┴─────────────┴──────────────┴──────────┘

DB_TRX_ID: 创建/修改该版本的事务ID
DB_ROLL_PTR: 指向Undo Log中的旧版本
```

**一致性读的实现**

事务开始时（准确说是第一次读取时），MySQL 会创建一个 Read View（读视图）：
```
Read View 包含：
- m_ids: 当前活跃的事务ID列表
- min_trx_id: 最小的活跃事务ID
- max_trx_id: 下一个将被分配的事务ID
- creator_trx_id: 创建该Read View的事务ID
```

读取数据时的可见性判断算法：
```
对于每一行数据的DB_TRX_ID，判断：

1. 如果 DB_TRX_ID < min_trx_id
   → 这个版本在所有活跃事务开始前就提交了，可见

2. 如果 DB_TRX_ID >= max_trx_id
   → 这个版本是在Read View创建后才生成的，不可见

3. 如果 min_trx_id <= DB_TRX_ID < max_trx_id
   a) 如果 DB_TRX_ID 在 m_ids 中（事务还活跃）
      → 不可见，沿着DB_ROLL_PTR找旧版本
   b) 如果 DB_TRX_ID 不在 m_ids 中（事务已提交）
      → 可见

4. 如果 DB_TRX_ID == creator_trx_id
   → 是自己修改的，可见
```

**示例：可重复读是如何实现的**

```
时刻    事务A (ID=10)              事务B (ID=11)
T1     BEGIN;
T2     SELECT balance FROM accounts WHERE id=1;
       → 读到 balance=1000
       → 创建Read View: m_ids=[10,11], min=10, max=12
T3                                UPDATE accounts SET balance=800 WHERE id=1;
                                  COMMIT;
T4     SELECT balance FROM accounts WHERE id=1;
       → 仍然读到 balance=1000

为什么？因为：
- 数据行的DB_TRX_ID现在是11
- Read View中的m_ids包含11
- 可见性判断：11在m_ids中 → 不可见
- 沿着ROLL_PTR找到旧版本（DB_TRX_ID < 10）→ 读到1000
```

这就是为什么 Repeatable Read 能实现可重复读：**Read View 在事务开始时固定，后续所有读操作都用这个快照**。

**Read Committed 的区别**

Read Committed 每次读取都会创建新的 Read View，所以能读到其他事务已提交的修改。

## 业务层的一致性挑战

### 跨表操作的一致性

考虑创建订单的场景：
```
1. 插入订单记录（orders表）
2. 插入订单明细（order_items表）
3. 扣减库存（products表）
4. 增加用户积分（users表）
```

即使每个操作本身都保持一致，整体操作也可能出问题：

**问题1：部分成功**
- 订单创建了，但库存扣减失败（库存不足）
- 结果：数据不一致

**解决方案**：事务的原子性
```sql
BEGIN;
  INSERT INTO orders ...;
  INSERT INTO order_items ...;
  UPDATE products SET stock = stock - 1 WHERE id = ? AND stock > 0;
  IF affected_rows = 0 THEN ROLLBACK;
  UPDATE users SET points = points + 10 WHERE id = ?;
COMMIT;
```

**问题2：并发冲突**
- 两个事务同时读取库存为1
- 都认为可以扣减，都下单成功
- 结果：超卖

**解决方案1**：悲观锁（SELECT FOR UPDATE）
```sql
BEGIN;
SELECT stock FROM products WHERE id = 1 FOR UPDATE;
-- 这会锁定该行，其他事务必须等待
IF stock > 0 THEN
  UPDATE products SET stock = stock - 1 WHERE id = 1;
  -- 创建订单...
END IF;
COMMIT;
```

FOR UPDATE 的工作原理：
- 在读取时就加 X 锁（排他锁）
- 其他事务的 SELECT FOR UPDATE 会阻塞
- 其他事务的 UPDATE/DELETE 会阻塞
- 普通 SELECT（一致性读）不阻塞

**解决方案2**：乐观锁（版本号）
```sql
-- 读取时记录版本号
SELECT stock, version FROM products WHERE id = 1;
-- stock=10, version=5

-- 更新时检查版本号
UPDATE products
SET stock = stock - 1, version = version + 1
WHERE id = 1 AND version = 5;

-- 如果 affected_rows = 0，说明被其他事务修改了，重试
```

乐观锁适合冲突较少的场景，悲观锁适合冲突频繁的场景。

### 分布式场景的一致性

当数据分散在多个数据库时，单机事务无法保证一致性。

**问题：跨库转账**
```
用户A的账户在DB1，余额1000
用户B的账户在DB2，余额500
转账100元：
  DB1: UPDATE accounts SET balance = 900 WHERE id = A;
  DB2: UPDATE accounts SET balance = 600 WHERE id = B;
```

如果 DB1 成功但 DB2 失败，无法自动回滚（不在同一个事务中）。

**解决方案1：两阶段提交（2PC）**

```
协调者的流程：

阶段1（准备）：
  发送给 DB1: "准备提交 UPDATE accounts SET balance=900"
  发送给 DB2: "准备提交 UPDATE accounts SET balance=600"

  DB1 执行操作，加锁，写Redo Log，返回"准备好了"
  DB2 执行操作，加锁，写Redo Log，返回"准备好了"

阶段2（提交）：
  如果都准备好：
    发送给 DB1: "提交"
    发送给 DB2: "提交"
  如果任何一个失败：
    发送给 DB1: "回滚"
    发送给 DB2: "回滚"
```

2PC 的问题：
- 同步阻塞：准备阶段会锁定资源，直到收到提交/回滚命令
- 单点故障：如果协调者崩溃，参与者会一直阻塞
- 数据不一致：协调者发送提交命令时崩溃，部分参与者提交，部分未收到

**解决方案2：最终一致性（BASE）**

放宽对一致性的要求，允许短暂的不一致，最终达到一致。

典型模式：本地消息表 + 定时补偿
```
DB1 事务：
  1. UPDATE accounts SET balance = 900 WHERE id = A;
  2. INSERT INTO outbox_events (type='TRANSFER', data='...', status='PENDING');
  COMMIT;

后台任务：
  轮询 outbox_events 表，发送消息到DB2
  DB2 收到消息，更新账户B
  更新 outbox_events SET status='SUCCESS'

补偿机制：
  定期检查 status='PENDING' 且超时的记录，重试或回滚
```

这种方案牺牲了强一致性，但获得了更高的可用性和性能。

## 一致性与其他 ACID 特性的关系

### 一致性依赖于原子性

如果事务不具备原子性，一致性就无从谈起：
```
转账操作包含两步：
  步骤1：账户A - 100
  步骤2：账户B + 100

没有原子性：
  步骤1执行了，步骤2失败 → 总金额减少，不一致

有原子性：
  步骤1和步骤2要么都成功，要么都不执行 → 保持一致
```

### 一致性依赖于隔离性

并发事务如果相互干扰，会破坏一致性：
```
事务A和B同时执行转账：
  A: 账户X - 100，账户Y + 100
  B: 账户Y - 50，账户Z + 50

没有隔离性（交错执行）：
  A读到Y=500
  B读到Y=500
  A写入Y=600 (500+100)
  B写入Y=450 (500-50)  ← 覆盖了A的更新

结果：账户Y丢失了A的转账，总金额不守恒，不一致
```

隔离性通过锁和 MVCC 防止这种干扰。

### 一致性依赖于持久性

如果已提交的事务可能丢失，一致性也无法保证：
```
事务提交后，用户看到转账成功（1000 → 900）
数据库崩溃，重启后余额变回1000
这违反了"已提交状态永久保存"，破坏了一致性
```

持久性通过 Redo Log 和刷盘策略来保证。

**总结关系**：
- **原子性**：确保状态转换是完整的（要么全做，要么全不做）
- **隔离性**：确保并发时不会产生中间状态的干扰
- **持久性**：确保一致的状态不会丢失
- **一致性**：是目标，原子性、隔离性、持久性是实现手段

## 实践中的权衡

### 性能 vs 强一致性

强一致性约束（如外键、触发器）会影响性能：
- 每次操作都要检查约束
- 可能产生额外的锁等待
- 限制了分库分表的灵活性

很多互联网公司的选择：
- 数据库层：去除外键，只用主键和索引
- 应用层：通过代码逻辑保证数据完整性
- 补偿机制：定时任务检查并修复不一致数据

### 可用性 vs 强一致性（CAP定理）

分布式系统的 CAP 定理指出，无法同时满足：
- **C**onsistency（一致性）：所有节点看到相同数据
- **A**vailability（可用性）：每个请求都能得到响应
- **P**artition tolerance（分区容错）：网络分区时系统继续工作

实践中的选择：
- 金融系统：选择 CP（保证一致性，牺牲可用性）
- 社交网络：选择 AP（保证可用性，接受最终一致性）
- 电商系统：核心交易 CP，其他功能 AP

## 小结

一致性是 ACID 中最抽象的特性，它的实现依赖于：

**数据库约束层**：
- 主键、外键、唯一约束保证结构一致性
- CHECK 约束保证数据范围有效性

**事务机制层**：
- 原子性确保操作完整性
- Undo Log 实现回滚

**并发控制层**：
- 隔离性防止并发干扰
- MVCC 提供一致性快照读

**应用业务层**：
- 悲观锁/乐观锁处理并发冲突
- 分布式事务保证跨库一致性
- 最终一致性放宽要求提升性能

理解一致性的本质——从一个有效状态到另一个有效状态——是设计可靠数据库应用的基础。在实际系统中，需要根据业务场景在强一致性、性能、可用性之间做出合理的权衡。
