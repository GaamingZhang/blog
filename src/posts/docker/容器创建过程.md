---
date: 2026-01-26
author: Gaaming Zhang
isOriginal: false
article: true
category:
  - Docker
tag:
  - Docker
  - ClaudeCode
---

# 容器创建的底层原理

## 从一条命令说起

当你执行 `docker run nginx` 时，短短几秒钟内就启动了一个完整的 Web 服务器。这背后到底发生了什么？

这条简单的命令背后，涉及了**镜像拉取、文件系统构建、网络配置、进程隔离、资源限制**等一系列复杂操作。理解这个过程，能让你：
- 掌握容器技术的核心原理
- 排查容器启动和运行问题
- 优化容器的性能和安全性

---

## 容器创建的完整流程

从宏观角度看，容器创建可以分为五个阶段：

```
1. 命令解析与验证
   ↓
2. 镜像准备
   ↓
3. 容器配置准备
   ↓
4. 运行时启动
   ↓
5. 容器进程运行
```

让我们逐个深入理解每个阶段。

---

## 第一阶段：命令解析与验证

### 客户端-服务器架构

Docker 采用 C/S 架构，用户的命令不是直接执行的：

```
docker run nginx
     ↓
Docker CLI（客户端）
     ↓ REST API / Unix Socket
Docker Daemon（服务端）
```

**为什么要这样设计？**

1. **权限分离**：Docker Daemon 以 root 权限运行，但用户不需要 root 权限
2. **远程管理**：可以通过 REST API 管理远程机器上的容器
3. **异步操作**：长时间运行的操作不会阻塞客户端

### 命令解析

Docker CLI 将 `docker run nginx` 解析成结构化的 API 请求：

```json
{
  "Image": "nginx:latest",
  "HostConfig": {
    "NetworkMode": "bridge",
    "RestartPolicy": {"Name": "no"}
  },
  "NetworkingConfig": {}
}
```

然后通过 HTTP POST 请求发送给 Docker Daemon。

---

## 第二阶段：镜像准备

### 检查本地镜像

Docker Daemon 首先检查本地是否已有 `nginx:latest` 镜像：

```
本地镜像存储 (/var/lib/docker/image/)
     ↓
镜像元数据数据库
     ↓
查询 nginx:latest 的镜像 ID
```

如果找到，直接使用。如果没有，进入拉取流程。

### 镜像拉取原理

这不是简单地下载一个文件，而是一个复杂的分层拉取过程：

**1. 解析镜像引用**

```
nginx:latest
  ↓
registry: docker.io
repository: library/nginx
tag: latest
```

**2. 连接镜像仓库**

```
Docker Daemon
     ↓ HTTPS
Docker Hub (registry-1.docker.io)
     ↓
请求镜像 manifest（清单）
```

**3. 获取镜像清单**

Manifest 描述了镜像的所有层：

```json
{
  "layers": [
    {"digest": "sha256:abc123...", "size": 50MB},
    {"digest": "sha256:def456...", "size": 30MB},
    {"digest": "sha256:ghi789...", "size": 20MB}
  ]
}
```

**4. 并行拉取层**

Docker 同时拉取多个层，而不是顺序下载：

```
Layer 1 ━━━━━━━━━━━━━━ 下载中
Layer 2 ━━━━━━━━ 下载中
Layer 3 ━━━━━━━━━━━━━━━ 下载中
```

**为什么分层拉取更高效？**

- 如果本地已有某些层（比如基础的 Ubuntu 层），就跳过不下载
- 多个镜像可以共享相同的层
- 增量更新：只需下载变化的层

**5. 验证完整性**

每个层下载后，Docker 会验证其 SHA256 哈希值：

```
下载的层哈希: sha256:abc123...
Manifest 中的哈希: sha256:abc123...
验证: ✓ 通过
```

这确保下载的内容没有被篡改。

---

## 第三阶段：容器配置准备

镜像准备好后，Docker 开始为容器准备运行环境。这是最复杂的阶段，涉及多个子系统。

### 1. 文件系统准备

#### 联合挂载

还记得镜像是分层的吗？容器需要将这些层"叠加"成一个统一的文件系统：

```
容器的文件系统视图：

┌──────────────────────────────┐
│  容器层（读写层）             │  ← 新创建的空层
├──────────────────────────────┤
│  应用配置层（只读）           │  ← 从镜像
├──────────────────────────────┤
│  应用代码层（只读）           │  ← 从镜像
├──────────────────────────────┤
│  依赖包层（只读）             │  ← 从镜像
├──────────────────────────────┤
│  运行时层（只读）             │  ← 从镜像
├──────────────────────────────┤
│  基础系统层（只读）           │  ← 从镜像
└──────────────────────────────┘
       ↓ Union Mount (OverlayFS)
┌──────────────────────────────┐
│  /（根文件系统）              │  ← 容器内看到的统一视图
└──────────────────────────────┘
```

**OverlayFS 的工作原理**：

```
lower: 镜像的所有只读层
upper: 容器的可写层
merged: 联合后的视图（容器内看到的）
work: 临时工作目录
```

当容器修改 `/etc/nginx/nginx.conf` 时：
1. 文件从 lower 层复制到 upper 层
2. 在 upper 层进行修改
3. merged 视图显示修改后的文件

### 2. Namespace 创建与配置

这是容器隔离的核心。Docker 为容器创建一组新的 Namespace：

#### PID Namespace

```
宿主机的进程树：
init (PID 1)
  ├─ systemd (PID 2)
  ├─ dockerd (PID 1234)
  └─ 容器进程 (PID 5678)  ← 宿主机看到的 PID

容器内的进程树：
nginx (PID 1)  ← 容器内看到的 PID（同一个进程！）
  ├─ nginx worker (PID 6)
  └─ nginx worker (PID 7)
```

**关键点**：容器内的 PID 1 进程在宿主机上有不同的 PID。

#### NET Namespace

为容器创建独立的网络栈：

```
宿主机网络栈：
├─ lo (127.0.0.1)
├─ eth0 (192.168.1.100)
└─ docker0 (172.17.0.1)  ← 虚拟网桥

容器网络栈：
├─ lo (127.0.0.1)  ← 容器自己的回环接口
└─ eth0 (172.17.0.2)  ← 实际是 veth pair 的一端
```

**veth pair 的原理**：

```
┌─────────────────────┐        ┌──────────────────┐
│      容器            │        │     宿主机        │
│                     │        │                  │
│  eth0 (172.17.0.2) │◄──────►│ vethXXX          │
│                     │  pair  │      ↓           │
└─────────────────────┘        │   docker0        │
                               │   (网桥)         │
                               └──────────────────┘
```

veth pair 就像一根"网线"，一端在容器内，一端连到宿主机的网桥。

#### MNT Namespace

容器有自己的挂载点视图：

```
容器的挂载点：
/     → 容器的根文件系统（联合挂载）
/proc → 容器自己的 proc
/sys  → 容器自己的 sys
/data → 可能挂载了一个 Docker Volume
```

容器内执行 `mount` 命令，只能看到自己的挂载点，看不到宿主机的其他挂载。

#### 其他 Namespace

- **UTS Namespace**：容器可以有独立的主机名
- **IPC Namespace**：隔离进程间通信（共享内存、信号量）
- **User Namespace**：容器内的 root 可以映射到宿主机的普通用户

### 3. Cgroups 配置

Namespace 实现了"隔离"，Cgroups 实现了"限制"。

#### CPU 限制

```bash
# 用户可能指定：--cpus 0.5
# Docker 配置 Cgroups：
/sys/fs/cgroup/cpu/docker/<container_id>/
  ├─ cpu.cfs_period_us = 100000  (100ms 周期)
  └─ cpu.cfs_quota_us  = 50000   (50ms 配额)
```

**工作原理**：
- 每 100ms 周期内，容器最多使用 50ms 的 CPU 时间
- 相当于 0.5 个 CPU 核心

#### 内存限制

```bash
# 用户可能指定：--memory 512m
# Docker 配置 Cgroups：
/sys/fs/cgroup/memory/docker/<container_id>/
  ├─ memory.limit_in_bytes = 536870912  (512MB)
  └─ memory.oom_control    = 0 (启用 OOM killer)
```

**工作原理**：
- 容器内进程的内存使用被内核跟踪
- 超过限制时，触发 OOM Killer，可能终止容器进程

#### 磁盘 I/O 限制

```bash
# 用户可能指定：--device-write-bps /dev/sda:10mb
# Docker 配置 Cgroups：
/sys/fs/cgroup/blkio/docker/<container_id>/
  └─ blkio.throttle.write_bps_device = "8:0 10485760"
```

**工作原理**：
- 内核限制容器向指定设备的写入速率
- 超过限制时，写操作会被延迟

### 4. 网络配置

#### Bridge 模式（默认）

```
1. 创建 veth pair
   veth0 ←→ veth1

2. 将 veth0 放入容器的 NET Namespace
   容器内看到的网卡名：eth0

3. 将 veth1 连接到 docker0 网桥
   宿主机上显示为 vethXXXXXX

4. 为容器分配 IP 地址
   从 172.17.0.0/16 网段分配：172.17.0.2

5. 配置路由
   容器的默认网关：172.17.0.1 (docker0)

6. 配置 iptables（如果有端口映射）
   -p 8080:80 → DNAT 规则
```

**端口映射的原理**：

```
外部请求: 192.168.1.100:8080
     ↓ iptables DNAT 规则
目标地址改写: 172.17.0.2:80
     ↓ docker0 网桥转发
容器: 172.17.0.2:80
```

### 5. 存储卷挂载

如果用户指定了 `-v` 或 `--volume`：

```bash
docker run -v mydata:/data nginx
```

**Volume 的准备过程**：

```
1. 检查 Volume 是否存在
   /var/lib/docker/volumes/mydata

2. 如果不存在，创建 Volume
   mkdir /var/lib/docker/volumes/mydata/_data

3. 将 Volume 挂载到容器的 MNT Namespace
   bind mount:
   /var/lib/docker/volumes/mydata/_data → /data
```

**Bind Mount 的原理**：

```
宿主机路径: /var/lib/docker/volumes/mydata/_data
              ↕ bind mount
容器内路径: /data

同一块磁盘区域，两个不同的路径访问
```

---

## 第四阶段：容器运行时启动

Docker Daemon 不直接创建容器进程，而是通过一系列组件：

```
Docker Daemon
     ↓ gRPC
containerd (容器运行时守护进程)
     ↓
containerd-shim (容器进程的父进程)
     ↓
runc (OCI 运行时)
     ↓
容器进程
```

### 为什么需要这么多层？

**containerd**：
- 职责：镜像管理、容器生命周期管理
- 优势：可以独立于 Docker 使用（Kubernetes 就直接用 containerd）

**containerd-shim**：
- 职责：作为容器进程的父进程，保持 stdio 连接
- 优势：runc 创建容器后可以退出，shim 继续管理容器

**runc**：
- 职责：实际创建和启动容器进程
- 优势：轻量级，遵循 OCI 标准，创建后即退出

### runc 创建容器的过程

这是真正创建容器的地方：

**1. 解析 OCI 规范**

containerd 生成符合 OCI 标准的 `config.json`：

```json
{
  "root": {
    "path": "/var/lib/docker/overlay2/xxx/merged"
  },
  "process": {
    "args": ["nginx", "-g", "daemon off;"],
    "env": ["PATH=/usr/local/sbin:/usr/local/bin:..."],
    "cwd": "/"
  },
  "linux": {
    "namespaces": [
      {"type": "pid"}, {"type": "net"}, {"type": "mnt"}
    ],
    "resources": {
      "memory": {"limit": 536870912},
      "cpu": {"quota": 50000, "period": 100000}
    }
  }
}
```

**2. 创建容器进程**

runc 执行以下系统调用序列：

```
1. clone() 系统调用，创建新进程
   参数：CLONE_NEWPID | CLONE_NEWNET | CLONE_NEWNS ...
   效果：新进程拥有独立的 PID/NET/MNT Namespace

2. 设置 Cgroups
   将新进程加入配置好的 cgroup

3. pivot_root()
   将容器的根文件系统设为容器进程的根目录

4. execve()
   执行容器的入口命令（如 nginx）
```

**3. runc 退出，shim 接管**

```
容器进程: PID 5678 (宿主机视角)
    ↑ 父进程
containerd-shim: PID 5670

runc 的任务完成，退出
```

---

## 第五阶段：容器进程运行

### 容器内的"世界观"

此时容器进程已经启动，它看到的"世界"是：

```
文件系统: 自己的根目录（联合挂载）
进程: 只能看到自己和子进程（PID Namespace）
网络: 独立的网络栈，通过 veth 与外界通信
主机名: 容器 ID 或用户指定的名称
资源: 被 Cgroups 限制的 CPU 和内存
```

### Docker Daemon 的监控

容器启动后，Docker Daemon 持续监控：

```
定期检查:
  - 容器进程是否还在运行？
  - 资源使用情况如何？
  - 健康检查是否通过？

通过 containerd-shim 获取:
  - 容器的退出状态
  - stdout/stderr 输出
  - 容器的信号处理
```

---

## 容器 vs 虚拟机：启动过程对比

理解了容器创建过程，就能明白为什么容器比虚拟机快：

### 虚拟机启动（分钟级）

```
1. 启动 Hypervisor
2. 分配虚拟硬件资源
3. 加载 Guest OS 内核
4. 初始化 Guest OS（init、systemd）
5. 启动系统服务
6. 启动应用程序
```

### 容器启动（秒级）

```
1. 准备镜像层（已在本地，或快速拉取）
2. 创建联合文件系统（几乎瞬间）
3. 创建 Namespace 和 Cgroups（内核操作，毫秒级）
4. 配置网络（创建 veth，毫秒级）
5. 启动应用程序进程（直接 fork + exec）
```

**关键区别**：
- 虚拟机需要启动完整的操作系统
- 容器只是启动一个进程，直接使用宿主机内核

---

## 容器启动失败的常见原因

理解创建过程后，排查问题就有思路了：

### 1. 镜像拉取失败

```
原因：网络问题、镜像不存在、权限问题
排查：docker pull <image> 测试拉取
```

### 2. 端口冲突

```
原因：宿主机端口已被占用
排查：lsof -i :8080 查看端口占用
```

### 3. 资源不足

```
原因：内存不足、磁盘空间不够
排查：docker system df 查看磁盘使用
      free -h 查看内存
```

### 4. 入口命令错误

```
原因：CMD/ENTRYPOINT 配置错误，进程立即退出
排查：docker logs <container> 查看日志
      docker run -it <image> sh 进入调试
```

### 5. 依赖的服务未就绪

```
原因：数据库、缓存等依赖服务还没准备好
解决：使用健康检查和重试机制
```

---

## 总结

Docker 容器创建是一个精心设计的过程，涉及多个层次：

**镜像层面**：
- 分层存储，共享基础层
- 增量拉取，按需下载
- 哈希验证，确保完整性

**隔离层面**：
- Namespace 提供资源视图隔离
- 容器进程"以为"自己独占系统
- 7 种 Namespace 隔离不同资源

**限制层面**：
- Cgroups 限制资源使用量
- CPU、内存、磁盘 I/O 都可控
- 防止单个容器耗尽系统资源

**网络层面**：
- veth pair + 网桥实现容器通信
- iptables 实现端口映射
- 多种网络模式满足不同需求

**运行时层面**：
- Docker Daemon → containerd → runc
- 分层架构，职责清晰
- 符合 OCI 标准，可替换

理解这些原理，你就能：
- 写出更高效的容器化应用
- 快速诊断容器问题
- 优化容器的性能和安全性

容器技术的本质是**进程隔离 + 资源限制**，它巧妙地利用了 Linux 内核的特性，实现了轻量级的"虚拟化"。
