# 容器安全实践

## 概述

容器安全是容器化部署中不可忽视的环节。虽然Docker提供了namespace和cgroups等隔离机制，但容器并非完全隔离的虚拟机，需要从镜像安全、运行时安全、主机安全等多个层面进行防护。本文介绍Docker安全的核心概念和最佳实践。

## 安全威胁模型

```
┌─────────────────────────────────────────────────────────────────┐
│                        Attack Surface                            │
│                                                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │
│  │ Image-based  │  │  Runtime     │  │   Host       │         │
│  │  Attacks     │  │  Attacks     │  │  Attacks     │         │
│  │              │  │              │  │              │         │
│  │ - Malicious  │  │ - Container  │  │ - Docker     │         │
│  │   images     │  │   escape     │  │   socket     │         │
│  │ - Vulner-    │  │ - Privilege  │  │   exposure   │         │
│  │   abilities  │  │   escalation │  │ - Kernel     │         │
│  │ - Secrets    │  │ - DoS        │  │   exploits   │         │
│  │   in images  │  │ - Network    │  │ - Misconfigu-│         │
│  │              │  │   attacks    │  │   ration     │         │
│  └──────────────┘  └──────────────┘  └──────────────┘         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 镜像安全

### 使用可信基础镜像

```dockerfile
# 推荐：使用官方镜像
FROM nginx:1.25-alpine

# 推荐：使用特定版本，不要使用latest
FROM python:3.11-slim-bookworm

# 更好：使用digest锁定
FROM nginx@sha256:abc123...

# 推荐：使用minimal镜像
FROM gcr.io/distroless/python3
FROM alpine:3.18
```

### 镜像扫描

```bash
# 使用Docker Scout扫描
docker scout cves myimage:latest
docker scout recommendations myimage:latest

# 使用Trivy扫描
trivy image myimage:latest
trivy image --severity HIGH,CRITICAL myimage:latest

# 使用Grype扫描
grype myimage:latest

# 使用Snyk扫描
snyk container test myimage:latest
```

### 不在镜像中存储敏感信息

```dockerfile
# 错误：在镜像中包含敏感信息
COPY secrets.json /app/
ENV API_KEY=secret123

# 正确：使用环境变量或Secrets
# docker run -e API_KEY=$API_KEY myapp
# docker run --secret source=api_key,target=/run/secrets/api_key myapp
```

### 多阶段构建减少攻击面

```dockerfile
# 构建阶段
FROM golang:1.21 AS builder
WORKDIR /app
COPY . .
RUN CGO_ENABLED=0 go build -o myapp

# 运行阶段（最小镜像）
FROM gcr.io/distroless/static:nonroot
COPY --from=builder /app/myapp /
USER nonroot:nonroot
ENTRYPOINT ["/myapp"]
```

## 运行时安全

### 以非root用户运行

```dockerfile
# Dockerfile中创建并切换到非root用户
FROM alpine:3.18

# 创建用户
RUN addgroup -g 1000 appgroup && \
    adduser -u 1000 -G appgroup -D appuser

# 设置工作目录权限
WORKDIR /app
COPY --chown=appuser:appgroup . .

# 切换到非root用户
USER appuser

CMD ["./app"]
```

```bash
# 运行时指定用户
docker run -u 1000:1000 myapp

# 验证
docker exec mycontainer whoami
docker exec mycontainer id
```

### 只读文件系统

```bash
# 使用只读根文件系统
docker run --read-only myapp

# 为需要写入的目录添加tmpfs
docker run --read-only \
  --tmpfs /tmp \
  --tmpfs /var/run \
  myapp

# 或挂载卷用于写入
docker run --read-only \
  -v data:/app/data \
  myapp
```

### 限制Capabilities

```bash
# 删除所有capabilities，只添加需要的
docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE myapp

# 常用的capabilities
# NET_BIND_SERVICE: 绑定低于1024的端口
# CHOWN: 更改文件所有权
# SETUID/SETGID: 更改UID/GID
# DAC_OVERRIDE: 绕过文件权限检查
```

```dockerfile
# Dockerfile中也可以设置
FROM alpine
RUN apk add --no-cache libcap && \
    setcap 'cap_net_bind_service=+ep' /app/myapp
```

### 禁用特权模式

```bash
# 永远不要在生产环境使用--privileged
# 错误
docker run --privileged myapp

# 正确：只添加必要的权限
docker run --cap-add=SYS_PTRACE myapp

# 如果需要访问设备，使用--device
docker run --device=/dev/snd myapp
```

### 限制系统调用（Seccomp）

```bash
# 使用默认的seccomp配置文件
docker run --security-opt seccomp=default myapp

# 使用自定义seccomp配置
docker run --security-opt seccomp=/path/to/seccomp.json myapp
```

```json
// seccomp.json示例
{
  "defaultAction": "SCMP_ACT_ERRNO",
  "architectures": ["SCMP_ARCH_X86_64"],
  "syscalls": [
    {
      "names": ["read", "write", "exit", "exit_group"],
      "action": "SCMP_ACT_ALLOW"
    }
  ]
}
```

### AppArmor配置

```bash
# 使用默认AppArmor配置
docker run --security-opt apparmor=docker-default myapp

# 使用自定义AppArmor配置
docker run --security-opt apparmor=my-custom-profile myapp

# 查看当前容器的AppArmor配置
docker inspect --format='{{.AppArmorProfile}}' mycontainer
```

### SELinux配置

```bash
# 在SELinux环境中运行
docker run --security-opt label=level:s0:c100,c200 myapp

# 禁用SELinux标签（不推荐）
docker run --security-opt label=disable myapp
```

## 网络安全

### 使用用户定义网络

```bash
# 创建隔离的网络
docker network create --internal backend-net

# 容器只能访问同网络的其他容器
docker run -d --network backend-net --name db postgres
docker run -d --network backend-net --name api myapi
```

### 限制容器间通信

```json
// /etc/docker/daemon.json
{
  "icc": false  // 禁用容器间通信
}
```

### 不暴露Docker socket

```bash
# 危险：将Docker socket挂载到容器
# 这允许容器控制主机上的Docker
docker run -v /var/run/docker.sock:/var/run/docker.sock myapp

# 如果必须使用，使用只读方式或代理
docker run -v /var/run/docker.sock:/var/run/docker.sock:ro myapp
```

### 限制端口暴露

```bash
# 只绑定到必要的接口
docker run -p 127.0.0.1:8080:80 myapp

# 不要使用0.0.0.0
docker run -p 8080:80 myapp  # 默认绑定到0.0.0.0
```

## 资源限制

```bash
# 限制资源防止DoS
docker run -d \
  --memory=512m \
  --memory-swap=512m \
  --cpus=1 \
  --pids-limit=100 \
  --ulimit nofile=1024:1024 \
  myapp
```

## 日志与审计

### 启用日志

```json
// /etc/docker/daemon.json
{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  }
}
```

### 审计Docker活动

```bash
# 启用Docker守护进程审计
# /etc/audit/rules.d/docker.rules
-w /usr/bin/docker -k docker
-w /var/lib/docker -k docker
-w /etc/docker -k docker
-w /usr/lib/systemd/system/docker.service -k docker
-w /etc/default/docker -k docker
-w /etc/docker/daemon.json -k docker
-w /usr/bin/containerd -k docker
```

## Docker Daemon安全

### TLS配置

```bash
# 生成证书
openssl genrsa -aes256 -out ca-key.pem 4096
openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem

# 配置Docker使用TLS
# /etc/docker/daemon.json
{
  "tls": true,
  "tlsverify": true,
  "tlscacert": "/etc/docker/ca.pem",
  "tlscert": "/etc/docker/server-cert.pem",
  "tlskey": "/etc/docker/server-key.pem",
  "hosts": ["tcp://0.0.0.0:2376", "unix:///var/run/docker.sock"]
}
```

### 限制Docker API访问

```bash
# 只允许本地socket访问
# /etc/docker/daemon.json
{
  "hosts": ["unix:///var/run/docker.sock"]
}

# 如果需要远程访问，使用TLS
{
  "hosts": ["unix:///var/run/docker.sock", "tcp://0.0.0.0:2376"],
  "tls": true,
  "tlsverify": true
}
```

## Secrets管理

### Docker Secrets（Swarm模式）

```bash
# 创建secret
echo "mysecretpassword" | docker secret create db_password -

# 在服务中使用
docker service create \
  --name myapp \
  --secret db_password \
  myapp

# 容器内访问
cat /run/secrets/db_password
```

### 使用环境变量（基本方式）

```bash
# 从文件读取
docker run --env-file .env myapp

# 注意：环境变量会出现在docker inspect输出中
# 敏感信息应使用secrets
```

### 外部Secrets管理

```yaml
# 使用HashiCorp Vault
version: '3.8'

services:
  app:
    image: myapp
    environment:
      - VAULT_ADDR=http://vault:8200
      - VAULT_TOKEN=${VAULT_TOKEN}
```

## 安全基准检查

### Docker Bench Security

```bash
# 运行Docker安全基准测试
docker run -it --net host --pid host --userns host --cap-add audit_control \
  -v /var/lib:/var/lib:ro \
  -v /var/run/docker.sock:/var/run/docker.sock:ro \
  -v /usr/lib/systemd:/usr/lib/systemd:ro \
  -v /etc:/etc:ro \
  docker/docker-bench-security
```

### CIS Benchmark检查项

```bash
# 主要检查项：
# 1. 主机配置
# 2. Docker守护进程配置
# 3. Docker守护进程配置文件
# 4. 容器镜像和构建文件
# 5. 容器运行时
# 6. Docker安全操作
# 7. Docker Swarm配置
```

## 安全Dockerfile示例

```dockerfile
# 使用特定版本的minimal基础镜像
FROM python:3.11-slim-bookworm

# 设置标签
LABEL maintainer="security@example.com"
LABEL version="1.0"

# 创建非root用户
RUN groupadd -g 1000 appgroup && \
    useradd -u 1000 -g appgroup -m -s /sbin/nologin appuser

# 安装依赖并清理
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
        curl \
        && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# 设置工作目录
WORKDIR /app

# 复制依赖文件
COPY --chown=appuser:appgroup requirements.txt .

# 安装Python依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY --chown=appuser:appgroup . .

# 切换到非root用户
USER appuser

# 设置只读环境变量
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "app:app"]
```

## 实用命令

```bash
# 安全运行容器
docker run -d \
  --name secure-app \
  --user 1000:1000 \
  --read-only \
  --tmpfs /tmp \
  --cap-drop=ALL \
  --cap-add=NET_BIND_SERVICE \
  --security-opt=no-new-privileges:true \
  --memory=512m \
  --pids-limit=100 \
  myapp

# 扫描镜像漏洞
docker scout cves myimage:latest
trivy image myimage:latest

# 检查安全配置
docker inspect --format='{{.Config.User}}' mycontainer
docker inspect --format='{{json .HostConfig.CapDrop}}' mycontainer
docker inspect --format='{{.HostConfig.ReadonlyRootfs}}' mycontainer
```

## 常见问题

### Q1: 容器以root运行有什么风险？

```bash
# 风险：
# 1. 容器逃逸后直接获得主机root权限
# 2. 可以修改主机挂载的文件
# 3. 可以访问敏感的主机资源

# 解决：
# 1. Dockerfile中使用USER指令
USER appuser

# 2. 运行时指定用户
docker run -u 1000:1000 myapp

# 3. 使用rootless Docker
dockerd-rootless-setuptool.sh install
```

### Q2: 如何防止容器逃逸？

```bash
# 1. 使用最新版本的Docker和内核
# 2. 不使用--privileged
# 3. 删除不需要的capabilities
docker run --cap-drop=ALL myapp

# 4. 使用seccomp限制系统调用
docker run --security-opt seccomp=default myapp

# 5. 启用user namespace
# /etc/docker/daemon.json
{
  "userns-remap": "default"
}

# 6. 使用gVisor或Kata Containers
docker run --runtime=runsc myapp
```

### Q3: 如何安全地使用Docker socket？

```bash
# 最好的方案：不挂载Docker socket

# 如果必须使用：
# 1. 使用只读挂载
docker run -v /var/run/docker.sock:/var/run/docker.sock:ro myapp

# 2. 使用Docker socket代理
# 如Tecnativa/docker-socket-proxy
docker run -d \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -e CONTAINERS=1 \
  -e IMAGES=1 \
  -p 2375:2375 \
  tecnativa/docker-socket-proxy

# 3. 使用最小权限的API访问
```

### Q4: 镜像中发现漏洞怎么处理？

```bash
# 1. 识别漏洞
trivy image myimage:latest

# 2. 更新基础镜像
FROM alpine:3.18  # 使用最新的patch版本

# 3. 更新应用依赖
RUN apk upgrade --no-cache

# 4. 重新构建镜像
docker build --no-cache -t myimage:latest .

# 5. 设置CI/CD中的漏洞检查
# 如果发现高危漏洞，阻止部署
```

### Q5: 如何在CI/CD中实施容器安全？

```yaml
# GitLab CI示例
stages:
  - build
  - scan
  - deploy

build:
  stage: build
  script:
    - docker build -t myapp:$CI_COMMIT_SHA .

security_scan:
  stage: scan
  script:
    # 镜像扫描
    - trivy image --exit-code 1 --severity CRITICAL myapp:$CI_COMMIT_SHA
    # Dockerfile扫描
    - hadolint Dockerfile
    # 密钥扫描
    - gitleaks detect --source . --verbose
  allow_failure: false

deploy:
  stage: deploy
  script:
    - docker push myapp:$CI_COMMIT_SHA
  only:
    - main
  needs:
    - security_scan
```
