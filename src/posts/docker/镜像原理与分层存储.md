# 镜像原理与分层存储

## 什么是Docker镜像？

你可以把Docker镜像想象成一个**压缩包**，里面包含了运行应用所需的一切：操作系统文件、应用程序、库、配置文件。

但它不是普通的压缩包，而是由一层层"薄膜"堆叠而成的。这就是Docker镜像最核心的设计思想：**分层存储**。

## 分层存储：为什么这样设计？

想象你在做蛋糕：

```
┌─────────────────────────────────┐
│      裱花和装饰 (你的应用)      │  ← 最上层
├─────────────────────────────────┤
│      奶油层 (应用依赖)          │
├─────────────────────────────────┤
│      蛋糕胚 (系统工具)          │
├─────────────────────────────────┤
│      底座 (基础操作系统)        │  ← 最底层
└─────────────────────────────────┘
```

如果你要做10个蛋糕，它们都用同一个配方的蛋糕胚，你会做10个蛋糕胚吗？当然不会！你会做一个蛋糕胚，然后切成10份。

Docker镜像也是这个道理：**相同的层只存储一份**。

### 分层的三大好处

**1. 节省磁盘空间**

假设你有10个应用，都基于`python:3.11`基础镜像构建：
- 不分层：10 × 500MB = 5GB
- 分层：500MB（共享基础层）+ 10 × 50MB（应用层）= 1GB

**2. 加快镜像传输**

当你从仓库拉取镜像时，本地已有的层不需要重新下载。如果你已经有了`python:3.11`的层，只需要下载应用层。

**3. 加速构建过程**

构建镜像时，没有变化的层可以直接使用缓存。这就是为什么第二次构建通常比第一次快很多。

## 层的本质

每一层代表Dockerfile中的一条指令产生的文件变化：

```dockerfile
FROM ubuntu:22.04       # 层1：基础镜像（约77MB）
RUN apt-get update      # 层2：包索引文件
RUN apt-get install curl # 层3：curl及其依赖
COPY app.py /app/       # 层4：你的应用文件
```

**关键理解**：
- 每层是**只读的**
- 每层只记录与上一层的**差异**（增加、修改、删除了哪些文件）
- 层叠加在一起，形成完整的文件系统

## 联合文件系统（UnionFS）

Docker使用一种叫做**联合文件系统**的技术，把多个只读层"联合"成一个看起来完整的文件系统。

```
用户看到的视图（统一的文件系统）
        /bin  /etc  /lib  /app  /var
           ▲
           │  联合挂载
           │
  ┌────────┴────────┐
  │                 │
层3: /app/app.py    层2: /usr/bin/curl    层1: /bin, /etc, /lib...
```

你看到的是一个完整的目录结构，但实际上文件分布在不同的层中。

### 常用的存储驱动

Docker支持多种存储驱动来实现这个功能：

| 驱动 | 说明 |
|------|------|
| **overlay2** | 现代Linux首选，性能好 |
| devicemapper | 旧版本CentOS/RHEL使用 |
| btrfs/zfs | 如果你的文件系统是这些 |

**生产环境推荐**：overlay2（几乎所有现代Linux发行版）

## 写时复制（Copy-on-Write）

镜像层是只读的，那容器里的文件怎么修改呢？

Docker使用**写时复制**机制：

**读取文件时**：直接从对应的层读取，不需要复制

**修改文件时**：
1. 先把文件从只读层**复制**到容器的可写层
2. 然后在可写层修改这个副本
3. 之后的读取都读这个副本

```
修改前：                    修改后：
┌─────────────────┐         ┌─────────────────┐
│   容器可写层    │         │  /etc/nginx.conf│ ← 修改后的文件
│   (空)         │         │   (容器可写层)  │
├─────────────────┤         ├─────────────────┤
│ /etc/nginx.conf │         │ /etc/nginx.conf │ ← 原文件（被"遮住"了）
│   (镜像层)     │         │   (镜像层)      │
└─────────────────┘         └─────────────────┘
```

**删除文件呢？**

删除操作会在可写层创建一个特殊的"标记文件"（whiteout），告诉系统这个文件被删除了。原文件仍然存在于镜像层中。

这解释了一个重要现象：**在Dockerfile中删除文件不会让镜像变小**。因为文件仍然存在于之前的层中。

## 容器层 vs 镜像层

```
┌─────────────────────┐
│    容器可写层       │  ← 每个容器独有，容器删除后消失
│    (Container Layer)│
├─────────────────────┤
│    镜像层4          │
├─────────────────────┤  ← 所有基于该镜像的容器共享
│    镜像层3          │    只读，不会被修改
├─────────────────────┤
│    镜像层2          │
├─────────────────────┤
│    镜像层1          │
└─────────────────────┘
```

**关键区别**：
- **镜像层**：只读，可被多个容器共享
- **容器层**：可读写，每个容器独有，容器删除后消失

这就是为什么：
- 启动新容器很快（只需要创建一个薄薄的可写层）
- 修改容器不影响其他容器（各自有独立的可写层）
- 容器删除后数据丢失（可写层随之消失）

## 理解镜像大小

### 实际大小 vs 虚拟大小

当你运行`docker images`时，显示的SIZE是**虚拟大小**（所有层加起来）。但因为层可以共享，实际占用的磁盘空间可能小得多。

查看真实的磁盘占用：
```bash
docker system df -v
```

### 为什么镜像比预期大？

常见原因：

1. **删除操作的陷阱**
   ```dockerfile
   RUN apt-get install build-essential   # 安装500MB
   RUN rm -rf /var/lib/apt/lists/*       # 删除缓存
   ```
   删除命令在新层执行，原文件仍在第一层。

   **正确做法**：在同一层内删除

   ```dockerfile
   RUN apt-get install build-essential && \
       rm -rf /var/lib/apt/lists/*
   ```

2. **基础镜像太大**
   - ubuntu:22.04 ≈ 77MB
   - alpine:3.18 ≈ 5MB

   如果你的应用只需要基本功能，alpine可能是更好的选择。

## 层共享的实际例子

假设你有两个应用：

```dockerfile
# App A
FROM python:3.11-slim
COPY app_a.py /app/
CMD ["python", "/app/app_a.py"]

# App B
FROM python:3.11-slim
COPY app_b.py /app/
CMD ["python", "/app/app_b.py"]
```

存储情况：
```
python:3.11-slim (120MB)  ← 只存储一份
    │
    ├── App A 的层 (1MB)
    │
    └── App B 的层 (1MB)

总磁盘占用：122MB（不是240MB）
```

## 常见问题

### Q1: 怎么查看镜像有哪些层？

```bash
docker history <镜像名>
```

每一行对应一层，SIZE列显示该层的大小。

### Q2: 为什么有些层显示&lt;missing&gt;？

这是正常的。`&lt;missing&gt;`表示这些层是从远程仓库拉取的中间层，本地没有单独的镜像ID。

### Q3: 删除文件为什么镜像不变小？

因为删除操作只是在新层添加一个"删除标记"，原文件仍在旧层。

**解决方案**：
- 在同一个RUN指令中删除临时文件
- 使用多阶段构建，只保留需要的文件

### Q4: 镜像层有数量限制吗？

理论上没有硬限制，但：
- 层太多会影响性能（每层都要挂载）
- 建议控制在20层以内

### Q5: 怎么减少层数？

1. 合并RUN指令
2. 使用多阶段构建
3. 减少不必要的COPY指令

## 小结

| 概念 | 关键点 |
|------|--------|
| 分层存储 | 镜像由只读层堆叠而成，相同层只存一份 |
| 联合文件系统 | 把多层"联合"成一个完整的文件系统视图 |
| 写时复制 | 修改文件时先复制到可写层，再修改 |
| 容器层 | 每个容器独有的可写层，删除后消失 |

理解这些原理后，你就能明白：
- 为什么启动容器这么快（只创建一个薄薄的可写层）
- 为什么镜像可以共享（相同的层只存一份）
- 为什么删除文件不能减小镜像（文件仍在旧层）
- 为什么要在同一层清理临时文件（避免残留在之前的层）
