---
date: 2026-02-03
author: Gaaming Zhang
isOriginal: false
article: true
category:
  - docker
tag:
  - docker
  - ClaudeCode
---

# 容器调试技巧

## 概述

容器化应用的调试与传统应用有所不同，由于容器的隔离性和临时性，需要掌握特定的调试技巧。本文介绍Docker容器调试的各种方法和工具，帮助快速定位和解决问题。

## 调试思路

```
┌────────────────────────────────────────────────────────────────┐
│                      Container Debugging                        │
│                                                                │
│  1. 容器状态检查                                                │
│     └── docker ps, docker inspect                              │
│                                                                │
│  2. 日志分析                                                    │
│     └── docker logs, 应用日志                                   │
│                                                                │
│  3. 进入容器                                                    │
│     └── docker exec, docker attach                             │
│                                                                │
│  4. 进程和资源                                                  │
│     └── docker top, docker stats                               │
│                                                                │
│  5. 网络调试                                                    │
│     └── ping, curl, netstat, tcpdump                          │
│                                                                │
│  6. 文件系统检查                                                │
│     └── docker diff, docker cp                                 │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

## 容器状态检查

### 查看容器状态

```bash
# 查看运行中的容器
docker ps

# 查看所有容器（包括停止的）
docker ps -a

# 查看容器详细状态
docker inspect mycontainer

# 查看特定状态信息
docker inspect --format='{{.State.Status}}' mycontainer
docker inspect --format='{{.State.ExitCode}}' mycontainer
docker inspect --format='{{.State.Error}}' mycontainer
docker inspect --format='{{.State.OOMKilled}}' mycontainer

# 查看容器启动命令
docker inspect --format='{{.Config.Cmd}}' mycontainer
docker inspect --format='{{.Config.Entrypoint}}' mycontainer

# 查看环境变量
docker inspect --format='{{range .Config.Env}}{{println .}}{{end}}' mycontainer
```

### 查看容器事件

```bash
# 实时监控容器事件
docker events

# 过滤特定容器的事件
docker events --filter container=mycontainer

# 过滤特定类型的事件
docker events --filter type=container --filter event=die

# 查看最近的事件
docker events --since 1h
```

## 日志分析

### 基本日志查看

```bash
# 查看全部日志
docker logs mycontainer

# 实时跟踪日志
docker logs -f mycontainer

# 显示时间戳
docker logs -t mycontainer

# 查看最近N行
docker logs --tail 100 mycontainer

# 查看指定时间范围
docker logs --since "2024-01-01T00:00:00" mycontainer
docker logs --since 30m mycontainer
docker logs --until "2024-01-01T12:00:00" mycontainer
```

### 分离stdout和stderr

```bash
# 只看stdout
docker logs mycontainer 2>/dev/null

# 只看stderr
docker logs mycontainer 2>&1 1>/dev/null

# 导出日志
docker logs mycontainer > stdout.log 2> stderr.log
```

### 应用内日志

```bash
# 查看容器内的日志文件
docker exec mycontainer cat /var/log/app.log

# 实时查看应用日志
docker exec mycontainer tail -f /var/log/app.log

# 搜索特定内容
docker exec mycontainer grep "ERROR" /var/log/app.log
```

## 进入容器调试

### 使用exec进入

```bash
# 进入运行中的容器
docker exec -it mycontainer bash

# 容器没有bash时使用sh
docker exec -it mycontainer sh

# 以root用户进入
docker exec -it -u root mycontainer bash

# 在特定目录执行
docker exec -it -w /app mycontainer bash

# 设置环境变量
docker exec -it -e DEBUG=true mycontainer bash
```

### 调试已停止的容器

```bash
# 方法1: 修改启动命令
docker commit mycontainer debug-image
docker run -it debug-image bash

# 方法2: 覆盖entrypoint
docker run -it --entrypoint bash myimage

# 方法3: 使用docker start -ai
docker start -ai mycontainer
```

### 调试无shell的容器

```bash
# 使用nsenter（需要容器的PID）
PID=$(docker inspect --format '{{.State.Pid}}' mycontainer)
sudo nsenter -t $PID -m -u -i -n -p bash

# 使用docker debug（Docker Desktop）
docker debug mycontainer

# 复制调试工具到容器
docker cp /usr/bin/bash mycontainer:/tmp/
docker exec -it mycontainer /tmp/bash
```

### 使用调试容器

```bash
# 使用nicolaka/netshoot调试网络
docker run -it --net container:mycontainer nicolaka/netshoot

# 使用busybox作为调试工具
docker run -it --pid container:mycontainer --net container:mycontainer busybox
```

## 进程和资源调试

### 查看容器进程

```bash
# 查看容器内进程
docker top mycontainer

# 使用ps参数
docker top mycontainer aux

# 进入容器查看详细进程
docker exec mycontainer ps aux
docker exec mycontainer pstree -p
```

### 资源使用监控

```bash
# 实时资源统计
docker stats mycontainer

# 一次性输出
docker stats --no-stream mycontainer

# 自定义输出格式
docker stats --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}\t{{.BlockIO}}"
```

### 检查OOM

```bash
# 检查是否因OOM被杀
docker inspect --format='{{.State.OOMKilled}}' mycontainer

# 查看系统OOM日志
dmesg | grep -i "out of memory"
dmesg | grep -i "killed process"

# 查看cgroup内存限制
cat /sys/fs/cgroup/memory/docker/<container-id>/memory.limit_in_bytes
cat /sys/fs/cgroup/memory/docker/<container-id>/memory.usage_in_bytes
```

## 网络调试

### 基本网络检查

```bash
# 查看容器IP
docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' mycontainer

# 查看容器网络配置
docker exec mycontainer ip addr
docker exec mycontainer ip route
docker exec mycontainer cat /etc/resolv.conf

# 测试连通性
docker exec mycontainer ping -c 3 google.com
docker exec mycontainer ping -c 3 other-container

# 测试DNS解析
docker exec mycontainer nslookup google.com
docker exec mycontainer dig +short google.com
```

### 端口和连接

```bash
# 查看端口映射
docker port mycontainer

# 查看容器内端口监听
docker exec mycontainer netstat -tlnp
docker exec mycontainer ss -tlnp

# 测试端口连接
docker exec mycontainer curl -v http://localhost:8080
docker exec mycontainer nc -zv target-host 3306
```

### 抓包分析

```bash
# 在容器内抓包（需要tcpdump）
docker exec mycontainer tcpdump -i eth0 -n

# 在主机上抓包
# 找到容器的veth接口
docker exec mycontainer cat /sys/class/net/eth0/iflink
# 在主机上找对应接口
ip link | grep <iflink>
sudo tcpdump -i veth<xxx> -n

# 使用netshoot容器抓包
docker run -it --net container:mycontainer nicolaka/netshoot tcpdump -i eth0
```

### 网络命名空间

```bash
# 进入容器网络命名空间
PID=$(docker inspect --format '{{.State.Pid}}' mycontainer)
sudo nsenter -t $PID -n bash

# 在网络命名空间内执行命令
sudo nsenter -t $PID -n ip addr
sudo nsenter -t $PID -n netstat -tlnp
```

## 文件系统调试

### 查看文件变化

```bash
# 查看容器文件系统变化
docker diff mycontainer
# A: 添加的文件
# C: 修改的文件
# D: 删除的文件
```

### 文件复制

```bash
# 从容器复制文件
docker cp mycontainer:/app/config.json ./

# 复制到容器
docker cp ./debug.sh mycontainer:/tmp/

# 复制整个目录
docker cp mycontainer:/var/log/ ./logs/
```

### 挂载检查

```bash
# 查看容器挂载
docker inspect --format='{{json .Mounts}}' mycontainer | jq

# 验证挂载权限
docker exec mycontainer ls -la /mnt/data
docker exec mycontainer touch /mnt/data/test
```

## 镜像调试

### 分析镜像层

```bash
# 查看镜像历史
docker history myimage

# 详细历史（不截断）
docker history --no-trunc myimage

# 使用dive分析镜像
dive myimage
```

### 导出镜像内容

```bash
# 导出镜像文件系统
docker save myimage -o image.tar
tar -tvf image.tar

# 创建容器并导出
docker create --name temp myimage
docker export temp -o container.tar
docker rm temp
tar -tvf container.tar
```

## 调试工具

### 常用调试镜像

```bash
# 网络调试
docker run -it --net container:mycontainer nicolaka/netshoot

# 通用调试
docker run -it busybox

# 完整Linux环境
docker run -it ubuntu:22.04

# 性能分析
docker run -it --privileged --pid host brendangregg/perf-tools
```

### 构建包含调试工具的镜像

```dockerfile
# Dockerfile.debug
FROM myapp:latest

RUN apt-get update && apt-get install -y \
    curl \
    wget \
    vim \
    net-tools \
    iputils-ping \
    dnsutils \
    tcpdump \
    strace \
    procps \
    && rm -rf /var/lib/apt/lists/*

# 或Alpine
FROM myapp:latest

RUN apk add --no-cache \
    curl \
    wget \
    vim \
    net-tools \
    iputils \
    bind-tools \
    tcpdump \
    strace \
    procps
```

## 远程调试

### Node.js远程调试

```bash
# 启动时启用调试
docker run -d -p 9229:9229 \
  node:18 node --inspect=0.0.0.0:9229 app.js

# 连接Chrome DevTools
chrome://inspect
```

### Python远程调试

```bash
# 使用debugpy
docker run -d -p 5678:5678 \
  -e PYTHONDONTWRITEBYTECODE=1 \
  myapp python -m debugpy --listen 0.0.0.0:5678 --wait-for-client app.py
```

### Java远程调试

```bash
# 启用JDWP
docker run -d -p 5005:5005 \
  -e JAVA_TOOL_OPTIONS="-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005" \
  myapp
```

## 性能分析

### CPU分析

```bash
# 使用perf（需要privileged）
docker run --privileged --pid host -it brendangregg/perf-tools \
  perf top -p $(docker inspect --format '{{.State.Pid}}' mycontainer)

# 使用strace追踪系统调用
docker exec mycontainer strace -p 1 -c
```

### 内存分析

```bash
# 查看内存详情
docker exec mycontainer cat /proc/meminfo

# 查看进程内存
docker exec mycontainer cat /proc/1/smaps

# 使用pmap
docker exec mycontainer pmap -x 1
```

## 实用命令

```bash
# 调试状态
docker inspect --format='{{.State}}' mycontainer | jq
docker logs --tail 50 -f mycontainer

# 网络调试
docker exec mycontainer ping target
docker exec mycontainer curl -v http://service

# 资源监控
docker stats --no-stream mycontainer

# 进入容器
docker exec -it mycontainer bash
docker run -it --entrypoint bash myimage
```

## 常见问题

### Q1: 容器启动后立即退出？

```bash
# 1. 查看退出码
docker inspect --format='{{.State.ExitCode}}' mycontainer

# 2. 查看日志
docker logs mycontainer

# 3. 检查启动命令
docker inspect --format='{{.Config.Cmd}}' mycontainer

# 4. 交互式调试
docker run -it --entrypoint bash myimage

# 常见原因：
# - 退出码0：正常结束（可能CMD命令执行完就退出了）
# - 退出码1：应用错误
# - 退出码137：OOM或收到SIGKILL
# - 退出码139：段错误
# - 退出码143：收到SIGTERM
```

### Q2: 容器内无法访问网络？

```bash
# 1. 检查DNS配置
docker exec mycontainer cat /etc/resolv.conf

# 2. 测试IP连通性
docker exec mycontainer ping -c 3 8.8.8.8

# 3. 检查路由
docker exec mycontainer ip route

# 4. 检查防火墙规则
sudo iptables -L -n -v

# 5. 检查Docker网络
docker network inspect bridge
```

### Q3: 如何调试多阶段构建？

```bash
# 构建到特定阶段
docker build --target builder -t myapp:builder .

# 进入该阶段调试
docker run -it myapp:builder bash

# 查看构建过程
docker build --progress=plain -t myapp .
```

### Q4: 容器性能差如何分析？

```bash
# 1. 查看资源使用
docker stats mycontainer

# 2. 检查CPU限制是否过小
docker inspect --format='{{.HostConfig.NanoCpus}}' mycontainer

# 3. 检查是否有CPU节流
cat /sys/fs/cgroup/cpu/docker/<id>/cpu.stat

# 4. 检查I/O
docker exec mycontainer iostat -x 1

# 5. 检查网络延迟
docker exec mycontainer ping -c 10 target
```

### Q5: 如何保留崩溃容器的现场？

```bash
# 1. 不要使用--rm
docker run -d myapp  # 不加--rm

# 2. 崩溃后提交为镜像
docker commit crashed-container debug:v1

# 3. 从镜像创建新容器调试
docker run -it --entrypoint bash debug:v1

# 4. 导出容器文件系统
docker export crashed-container -o crash-dump.tar
```
