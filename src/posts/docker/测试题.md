---
date: 2026-02-03
author: Gaaming Zhang
isOriginal: false
article: true
category:
  - docker
tag:
  - docker
  - ClaudeCode
---

# Docker 核心知识测试题

本测试包含100道选择题，涵盖Docker的核心知识点。答案使用剧透功能隐藏，点击可查看。

## Docker基础与架构

**1. Docker使用什么架构模式？**
- A. 单体架构
- B. 客户端-服务器架构
- C. 点对点架构
- D. 主从架构

答案：!!B!!

**2. Docker的核心组件不包括以下哪个？** ***!***
- A. Docker Client
- B. Docker Daemon
- C. Docker Registry
- D. Docker Compiler

答案：!!D!!

**3. Docker容器与虚拟机的主要区别是？**
- A. 容器不需要操作系统
- B. 容器共享主机内核，更轻量级
- C. 虚拟机启动更快
- D. 没有区别

答案：!!B!!

**4. Docker默认使用什么容器运行时？**
- A. rkt
- B. containerd
- C. LXC
- D. Podman

答案：!!B!!

**5. Docker镜像的存储驱动不包括以下哪个？** ***!***
- A. overlay2
- B. aufs
- C. devicemapper
- D. ntfs

答案：!!D!!

## 镜像原理与管理

**6. Docker镜像由什么组成？**
- A. 单个文件
- B. 多个只读层(layers)
- C. 可写层
- D. 压缩包

答案：!!B!!

**7. Docker镜像的分层结构有什么优势？**
- A. 增加镜像大小
- B. 共享层，节省存储空间和加速构建
- C. 减慢构建速度
- D. 没有优势

答案：!!B!!

**8. 如何查看镜像的历史层信息？** ***!***
- A. docker images
- B. docker inspect
- C. docker history
- D. docker layers

答案：!!C!!

**9. Docker镜像的命名格式是？** ***!***
- A. name:tag
- B. registry/name:tag
- C. registry/namespace/name:tag
- D. 以上都可能

答案：!!D!!

**10. 如何删除所有未使用的镜像？** ***!***
- A. docker rmi -a
- B. docker image prune -a
- C. docker remove images
- D. docker clean images

答案：!!B!!

## Dockerfile最佳实践

**11. Dockerfile中的FROM指令作用是什么？**
- A. 指定工作目录
- B. 指定基础镜像
- C. 复制文件
- D. 运行命令

答案：!!B!!

**12. RUN、CMD和ENTRYPOINT的区别是？** ***!***
- A. 完全相同
- B. RUN在构建时执行，CMD和ENTRYPOINT在运行时执行
- C. 只有名称不同
- D. RUN在运行时执行

答案：!!B!!

**13. CMD和ENTRYPOINT的区别是？**
- A. 没有区别
- B. CMD容易被覆盖，ENTRYPOINT不容易被覆盖
- C. ENTRYPOINT容易被覆盖
- D. 两者都不能被覆盖

答案：!!B!!

**14. COPY和ADD指令的区别是？**
- A. 完全相同
- B. ADD支持URL和自动解压tar文件，COPY只复制本地文件
- C. COPY功能更多
- D. 没有区别

答案：!!B!!

**15. Dockerfile中应该使用哪个指令设置工作目录？**
- A. CD
- B. WORKDIR
- C. DIR
- D. PWD

答案：!!B!!

**16. 为了减小镜像大小，Dockerfile的最佳实践是？**
- A. 使用多个RUN指令
- B. 合并RUN指令，清理缓存，使用多阶段构建
- C. 使用最大的基础镜像
- D. 不清理临时文件

答案：!!B!!

**17. 多阶段构建的主要优势是？**
- A. 增加构建时间
- B. 减小最终镜像大小
- C. 增加镜像层数
- D. 没有优势

答案：!!B!!

**18. .dockerignore文件的作用是？**
- A. 忽略镜像
- B. 排除不需要添加到镜像的文件
- C. 忽略容器
- D. 配置网络

答案：!!B!!

**19. Dockerfile中的EXPOSE指令作用是？** ***!***
- A. 自动映射端口
- B. 声明容器监听的端口（文档作用）
- C. 打开防火墙
- D. 创建网络

答案：!!B!!

**20. ARG和ENV的区别是？**
- A. 完全相同
- B. ARG只在构建时有效，ENV在运行时也有效
- C. ENV只在构建时有效
- D. 没有区别

答案：!!B!!

## 容器生命周期

**21. docker run的作用是？**
- A. 只创建容器
- B. 创建并启动容器
- C. 只启动已有容器
- D. 删除容器

答案：!!B!!

**22. docker start和docker run的区别是？**
- A. 完全相同
- B. docker run创建新容器，docker start启动已有容器
- C. docker start创建新容器
- D. 没有区别

答案：!!B!!

**23. 如何在后台运行容器？** ***!***
- A. docker run &lt;image&gt;
- B. docker run -d &lt;image&gt;
- C. docker run -b &lt;image&gt;
- D. docker run --background &lt;image&gt;

答案：!!B!!

**24. 容器停止后，容器内的数据会怎样？**
- A. 立即删除
- B. 保留在容器中，除非删除容器
- C. 自动备份
- D. 移动到主机

答案：!!B!!

**25. docker rm和docker rmi的区别是？**
- A. 完全相同
- B. docker rm删除容器，docker rmi删除镜像
- C. docker rm删除镜像
- D. 没有区别

答案：!!B!!

**26. 如何查看正在运行的容器？**
- A. docker ps
- B. docker container ls
- C. 两者都可以
- D. docker list

答案：!!C!!

**27. 如何查看包括已停止的所有容器？** ***!***
- A. docker ps -a
- B. docker ps --all
- C. 两者都可以
- D. docker ps -s

答案：!!C!!

**28. 如何进入正在运行的容器？** ***!***
- A. docker attach &lt;container&gt;
- B. docker exec -it &lt;container&gt; /bin/bash
- C. 两者都可以，但exec更常用
- D. docker ssh &lt;container&gt;

答案：!!C!!

**29. docker stop和docker kill的区别是？**
- A. 完全相同
- B. docker stop发送SIGTERM后SIGKILL，docker kill直接发送SIGKILL
- C. docker kill更温和
- D. 没有区别

答案：!!B!!

**30. 容器的重启策略不包括以下哪个？**
- A. no
- B. always
- C. on-failure
- D. on-demand

答案：!!D!!

## 容器网络

**31. Docker的默认网络模式是？**
- A. host
- B. bridge
- C. none
- D. overlay

答案：!!B!!

**32. bridge网络模式的特点是？**
- A. 容器共享主机网络栈
- B. 容器有独立的网络命名空间，通过虚拟网桥通信
- C. 容器没有网络
- D. 只用于集群

答案：!!B!!

**33. host网络模式的特点是？**
- A. 容器有独立IP
- B. 容器共享主机的网络命名空间
- C. 容器没有网络
- D. 容器使用虚拟网络

答案：!!B!!

**34. 如何创建自定义网络？** ***!***
- A. docker network add
- B. docker network create
- C. docker create network
- D. docker new network

答案：!!B!!

**35. 容器之间如何通过容器名通信？**
- A. 使用IP地址
- B. 连接到同一个自定义网络，使用内置DNS解析
- C. 不能通过容器名
- D. 只能使用hosts文件

答案：!!B!!

**36. 如何将容器端口映射到主机端口？** ***!***
- A. docker run -p host_port:container_port
- B. docker run -P
- C. 两者都可以
- D. 不能映射

答案：!!C!!

**37. -p和-P参数的区别是？**
- A. 完全相同
- B. -p指定端口映射，-P随机映射所有EXPOSE的端口
- C. -P指定端口映射
- D. 没有区别

答案：!!B!!

**38. overlay网络主要用于什么场景？**
- A. 单机容器通信
- B. 跨主机的容器通信（集群）
- C. 容器访问外网
- D. 主机访问容器

答案：!!B!!

**39. 如何查看容器的IP地址？**
- A. docker inspect &lt;container&gt; | grep IPAddress
- B. docker network inspect
- C. 两者都可以
- D. docker ip &lt;container&gt;

答案：!!C!!

**40. macvlan网络模式的特点是？**
- A. 容器没有网络
- B. 容器获得物理网络的MAC地址和IP
- C. 容器共享主机网络
- D. 只用于overlay

答案：!!B!!

## 容器数据管理

**41. Docker的数据持久化方式包括哪些？**
- A. 只有Volume
- B. 只有Bind Mount
- C. Volume、Bind Mount和tmpfs
- D. 不支持持久化

答案：!!C!!

**42. Volume和Bind Mount的主要区别是？** ***!***
- A. 完全相同
- B. Volume由Docker管理，Bind Mount挂载主机路径
- C. Bind Mount由Docker管理
- D. 没有区别

答案：!!B!!

**43. 如何创建命名Volume？** ***!***
- A. docker volume add
- B. docker volume create
- C. docker create volume
- D. docker new volume

答案：!!B!!

**44. 如何将Volume挂载到容器？** ***!***
- A. docker run -v volume_name:/container/path
- B. docker run --mount source=volume_name,target=/container/path
- C. 两者都可以
- D. 不能挂载

答案：!!C!!

**45. tmpfs挂载的特点是？**
- A. 持久化存储
- B. 存储在内存中，容器停止后数据丢失
- C. 存储在磁盘
- D. 自动备份

答案：!!B!!

**46. 如何查看所有Volume？**
- A. docker volume list
- B. docker volume ls
- C. 两者都可以
- D. docker volumes

答案：!!C!!

**47. 删除未使用的Volume的命令是？**
- A. docker volume rm
- B. docker volume prune
- C. docker volume clean
- D. docker volume delete

答案：!!B!!

**48. Volume的优势不包括以下哪个？** ***!***
- A. 更容易备份和迁移
- B. 可以在多个容器间安全共享
- C. 减少容器大小
- D. Volume驱动支持远程存储

答案：!!C!!

**49. 容器内的数据默认存储在哪里？**
- A. 主机磁盘
- B. 容器的可写层
- C. Volume
- D. 内存

答案：!!B!!

**50. 容器删除后，挂载的命名Volume会被删除吗？**
- A. 会自动删除
- B. 不会自动删除
- C. 取决于容器配置
- D. 有时删除

答案：!!B!!

## Docker Compose

**51. Docker Compose的主要作用是？**
- A. 只创建单个容器
- B. 定义和运行多容器应用
- C. 只管理网络
- D. 只管理镜像

答案：!!B!!

**52. Docker Compose的配置文件默认名称是？**
- A. compose.yaml
- B. docker-compose.yml或docker-compose.yaml
- C. config.yml
- D. docker.yml

答案：!!B!!

**53. 如何启动Compose定义的所有服务？**
- A. docker-compose start
- B. docker-compose up
- C. docker-compose run
- D. docker-compose create

答案：!!B!!

**54. docker-compose up -d的作用是？** ***!***
- A. 前台运行
- B. 后台运行
- C. 调试模式
- D. 删除服务

答案：!!B!!

**55. 如何停止并删除Compose创建的所有资源？**
- A. docker-compose stop
- B. docker-compose down
- C. docker-compose remove
- D. docker-compose delete

答案：!!B!!

**56. Compose文件的版本字段作用是？**
- A. 指定应用版本
- B. 指定Compose文件格式版本
- C. 指定Docker版本
- D. 没有作用

答案：!!B!!

**57. Compose中如何指定服务依赖关系？** ***!***
- A. links
- B. depends_on
- C. 两者都可以
- D. 不能指定

答案：!!C!!

**58. 如何查看Compose管理的服务状态？**
- A. docker-compose status
- B. docker-compose ps
- C. docker-compose list
- D. docker-compose show

答案：!!B!!

**59. Compose中如何扩展服务实例数量？**
- A. docker-compose scale service=3
- B. docker-compose up --scale service=3
- C. 两者都可以
- D. 不能扩展

答案：!!C!!

**60. 如何查看Compose服务的日志？**
- A. docker-compose log
- B. docker-compose logs
- C. docker-compose show logs
- D. docker-compose view

答案：!!B!!

## 容器资源限制

**61. 如何限制容器的CPU使用？**
- A. --cpu
- B. --cpus或--cpu-shares
- C. --cpu-limit
- D. 不能限制

答案：!!B!!

**62. --cpus=2表示什么？**
- A. 使用2号CPU
- B. 最多使用2个CPU核心
- C. 使用2%的CPU
- D. 创建2个容器

答案：!!B!!

**63. 如何限制容器的内存使用？** ***!***
- A. --memory或-m
- B. --mem
- C. --ram
- D. 不能限制

答案：!!A!!

**64. 容器超过内存限制会发生什么？**
- A. 自动扩展内存
- B. 容器被OOM Killer杀死
- C. 只记录日志
- D. 什么都不发生

答案：!!B!!

**65. --memory-swap的作用是什么？**
- A. 禁用内存
- B. 设置内存和交换分区的总限制
- C. 只设置交换分区
- D. 没有作用

答案：!!B!!

**66. 如何限制容器的磁盘IO？**
- A. --device-read-bps和--device-write-bps
- B. --disk-limit
- C. --io-limit
- D. 不能限制

答案：!!A!!

**67. --pids-limit的作用是什么？**
- A. 限制CPU
- B. 限制容器可以创建的进程数
- C. 限制内存
- D. 限制网络

答案：!!B!!

**68. 如何实时查看容器的资源使用情况？** ***!***
- A. docker status
- B. docker stats
- C. docker top
- D. docker monitor

答案：!!B!!

**69. --cpu-shares的作用是？** ***!***
- A. 设置CPU绝对限制
- B. 设置CPU相对权重
- C. 禁用CPU
- D. 没有作用

答案：!!B!!

**70. 资源限制对容器性能的影响是？**
- A. 总是降低性能
- B. 防止资源争抢，保护系统稳定性
- C. 没有影响
- D. 只影响网络

答案：!!B!!

## 容器安全

**71. 容器默认以什么用户运行？** ***!***
- A. 普通用户
- B. root用户
- C. docker用户
- D. 随机用户

答案：!!B!!

**72. 如何以非root用户运行容器？**
- A. --user &lt;uid&gt;:&lt;gid&gt;或在Dockerfile中使用USER指令
- B. --non-root
- C. --safe-mode
- D. 不能实现

答案：!!A!!

**73. --privileged参数的作用是什么？**
- A. 降低权限
- B. 给容器几乎所有主机权限（不安全）
- C. 只增加网络权限
- D. 没有作用

答案：!!B!!

**74. --read-only参数的作用是？**
- A. 禁止读取
- B. 将容器的根文件系统设为只读
- C. 只读取镜像
- D. 没有作用

答案：!!B!!

**75. --cap-drop和--cap-add的作用是？**
- A. 管理网络
- B. 删除或添加Linux capabilities
- C. 管理存储
- D. 没有作用

答案：!!B!!

**76. Docker Content Trust的作用是什么？**
- A. 管理容器
- B. 验证镜像签名，确保镜像来源可信
- C. 只管理网络
- D. 没有作用

答案：!!B!!

**77. 如何扫描镜像漏洞？**
- A. docker scan &lt;image&gt;
- B. 使用第三方工具如Trivy、Clair
- C. 两者都可以
- D. 不能扫描

答案：!!C!!

**78. Seccomp的作用是什么？**
- A. 管理网络
- B. 限制容器可以使用的系统调用
- C. 管理存储
- D. 没有作用

答案：!!B!!

**79. AppArmor和SELinux的作用是？**
- A. 加速容器
- B. 提供强制访问控制(MAC)
- C. 只管理网络
- D. 没有作用

答案：!!B!!

**80. 容器安全的最佳实践不包括？**
- A. 使用官方镜像
- B. 以root用户运行所有容器
- C. 定期更新镜像
- D. 限制容器资源

答案：!!B!!

## 容器日志与调试

**81. 如何查看容器日志？**
- A. docker log
- B. docker logs &lt;container&gt;
- C. docker view logs
- D. docker show logs

答案：!!B!!

**82. docker logs -f的作用是？**
- A. 查看前10行
- B. 实时跟踪日志输出
- C. 过滤日志
- D. 删除日志

答案：!!B!!

**83. docker logs --tail 100的作用是？**
- A. 查看前100行
- B. 查看最后100行
- C. 删除100行
- D. 没有作用

答案：!!B!!

**84. 容器的日志驱动不包括以下哪个？**
- A. json-file
- B. syslog
- C. journald
- D. mysql

答案：!!D!!

**85. 如何查看容器内运行的进程？**
- A. docker ps
- B. docker top &lt;container&gt;
- C. docker processes
- D. docker list

答案：!!B!!

**86. docker inspect的作用是？**
- A. 删除容器
- B. 查看容器或镜像的详细配置信息
- C. 启动容器
- D. 只查看日志

答案：!!B!!

**87. 如何从容器中复制文件到主机？**
- A. docker cp &lt;container&gt;:&lt;src_path&gt; &lt;dest_path&gt;
- B. docker copy
- C. docker export
- D. 不能复制

答案：!!A!!

**88. docker diff的作用是？** ***!***
- A. 比较两个镜像
- B. 查看容器文件系统的变化
- C. 比较两个容器
- D. 没有作用

答案：!!B!!

**89. 如何将容器导出为tar文件？** ***!***
- A. docker save
- B. docker export
- C. docker backup
- D. docker archive

答案：!!B!!

**90. docker save和docker export的区别是？**
- A. 完全相同
- B. docker save保存镜像（含历史），docker export导出容器（当前状态）
- C. docker save导出容器
- D. 没有区别

答案：!!B!!

## 镜像仓库与分发

**91. Docker Hub是什么？**
- A. Docker的开发工具
- B. Docker的公共镜像仓库
- C. Docker的配置文件
- D. Docker的网络组件

答案：!!B!!

**92. 如何登录Docker Hub？**
- A. docker signin
- B. docker login
- C. docker auth
- D. docker connect

答案：!!B!!

**93. 如何推送镜像到仓库？**
- A. docker upload
- B. docker push &lt;image&gt;
- C. docker send
- D. docker deploy

答案：!!B!!

**94. 如何从仓库拉取镜像？**
- A. docker download
- B. docker pull &lt;image&gt;
- C. docker get
- D. docker fetch

答案：!!B!!

**95. 搭建私有镜像仓库可以使用什么？**
- A. Docker Registry
- B. Harbor
- C. Nexus
- D. 以上都可以

答案：!!D!!

**96. 如何给镜像打标签？**
- A. docker tag &lt;source&gt; &lt;target&gt;
- B. docker label
- C. docker rename
- D. docker mark

答案：!!A!!

**97. 镜像的完整标识格式是？**
- A. name:tag
- B. registry/namespace/repository:tag
- C. repository:tag
- D. 随意格式

答案：!!B!!

**98. 如何搜索Docker Hub上的镜像？** ***!***
- A. docker find
- B. docker search &lt;keyword&gt;
- C. docker query
- D. docker lookup

答案：!!B!!

## 高级特性与最佳实践

**99. Docker的多阶段构建主要解决什么问题？**
- A. 加快运行速度
- B. 减小最终镜像大小，分离构建和运行环境
- C. 增加安全性
- D. 没有作用

答案：!!B!!

**100. 生产环境中Docker的最佳实践不包括？**
- A. 使用latest标签
- B. 设置资源限制
- C. 定期更新镜像
- D. 使用健康检查

答案：!!A!!

### 评分标准

- 90-100分：优秀，对Docker核心概念掌握扎实
- 80-89分：良好，大部分核心知识点已掌握
- 70-79分：中等，需要加强部分知识点的学习
- 60-69分：及格，建议系统复习相关文档
- 60分以下：需要重新学习Docker基础知识

## 简答

### 请简述 Docker 的核心组件（Docker Engine、Docker Client、Docker Registry、Containerd 等）及各自作用。

#### 1. **Docker Engine**
Docker 的核心引擎,负责容器的整体运行环境。它包含三个主要部分:
- **Docker Daemon (dockerd)**: 后台服务进程,负责管理容器、镜像、网络和存储卷
- **REST API**: 提供程序与 daemon 交互的接口
- **CLI 客户端**: 命令行工具,通过 API 与 daemon 通信

#### 2. **Docker Client**
用户与 Docker 交互的主要方式,即 `docker` 命令行工具。当你执行 `docker run`、`docker build` 等命令时,客户端会将这些命令发送给 Docker daemon 执行。客户端可以与本地或远程的 daemon 通信。

#### 3. **Docker Registry**
镜像的存储和分发系统:
- **Docker Hub**: Docker 官方的公共镜像仓库
- **私有 Registry**: 企业可搭建自己的镜像仓库
- 作用是存储、管理和分发 Docker 镜像,支持 `docker pull` 和 `docker push` 操作

#### 4. **Containerd**
高级容器运行时,从 Docker 1.11 开始独立出来:
- 管理容器的生命周期(创建、启动、停止、删除)
- 镜像管理和传输
- 网络和存储管理
- 作为 Docker Engine 和底层运行时(如 runc)之间的中间层

#### 5. **runc**
OCI (开放容器倡议)标准的容器运行时实现:
- 负责实际创建和运行容器进程
- 处理 Linux namespace、cgroups 等底层隔离机制
- containerd 调用 runc 来启动容器

#### 组件协作流程
```
用户命令 → Docker Client → Docker Daemon → Containerd → runc → 容器运行
                                    ↓
                              Docker Registry (拉取/推送镜像)
```

这种分层架构使得 Docker 更加模块化,各组件可独立升级和维护,同时也符合容器标准化的趋势。

### Docker 容器和虚拟机（VM）的核心区别是什么？为什么 Docker 更轻量？

#### 1. 架构层面的根本差异

**虚拟机 (VM)**:
- 在物理硬件上运行 Hypervisor (如 VMware、VirtualBox)
- 每个 VM 包含完整的操作系统 (Guest OS)
- 应用运行在 Guest OS 之上
- 架构: 硬件 → Hypervisor → Guest OS → 应用

**Docker 容器**:
- 直接运行在宿主机操作系统上
- 共享宿主机的内核
- 只包含应用及其依赖库
- 架构: 硬件 → Host OS → Docker Engine → 容器

#### 2. 为什么 Docker 更轻量

**资源占用方面**:
- VM 每个实例需要完整 OS,通常占用几 GB 到几十 GB,启动需要数分钟
- 容器只包含应用层,镜像通常几十 MB 到几百 MB,启动只需几秒甚至毫秒
- 同样硬件可运行几十个 VM,但可运行成百上千个容器

**隔离机制**:
- VM 通过硬件虚拟化实现完全隔离,开销大但安全性高
- 容器通过 Linux namespace 和 cgroups 实现进程级隔离,共享内核,开销小但隔离性相对弱

**性能表现**:
- VM 存在硬件虚拟化开销,性能有一定损耗
- 容器几乎没有性能损耗,接近原生运行速度

#### 3. 核心区别总结

| 特性 | 虚拟机 | Docker 容器 |
|------|--------|------------|
| 操作系统 | 每个 VM 独立 OS | 共享宿主机内核 |
| 启动时间 | 分钟级 | 秒级/毫秒级 |
| 资源占用 | GB 级别 | MB 级别 |
| 隔离级别 | 完全隔离 | 进程级隔离 |
| 性能 | 有虚拟化损耗 | 接近原生 |

Docker 的轻量源于它不需要虚拟化硬件和完整操作系统,而是通过操作系统级别的虚拟化技术实现应用隔离,这使得它在资源利用率、启动速度和部署密度上都远超传统虚拟机。

### Docker 镜像的分层结构是怎样的？分层机制带来了哪些优势（如镜像复用、体积优化）？

#### 1. 分层结构原理

Docker 镜像采用 **Union File System (联合文件系统)** 技术,由多个只读层堆叠而成:

**镜像层次结构**:
- **Base Layer (基础层)**: 通常是操作系统镜像,如 Ubuntu、Alpine
- **中间层**: 每条 Dockerfile 指令(RUN、COPY、ADD 等)都会创建新的一层
- **顶层**: 最终的应用层
- **容器层**: 运行时在镜像之上添加的可写层(Container Layer)

**示例 Dockerfile 的分层**:
```dockerfile
FROM ubuntu:20.04          # Layer 1: 基础镜像层
RUN apt-get update         # Layer 2: 更新包列表
RUN apt-get install -y nginx  # Layer 3: 安装 nginx
COPY index.html /var/www/  # Layer 4: 复制文件
CMD ["nginx"]              # Layer 5: 元数据层(不增加体积)
```

每一层都是只读的,通过层 ID (SHA256 哈希值)唯一标识。

#### 2. 分层机制的核心优势

**镜像复用**:
- 多个镜像可以共享相同的基础层,例如多个应用都基于 `ubuntu:20.04`,这个基础层只需存储一份
- 构建新镜像时,已存在的层会被缓存复用,不需要重新下载或构建
- 大幅节省存储空间和网络带宽

**体积优化**:
- 只传输和存储发生变化的层,而非整个镜像
- 使用 `.dockerignore` 和优化 Dockerfile 可减少不必要的层
- 多阶段构建可以丢弃中间层,只保留最终产物

**加速构建和分发**:
- 构建时利用缓存机制,未修改的层直接使用缓存,只重建变化的层
- Pull 镜像时并行下载各层,已存在的层跳过下载
- Push 镜像时只上传新增或修改的层

**版本管理**:
- 每层都有唯一标识,便于追溯和回滚
- 不同版本的镜像可以共享大部分相同的层
- 方便实现镜像的增量更新

#### 3. 写时复制 (Copy-on-Write) 机制

容器运行时:
- 所有镜像层保持只读
- 在顶部添加可写的容器层
- 修改文件时,从只读层复制到可写层再修改
- 删除容器后,可写层被删除,镜像层不受影响

#### 4. 最佳实践示例

**优化前**:
```dockerfile
RUN apt-get update
RUN apt-get install -y package1
RUN apt-get install -y package2
```
这会创建 3 个独立层,每层都包含 apt 缓存。

**优化后**:
```dockerfile
RUN apt-get update && \
    apt-get install -y package1 package2 && \
    rm -rf /var/lib/apt/lists/*
```
合并为 1 层,并清理缓存,减小镜像体积。

分层机制使 Docker 镜像既高效又灵活,是 Docker 生态系统快速发展的关键技术基础之一。

4. 什么是 Dockerfile？请列出至少 8 个常用的 Dockerfile 指令，并说明其作用（如 FROM、RUN、COPY、CMD、ENTRYPOINT 等）。

### Dockerfile 及常用指令详解

Dockerfile 是一个文本文件,包含一系列指令和参数,用于自动化构建 Docker 镜像。它定义了镜像的基础环境、依赖安装、文件复制、环境配置等所有步骤。通过 `docker build` 命令可以根据 Dockerfile 生成镜像。

#### 常用 Dockerfile 指令

**FROM - 指定基础镜像**:
- 作用: 定义构建的基础镜像,必须是 Dockerfile 的第一条指令(除了 ARG)
- 语法: `FROM <image>:<tag>`
- 示例: `FROM ubuntu:20.04` 或 `FROM node:16-alpine`

**RUN - 执行命令**:
- 作用: 在镜像构建过程中执行命令,常用于安装软件包、编译代码
- 每个 RUN 指令会创建新的镜像层
- 语法: `RUN <command>` 或 `RUN ["executable", "param1", "param2"]`
- 示例: `RUN apt-get update && apt-get install -y nginx`

**COPY - 复制文件**:
- 作用: 从构建上下文复制文件或目录到镜像中
- 语法: `COPY <src> <dest>`
- 示例: `COPY ./app /usr/src/app` 或 `COPY package*.json ./`
- 特点: 只支持本地文件复制,不解压压缩包

**ADD - 添加文件**:
- 作用: 类似 COPY,但功能更强大
- 语法: `ADD <src> <dest>`
- 示例: `ADD app.tar.gz /usr/src/`
- 特点: 支持 URL 下载,自动解压 tar/gzip 等压缩文件
- 建议: 优先使用 COPY,除非需要 ADD 的特殊功能

**WORKDIR - 设置工作目录**:
- 作用: 为后续的 RUN、CMD、ENTRYPOINT、COPY、ADD 指令设置工作目录
- 语法: `WORKDIR <path>`
- 示例: `WORKDIR /usr/src/app`
- 特点: 目录不存在时会自动创建,可多次使用切换目录

**CMD - 容器启动命令**:
- 作用: 指定容器启动时执行的默认命令
- 语法: `CMD ["executable","param1","param2"]` (推荐) 或 `CMD command param1 param2`
- 示例: `CMD ["nginx", "-g", "daemon off;"]`
- 特点: 可被 `docker run` 后的参数覆盖,一个 Dockerfile 只有最后一个 CMD 生效

**ENTRYPOINT - 入口点**:
- 作用: 配置容器启动时运行的命令,不会被 `docker run` 参数覆盖
- 语法: `ENTRYPOINT ["executable", "param1", "param2"]`
- 示例: `ENTRYPOINT ["python", "app.py"]`
- 特点: `docker run` 的参数会追加到 ENTRYPOINT 后,常与 CMD 组合使用

**ENV - 设置环境变量**:
- 作用: 设置环境变量,在构建和运行时都可用
- 语法: `ENV <key>=<value>` 或 `ENV <key> <value>`
- 示例: `ENV NODE_ENV=production` 或 `ENV PATH=/usr/local/bin:$PATH`
- 特点: 可在后续指令中使用 `$变量名` 引用

**EXPOSE - 声明端口**:
- 作用: 声明容器运行时监听的网络端口
- 语法: `EXPOSE <port> [<port>/<protocol>...]`
- 示例: `EXPOSE 80` 或 `EXPOSE 8080/tcp 9090/udp`
- 特点: 仅作为文档说明,不会实际发布端口,需配合 `docker run -p` 使用

**VOLUME - 挂载卷**:
- 作用: 创建挂载点,用于持久化数据或共享数据
- 语法: `VOLUME ["<path>"]` 或 `VOLUME <path>`
- 示例: `VOLUME ["/data", "/var/log"]`
- 特点: 运行时会自动创建匿名卷,除非使用 `-v` 指定

**ARG - 构建参数**:
- 作用: 定义构建时的变量,仅在构建过程中有效
- 语法: `ARG <name>[=<default value>]`
- 示例: `ARG VERSION=1.0`
- 特点: 可通过 `docker build --build-arg VERSION=2.0` 传入,不会保留在最终镜像中

**LABEL - 添加元数据**:
- 作用: 为镜像添加元数据标签
- 语法: `LABEL <key>=<value>`
- 示例: `LABEL version="1.0" maintainer="user@example.com"`
- 特点: 便于镜像管理和筛选

#### 3. 完整示例

```dockerfile
# 基础镜像
FROM node:16-alpine

# 构建参数
ARG APP_VERSION=1.0.0

# 设置元数据
LABEL version="${APP_VERSION}" \
      description="My Node.js App"

# 设置环境变量
ENV NODE_ENV=production \
    PORT=3000

# 设置工作目录
WORKDIR /app

# 复制依赖文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production

# 复制应用代码
COPY . .

# 声明端口
EXPOSE 3000

# 创建数据卷
VOLUME ["/app/data"]

# 设置启动命令
ENTRYPOINT ["node"]
CMD ["server.js"]
```

通过合理使用这些指令,可以构建出高效、可维护的 Docker 镜像。

### Docker 容器的网络模式有哪些？（bridge、host、none、container）分别适用于什么场景？

#### 1. Bridge 模式（桥接模式）

**工作原理**:
- Docker 默认的网络模式
- 创建虚拟网桥 `docker0`,容器连接到该网桥
- 每个容器分配独立的 IP 地址（通常在 172.17.0.0/16 网段）
- 容器通过 NAT 访问外部网络
- 容器间可通过 IP 或容器名（需自定义网络）通信

**使用方式**:
```bash
docker run --network bridge <image>
# 或不指定（默认就是 bridge）
docker run <image>
```

**适用场景**:
- 大多数单机容器应用的默认选择
- 需要容器间相互通信的微服务架构
- 需要端口映射将服务暴露给宿主机
- 对网络隔离有一定要求的应用

**优势**: 提供网络隔离,容器有独立 IP,安全性较好

**劣势**: 存在 NAT 转换,性能略有损耗

#### 2. Host 模式（主机模式）

**工作原理**:
- 容器不创建独立的网络命名空间
- 直接使用宿主机的网络栈
- 容器与宿主机共享 IP 地址和端口
- 无需端口映射,容器监听的端口直接在宿主机上监听

**使用方式**:
```bash
docker run --network host <image>
```

**适用场景**:
- 对网络性能要求极高的应用
- 需要处理大量网络流量的服务（如负载均衡器、网络监控工具）
- 需要直接访问宿主机网络接口的应用
- 容器需要绑定宿主机特定端口且不希望冲突管理复杂化

**优势**: 网络性能最佳,无 NAT 开销,延迟最低

**劣势**: 
- 端口冲突风险高
- 网络隔离性差,安全性较低
- 在 Windows 和 macOS 的 Docker Desktop 中不可用

#### 3. None 模式（无网络模式）

**工作原理**:
- 容器拥有独立的网络命名空间
- 但不配置任何网络接口（除了 loopback）
- 容器完全与外界网络隔离
- 只能通过 `docker exec` 进入容器操作

**使用方式**:
```bash
docker run --network none <image>
```

**适用场景**:
- 需要最大程度网络隔离的安全敏感应用
- 批处理任务,不需要网络通信
- 后续需要手动配置自定义网络的场景
- 测试或调试不依赖网络的应用逻辑

**优势**: 安全性最高,完全隔离

**劣势**: 无法进行网络通信,使用场景有限

#### 4. Container 模式（容器模式）

**工作原理**:
- 新容器与已存在的容器共享网络命名空间
- 共享相同的 IP 地址、端口范围和网络配置
- 两个容器间通过 `localhost` 直接通信
- 类似 Kubernetes 中 Pod 内多容器的网络模型

**使用方式**:
```bash
# 先启动一个容器
docker run -d --name container1 nginx

# 新容器共享 container1 的网络
docker run --network container:container1 <image>
```

**适用场景**:
- 需要多个容器紧密协作,频繁通信（如应用容器 + 边车容器）
- 网络监控容器需要监听主应用容器的流量
- 日志收集容器与应用容器共享网络
- 实现类似 Kubernetes sidecar 模式

**优势**: 容器间通信无网络开销,延迟极低

**劣势**: 
- 端口冲突管理需注意
- 容器间依赖性强,不够灵活

#### 5. 自定义网络（User-defined Networks）

除了上述模式,Docker 还支持创建自定义网络:

```bash
# 创建自定义桥接网络
docker network create mynetwork

# 容器加入自定义网络
docker run --network mynetwork --name app1 <image>
docker run --network mynetwork --name app2 <image>
```

**优势**:
- 容器间可通过容器名直接通信（内置 DNS 解析）
- 更好的网络隔离和管理
- 支持连接/断开网络的动态操作

#### 6. 网络模式对比总结

| 网络模式 | 隔离性 | 性能 | 使用复杂度 | 典型场景 |
|---------|--------|------|-----------|----------|
| Bridge | 中 | 中 | 低 | 常规应用（默认） |
| Host | 低 | 高 | 低 | 高性能网络服务 |
| None | 高 | N/A | 中 | 安全隔离/批处理 |
| Container | 低 | 高 | 中 | 紧密协作的容器组 |

选择合适的网络模式需要根据应用的性能需求、安全要求和部署架构来综合考虑。对于大多数应用,使用默认的 Bridge 模式或自定义网络即可满足需求。

### Docker 的数据卷（Volume）和挂载（Bind Mount）的区别是什么？如何实现容器数据持久化？

#### 1. 数据卷（Volume）

**基本概念**:
- 由 Docker 管理的特殊目录,存储在宿主机的 Docker 存储目录中（Linux 下通常是 `/var/lib/docker/volumes/`）
- 完全由 Docker 管理生命周期
- 是 Docker 推荐的持久化数据的首选方式

**创建和使用**:
```bash
# 创建命名卷
docker volume create mydata

# 查看所有卷
docker volume ls

# 查看卷详情
docker volume inspect mydata

# 使用卷
docker run -v mydata:/app/data nginx
# 或使用 --mount 语法（更明确）
docker run --mount source=mydata,target=/app/data nginx

# 删除卷
docker volume rm mydata
```

**特点**:
- 独立于容器生命周期,删除容器不会删除卷（除非使用 `docker rm -v`）
- 可在多个容器间共享和重用
- 支持卷驱动程序,可存储到远程主机或云存储
- 更容易备份和迁移
- 新卷的内容可以由容器预填充

**适用场景**:
- 数据库数据持久化
- 应用配置文件
- 日志文件存储
- 需要在多个容器间共享的数据
- 生产环境的数据持久化

#### 2. 挂载（Bind Mount）

**基本概念**:
- 直接将宿主机的文件或目录挂载到容器中
- 需要指定宿主机的绝对路径
- 早期 Docker 版本的主要数据共享方式

**使用方式**:
```bash
# 挂载宿主机目录
docker run -v /host/path:/container/path nginx

# 使用 --mount 语法（推荐）
docker run --mount type=bind,source=/host/path,target=/container/path nginx

# 只读挂载
docker run -v /host/path:/container/path:ro nginx
docker run --mount type=bind,source=/host/path,target=/container/path,readonly nginx
```

**特点**:
- 依赖宿主机的文件系统结构
- 宿主机上的进程可以直接修改这些文件
- 路径必须是绝对路径
- 性能较好,无额外抽象层
- 宿主机文件会覆盖容器中的同名文件

**适用场景**:
- 开发环境下的代码热更新（实时同步代码修改）
- 共享配置文件（如 nginx.conf）
- 需要直接访问宿主机特定文件或目录
- 调试和开发阶段

#### 3. tmpfs 挂载（临时文件系统）

**基本概念**:
- 数据存储在宿主机内存中,不写入文件系统
- 容器停止后数据丢失

**使用方式**:
```bash
docker run --tmpfs /app/cache:rw,size=100m nginx
# 或
docker run --mount type=tmpfs,target=/app/cache,tmpfs-size=104857600 nginx
```

**适用场景**:
- 临时缓存数据
- 敏感信息（不希望持久化到磁盘）
- 需要高速 I/O 的临时数据

#### 4. Volume 与 Bind Mount 核心区别

| 特性 | Volume（数据卷） | Bind Mount（挂载） |
|------|-----------------|-------------------|
| **管理方式** | Docker 完全管理 | 依赖宿主机文件系统 |
| **存储位置** | Docker 目录（/var/lib/docker/volumes/） | 宿主机任意路径 |
| **路径指定** | 卷名或自动生成 | 必须是绝对路径 |
| **可移植性** | 高,跨平台一致 | 低,依赖宿主机路径 |
| **初始内容** | 可从容器预填充 | 宿主机文件覆盖容器 |
| **备份/迁移** | 通过 Docker 命令管理 | 需手动操作文件系统 |
| **性能** | 略有抽象层开销 | 直接访问,性能最好 |
| **安全性** | Docker 隔离管理 | 宿主机进程可直接修改 |
| **使用建议** | 生产环境推荐 | 开发环境推荐 |

#### 5. 数据持久化最佳实践

**使用 Volume 持久化数据库**:
```bash
# MySQL 示例
docker run -d \
  --name mysql \
  -v mysql-data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=secret \
  mysql:8.0
```

**使用 Bind Mount 开发环境**:
```bash
# Node.js 开发示例
docker run -d \
  --name dev-app \
  -v $(pwd)/src:/app/src \
  -v $(pwd)/package.json:/app/package.json \
  -p 3000:3000 \
  node:16
```

**组合使用**:
```bash
docker run -d \
  --name webapp \
  -v app-data:/app/data \              # Volume 存储数据
  -v $(pwd)/config:/app/config:ro \    # Bind Mount 配置文件（只读）
  -v logs:/var/log \                   # Volume 存储日志
  myapp:latest
```

**数据备份**:
```bash
# 备份 Volume
docker run --rm \
  -v mysql-data:/data \
  -v $(pwd):/backup \
  alpine tar czf /backup/mysql-backup.tar.gz /data

# 恢复 Volume
docker run --rm \
  -v mysql-data:/data \
  -v $(pwd):/backup \
  alpine tar xzf /backup/mysql-backup.tar.gz -C /
```

**Dockerfile 中声明**:
```dockerfile
# 声明卷（运行时会创建匿名卷或使用命名卷）
VOLUME ["/app/data", "/var/log"]
```

#### 6. 选择建议

**使用 Volume 当**:
- 生产环境部署
- 需要跨容器共享数据
- 需要 Docker 管理数据生命周期
- 需要使用卷驱动（网络存储、云存储）

**使用 Bind Mount 当**:
- 本地开发,需要实时同步代码
- 需要精确控制宿主机文件位置
- 配置文件需要频繁修改
- 需要容器访问宿主机特定文件

通过合理使用 Volume 和 Bind Mount,可以有效实现 Docker 容器的数据持久化,确保数据安全和应用的可维护性。

### 简述 Docker 的资源限制机制（CPU、内存、磁盘 IO），如何给容器配置资源配额？

#### 1. 资源限制的底层原理

Docker 通过 Linux 内核的 **cgroups (Control Groups)** 机制实现资源限制和隔离:
- cgroups 可以限制、记录和隔离进程组使用的物理资源
- Docker 为每个容器创建独立的 cgroup
- 支持限制 CPU、内存、磁盘 I/O、网络等资源

#### 2. CPU 资源限制

**CPU 份额限制 (--cpu-shares)**:
- 设置容器使用 CPU 的相对权重,默认值为 1024
- 仅在 CPU 资源竞争时生效
- 语法: `--cpu-shares=<value>`

```bash
# 容器 A 获得 2 倍于容器 B 的 CPU 时间
docker run -d --cpu-shares=2048 --name app-a nginx
docker run -d --cpu-shares=1024 --name app-b nginx
```

**CPU 核心数限制 (--cpus)**:
- 限制容器最多使用的 CPU 核心数
- 可以是小数,如 0.5 表示半个核心
- 语法: `--cpus=<value>`

```bash
# 限制容器最多使用 1.5 个 CPU 核心
docker run -d --cpus=1.5 nginx

# 限制使用 0.5 个核心（50% CPU）
docker run -d --cpus=0.5 nginx
```

**指定 CPU 核心 (--cpuset-cpus)**:
- 绑定容器到特定的 CPU 核心
- 语法: `--cpuset-cpus=<cpu-list>`

```bash
# 容器只能在 CPU 0 和 1 上运行
docker run -d --cpuset-cpus=0,1 nginx

# 容器只能在 CPU 0-3 上运行
docker run -d --cpuset-cpus=0-3 nginx
```

**CPU 配额限制 (--cpu-period 和 --cpu-quota)**:
- `--cpu-period`: 设置 CPU 调度周期,默认 100000 微秒（100ms）
- `--cpu-quota`: 设置容器在周期内可使用的 CPU 时间
- 语法: `--cpu-quota=<value>`

```bash
# 限制容器在每 100ms 周期内最多使用 50ms CPU 时间（相当于 0.5 核心）
docker run -d --cpu-period=100000 --cpu-quota=50000 nginx
```

#### 3. 内存资源限制

**内存硬限制 (-m 或 --memory)**:
- 设置容器可使用的最大内存量
- 超过限制时,容器会被 OOM Killer 杀死
- 语法: `-m <value>` 或 `--memory=<value>`
- 单位: b, k, m, g

```bash
# 限制容器最多使用 512MB 内存
docker run -d -m 512m nginx

# 限制使用 2GB 内存
docker run -d --memory=2g mysql
```

**内存软限制 (--memory-reservation)**:
- 设置内存的软限制
- 在宿主机内存不足时,优先回收超过软限制的容器内存
- 应该小于硬限制

```bash
# 软限制 256MB,硬限制 512MB
docker run -d -m 512m --memory-reservation=256m nginx
```

**交换空间限制 (--memory-swap)**:
- 设置容器可使用的内存 + swap 总量
- `-1` 表示不限制 swap
- 如果不设置,默认为内存限制的 2 倍

```bash
# 内存 512MB,swap 512MB（总共 1GB）
docker run -d -m 512m --memory-swap=1g nginx

# 内存 512MB,禁用 swap
docker run -d -m 512m --memory-swap=512m nginx

# 内存 512MB,不限制 swap
docker run -d -m 512m --memory-swap=-1 nginx
```

**OOM 控制 (--oom-kill-disable)**:
- 禁用 OOM Killer,但必须同时设置内存限制
- 不建议在生产环境使用

```bash
docker run -d -m 512m --oom-kill-disable nginx
```

**内存 swappiness (--memory-swappiness)**:
- 设置容器使用 swap 的倾向,范围 0-100
- 0 表示尽量不使用 swap,100 表示积极使用 swap

```bash
# 减少 swap 使用
docker run -d -m 512m --memory-swappiness=0 nginx
```

#### 4. 磁盘 I/O 限制

**块设备权重 (--blkio-weight)**:
- 设置块设备 I/O 的相对权重,范围 10-1000,默认 500
- 仅在 I/O 竞争时生效

```bash
# 设置更高的 I/O 优先级
docker run -d --blkio-weight=600 nginx
```

**读写速率限制**:
- `--device-read-bps`: 限制读取速率（bytes per second）
- `--device-write-bps`: 限制写入速率
- `--device-read-iops`: 限制读取操作次数（I/O per second）
- `--device-write-iops`: 限制写入操作次数

```bash
# 限制 /dev/sda 读取速率为 10MB/s
docker run -d --device-read-bps /dev/sda:10mb nginx

# 限制写入速率为 5MB/s
docker run -d --device-write-bps /dev/sda:5mb nginx

# 限制读取 IOPS 为 1000
docker run -d --device-read-iops /dev/sda:1000 nginx

# 限制写入 IOPS 为 500
docker run -d --device-write-iops /dev/sda:500 nginx
```

#### 5. 其他资源限制

**进程数限制 (--pids-limit)**:
- 限制容器可创建的进程数

```bash
# 限制最多创建 100 个进程
docker run -d --pids-limit=100 nginx
```

**网络带宽限制**:
- Docker 原生不直接支持,需要使用 tc (traffic control) 工具
- 或使用第三方网络插件

#### 6. 综合配置示例

**Web 应用容器**:
```bash
docker run -d \
  --name webapp \
  --cpus=2 \                          # 最多 2 个 CPU 核心
  -m 1g \                             # 最多 1GB 内存
  --memory-reservation=512m \         # 软限制 512MB
  --memory-swap=2g \                  # 内存+swap 总共 2GB
  --blkio-weight=500 \                # 默认 I/O 权重
  --device-write-bps /dev/sda:10mb \  # 写入限制 10MB/s
  --pids-limit=200 \                  # 最多 200 进程
  nginx:latest
```

**数据库容器**:
```bash
docker run -d \
  --name mysql \
  --cpus=4 \                          # 4 核心
  --cpuset-cpus=0-3 \                 # 绑定到 CPU 0-3
  -m 4g \                             # 4GB 内存
  --memory-swap=4g \                  # 禁用 swap
  --memory-swappiness=0 \             # 不使用 swap
  --blkio-weight=800 \                # 更高 I/O 优先级
  --device-read-iops /dev/sda:2000 \  # 读取 IOPS 2000
  --device-write-iops /dev/sda:1000 \ # 写入 IOPS 1000
  -v mysql-data:/var/lib/mysql \
  mysql:8.0
```

#### 7. Docker Compose 中配置资源限制

```yaml
version: '3.8'
services:
  webapp:
    image: nginx
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
        reservations:
          cpus: '1'
          memory: 512M
    blkio_config:
      weight: 500
      device_write_bps:
        - path: /dev/sda
          rate: '10mb'
```

#### 8. 查看容器资源使用情况

```bash
# 实时查看容器资源使用
docker stats

# 查看特定容器
docker stats container-name

# 查看容器详细配置
docker inspect container-name | grep -A 20 "Memory\|Cpu"
```

#### 9. 资源限制最佳实践

**合理设置限制**:
- 根据应用实际需求设置,避免过度限制影响性能
- 为关键应用预留足够资源
- 在测试环境充分压测验证配置

**监控和调优**:
- 使用 `docker stats` 或监控工具（Prometheus + cAdvisor）持续监控
- 根据实际使用情况调整资源配额
- 关注 OOM 事件和 CPU 限流情况

**防止资源耗尽**:
- 生产环境必须设置内存限制,防止单个容器耗尽宿主机资源
- 合理设置 CPU 限制,避免某个容器独占 CPU
- 数据库等 I/O 密集型应用需特别关注磁盘 I/O 限制

通过合理配置资源限制,可以确保容器化应用的稳定性和可预测性,避免资源争抢导致的性能问题。

### 常用命令

**1. 拉取指定版本的镜像**
```bash
docker pull nginx:1.25.3
```

**2. 后台运行容器并配置端口映射和目录挂载**
```bash
docker run -d \
  --name nginx-container \
  -p 8080:80 \
  -v /opt/html:/usr/share/nginx/html \
  nginx:1.25.3
```

参数说明：
- `-d`: 后台运行
- `--name`: 为容器指定名称
- `-p 8080:80`: 将宿主机 8080 端口映射到容器 80 端口
- `-v /opt/html:/usr/share/nginx/html`: 挂载目录

**3. 进入正在运行的容器执行 bash**
```bash
docker exec -it nginx-container bash
```

或者使用容器 ID：
```bash
docker exec -it <容器ID> bash
```

**4. 查看容器资源使用情况**
```bash
# 实时查看所有容器的资源使用
docker stats

# 查看指定容器的资源使用
docker stats nginx-container

# 只显示一次统计信息（不持续刷新）
docker stats --no-stream
```

**5. 清理未使用的资源**
```bash
# 清理所有未使用的资源（镜像、容器、卷、网络）
docker system prune -a --volumes

# 分别清理
docker container prune  # 清理停止的容器
docker image prune -a   # 清理未使用的镜像
docker volume prune     # 清理未使用的卷
docker network prune    # 清理未使用的网络
```

**额外的实用命令：**
```bash
# 查看正在运行的容器
docker ps

# 查看所有容器（包括停止的）
docker ps -a

# 停止容器
docker stop nginx-container

# 删除容器
docker rm nginx-container
```

这些命令涵盖了 Docker 日常使用中最常见的操作场景。