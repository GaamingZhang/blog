---
date: 2026-01-06
author: Gaaming Zhang
isOriginal: false
article: true
category:
  - Redis
tag:
  - Redis
---

# 缓存穿透基本概念

## 1. 什么是缓存穿透？

缓存穿透（Cache Penetration）是指客户端请求的数据在缓存中不存在，并且在数据库中也不存在。这种情况下，每次请求都会穿透缓存直接访问数据库，导致数据库压力增大，严重时可能导致数据库服务不可用。

缓存穿透是缓存使用中常见的性能问题之一，尤其在恶意攻击场景下，攻击者会故意请求大量不存在的数据，从而达到消耗数据库资源的目的。

## 2. 缓存穿透的危害

### 2.1 数据库压力增大

由于每次请求都会穿透缓存直接访问数据库，当请求量较大时，数据库会面临巨大的查询压力，可能导致数据库连接耗尽、响应时间变长，甚至数据库服务宕机。

### 2.2 缓存失效

缓存穿透会导致缓存失去其应有的保护作用，无法减轻数据库的负载，系统性能会严重下降。

### 2.3 系统可用性降低

当数据库因压力过大而宕机时，整个系统的可用性会受到影响，用户无法正常访问服务。

### 2.4 经济损失

系统性能下降和可用性降低会直接影响用户体验，可能导致用户流失，给企业带来经济损失。

## 3. 缓存穿透的原因

### 3.1 业务逻辑问题

- **数据确实不存在**：客户端请求的数据在业务上本来就不存在，例如请求一个不存在的用户ID、商品ID等。
- **业务变更**：数据已经被删除或过期，但客户端仍然在请求这些数据。

### 3.2 恶意攻击

攻击者故意构造大量不存在的请求参数，例如使用随机生成的用户ID或商品ID，目的是消耗数据库资源，使系统无法正常提供服务。

### 3.3 缓存设计缺陷

- **缓存键设计不合理**：例如使用可以被轻易猜测或枚举的键。
- **缓存过滤机制缺失**：没有对请求参数进行有效性验证，直接将所有请求传递到缓存和数据库。

## 4. 缓存穿透的解决方案

### 4.1 布隆过滤器（Bloom Filter）

#### 4.1.1 原理

布隆过滤器是一种空间效率极高的概率性数据结构，用于判断一个元素是否在集合中。它可以快速判断一个请求的数据是否存在于数据库中，如果不存在则直接返回，避免穿透到数据库。

布隆过滤器的工作原理：
1. 初始化一个长度为m的位数组，所有位初始化为0。
2. 定义k个不同的哈希函数。
3. 当添加一个元素时，使用k个哈希函数计算元素的哈希值，将位数组中对应的位置设为1。
4. 当查询一个元素时，使用k个哈希函数计算元素的哈希值，检查位数组中对应的位置是否都为1：
   - 如果有任何一个位置为0，则元素一定不存在于集合中。
   - 如果所有位置都为1，则元素可能存在于集合中（存在一定的误判率）。

#### 4.1.2 实现

在Redis中，可以使用Redisson或Guava实现布隆过滤器：

**使用Redisson实现布隆过滤器：**

```java
// 1. 创建Redisson客户端
Config config = new Config();
config.useSingleServer().setAddress("redis://127.0.0.1:6379");
RedissonClient redisson = Redisson.create(config);

// 2. 获取布隆过滤器
RBloomFilter<String> bloomFilter = redisson.getBloomFilter("productIdBloomFilter");

// 3. 初始化布隆过滤器：预计元素数量为1000000，误判率为0.01
bloomFilter.tryInit(1000000L, 0.01);

// 4. 添加元素
bloomFilter.add("product:1001");
bloomFilter.add("product:1002");

// 5. 检查元素是否存在
boolean exists = bloomFilter.contains("product:1003");
if (exists) {
    // 可能存在，继续查询缓存和数据库
} else {
    // 一定不存在，直接返回
}
```

**使用Guava实现布隆过滤器：**

```java
// 1. 创建布隆过滤器：预计元素数量为1000000，误判率为0.01
BloomFilter<String> bloomFilter = BloomFilter.create(
    Funnels.stringFunnel(Charset.defaultCharset()),
    1000000,
    0.01
);

// 2. 添加元素
bloomFilter.put("product:1001");
bloomFilter.put("product:1002");

// 3. 检查元素是否存在
boolean exists = bloomFilter.mightContain("product:1003");
if (exists) {
    // 可能存在，继续查询缓存和数据库
} else {
    // 一定不存在，直接返回
}
```

#### 4.1.3 优缺点

**优点：**
- 空间效率高，占用内存小
- 查询速度快，时间复杂度为O(k)
- 可以有效防止缓存穿透

**缺点：**
- 存在误判率，无法100%准确判断元素是否存在
- 删除元素困难，需要重新构建布隆过滤器
- 不支持元素数量的动态扩展

### 4.2 缓存空值

#### 4.2.1 原理

当请求的数据在数据库中不存在时，将一个空值或特殊标记缓存起来，并设置一个较短的过期时间。这样，后续相同的请求会直接从缓存中获取空值，而不会穿透到数据库。

#### 4.2.2 实现

```java
public Object getData(String key) {
    // 1. 先查询缓存
    Object value = redisTemplate.opsForValue().get(key);
    if (value != null) {
        // 2. 如果缓存命中，返回结果
        if ("NULL".equals(value)) {
            return null; // 空值标记
        }
        return value;
    }
    
    try {
        // 3. 如果缓存未命中，查询数据库
        value = database.query(key);
        if (value != null) {
            // 4. 如果数据库存在，缓存结果，设置较长过期时间
            redisTemplate.opsForValue().set(key, value, 30, TimeUnit.MINUTES);
        } else {
            // 5. 如果数据库不存在，缓存空值标记，设置较短过期时间
            redisTemplate.opsForValue().set(key, "NULL", 5, TimeUnit.MINUTES);
        }
        return value;
    } catch (Exception e) {
        // 处理异常
        log.error("查询数据失败", e);
        return null;
    }
}
```

#### 4.2.3 优缺点

**优点：**
- 实现简单，容易理解和维护
- 可以有效防止缓存穿透

**缺点：**
- 会占用一定的缓存空间存储空值
- 可能导致缓存中存在大量无效数据
- 过期时间设置不当可能影响用户体验（设置太短则频繁穿透，设置太长则可能返回旧数据）

### 4.3 接口层参数校验

#### 4.3.1 原理

在接口层对请求参数进行有效性验证，过滤掉明显不存在的请求参数，例如：
- 检查参数格式是否正确
- 检查参数值是否在合理范围内
- 检查参数是否符合业务规则

#### 4.3.2 实现

```java
public Object getData(@PathVariable Long productId) {
    // 1. 参数有效性验证
    if (productId == null || productId <= 0) {
        throw new IllegalArgumentException("商品ID无效");
    }
    
    // 2. 检查商品ID是否在合理范围内（例如数据库中商品ID的范围）
    if (productId > 1000000) {
        throw new IllegalArgumentException("商品ID不存在");
    }
    
    // 3. 继续查询缓存和数据库
    // ...
}
```

#### 4.3.3 优缺点

**优点：**
- 可以在请求到达缓存和数据库之前过滤掉无效请求
- 可以防止恶意攻击（例如使用超大ID或负数ID）

**缺点：**
- 无法过滤所有无效请求，只能过滤明显不合理的请求
- 需要维护参数的有效性规则，增加开发和维护成本

### 4.4 热点数据预热

#### 4.4.1 原理

在系统启动时或定期将热点数据加载到缓存中，避免在请求时才从数据库加载数据。这样可以减少缓存未命中的情况，降低缓存穿透的风险。

#### 4.4.2 实现

```java
@Component
public class DataWarmUpTask {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private ProductDao productDao;
    
    // 系统启动时执行
    @PostConstruct
    public void warmUpData() {
        // 1. 查询热点数据
        List<Product> hotProducts = productDao.queryHotProducts();
        
        // 2. 将热点数据加载到缓存
        for (Product product : hotProducts) {
            String key = "product:" + product.getId();
            redisTemplate.opsForValue().set(key, product, 1, TimeUnit.HOURS);
        }
    }
    
    // 定期执行（例如每天凌晨执行）
    @Scheduled(cron = "0 0 0 * * ?")
    public void scheduledWarmUpData() {
        warmUpData();
    }
}
```

#### 4.4.3 优缺点

**优点：**
- 可以减少缓存未命中的情况
- 可以提高系统响应速度

**缺点：**
- 无法覆盖所有数据，只能预热热点数据
- 需要准确识别热点数据，否则可能导致资源浪费

### 4.5 IP限流和黑名单

#### 4.5.1 原理

对请求IP进行限流，限制单个IP在单位时间内的请求次数。对于超过限流阈值的IP，可以将其加入黑名单，禁止其继续访问。

#### 4.5.2 实现

```java
@Component
public class IpRateLimiter {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 限制单个IP每分钟最多请求100次
    private static final int LIMIT = 100;
    private static final int TIME_WINDOW = 60; // 秒
    
    public boolean isAllowed(String ip) {
        String key = "rate_limit:" + ip;
        
        // 1. 检查IP是否在黑名单中
        if (Boolean.TRUE.equals(redisTemplate.hasKey("blacklist:" + ip))) {
            return false;
        }
        
        // 2. 使用Redis的incr命令进行限流
        Long count = redisTemplate.opsForValue().increment(key);
        if (count == 1) {
            // 第一次请求，设置过期时间
            redisTemplate.expire(key, TIME_WINDOW, TimeUnit.SECONDS);
        }
        
        // 3. 检查是否超过限流阈值
        if (count > LIMIT) {
            // 将IP加入黑名单，例如禁止访问1小时
            redisTemplate.opsForValue().set("blacklist:" + ip, "1", 1, TimeUnit.HOURS);
            return false;
        }
        
        return true;
    }
}
```

#### 4.5.3 优缺点

**优点：**
- 可以有效防止恶意攻击
- 可以保护系统免受大量请求的影响

**缺点：**
- 可能误判正常用户（例如用户使用代理服务器或共享IP）
- 需要维护限流和黑名单规则，增加开发和维护成本

## 5. 各种解决方案的对比

| 解决方案 | 优点 | 缺点 | 适用场景 |
|---------|------|------|----------|
| 布隆过滤器 | 空间效率高，查询速度快 | 存在误判率，删除困难 | 数据量大，查询频繁的场景 |
| 缓存空值 | 实现简单，容易维护 | 占用缓存空间，过期时间难设置 | 数据分布均匀，无效请求量不大的场景 |
| 接口层参数校验 | 提前过滤无效请求 | 无法过滤所有无效请求 | 有明确参数规则的场景 |
| 热点数据预热 | 减少缓存未命中 | 无法覆盖所有数据 | 热点数据明确的场景 |
| IP限流和黑名单 | 防止恶意攻击 | 可能误判正常用户 | 有恶意攻击风险的场景 |

## 6. 最佳实践

### 6.1 综合使用多种方案

单一的解决方案往往无法完全解决缓存穿透问题，建议综合使用多种方案，例如：
- 首先使用接口层参数校验过滤明显无效的请求
- 然后使用布隆过滤器判断数据是否存在
- 最后使用缓存空值处理剩余的穿透请求
- 同时配合IP限流和黑名单防止恶意攻击

### 6.2 根据业务场景选择合适的方案

不同的业务场景需要选择不同的解决方案，例如：
- 对于电商系统的商品查询，可以使用布隆过滤器+缓存空值
- 对于用户登录验证，可以使用接口层参数校验+IP限流
- 对于热点新闻查询，可以使用热点数据预热+缓存空值

### 6.3 监控和告警

建立完善的监控和告警机制，实时监控缓存穿透的情况，例如：
- 监控缓存命中率
- 监控数据库查询次数和响应时间
- 设置告警阈值，当缓存命中率过低或数据库压力过大时发出告警

### 6.4 定期优化和调整

定期分析缓存穿透的原因和解决方案的效果，根据实际情况进行优化和调整，例如：
- 调整布隆过滤器的误判率和大小
- 调整缓存空值的过期时间
- 更新参数校验规则
- 调整IP限流阈值

## 7. 常见问题

### 7.1 布隆过滤器的误判率如何选择？

布隆过滤器的误判率取决于位数组大小m、哈希函数数量k和元素数量n。误判率越低，需要的位数组越大，哈希函数数量越多。一般建议根据实际业务需求选择误判率，例如0.01%或0.1%。可以使用以下公式计算位数组大小和哈希函数数量：

- m = -n * ln(p) / (ln(2))² （p为误判率）
- k = m / n * ln(2)

### 7.2 缓存空值的过期时间如何设置？

缓存空值的过期时间应该根据业务需求和数据变化频率来设置。一般建议设置较短的过期时间（例如5-15分钟），这样可以在防止缓存穿透的同时，避免因数据变化而导致的长时间返回旧数据的问题。

### 7.3 布隆过滤器和缓存空值可以同时使用吗？

是的，布隆过滤器和缓存空值可以同时使用，并且可以互相补充。布隆过滤器可以快速过滤掉大部分不存在的数据，缓存空值可以处理布隆过滤器误判的情况。这种组合可以有效提高系统的性能和稳定性。

### 7.4 如何处理布隆过滤器的动态扩展问题？

布隆过滤器不支持元素数量的动态扩展，如果元素数量超过预期，误判率会增加。可以采用以下解决方案：
1. 定期重建布隆过滤器，根据实际元素数量调整大小
2. 使用多个布隆过滤器，例如按时间分片或按业务分片
3. 使用动态布隆过滤器（Dynamic Bloom Filter），支持元素数量的动态扩展

### 7.5 如何识别和处理恶意攻击？

可以通过以下方式识别和处理恶意攻击：
1. 监控请求频率和模式，识别异常请求
2. 对请求IP进行限流和黑名单处理
3. 使用验证码或其他验证机制区分人机请求
4. 与网络安全团队合作，使用防火墙和入侵检测系统

## 8. 总结

缓存穿透是缓存使用中常见的性能问题，会导致数据库压力增大、系统性能下降和可用性降低。通过综合使用布隆过滤器、缓存空值、接口层参数校验、热点数据预热、IP限流和黑名单等解决方案，可以有效防止缓存穿透。

在实际应用中，需要根据业务场景选择合适的解决方案，并建立完善的监控和告警机制，定期优化和调整解决方案，以确保系统的性能和稳定性。

同时，需要注意各种解决方案的优缺点和适用场景，避免过度设计或使用不当导致的问题。通过合理的缓存设计和优化，可以充分发挥缓存的作用，提高系统的性能和可用性。

## 参考资源

- [Redis 官方文档 - 布隆过滤器](https://redis.io/docs/latest/develop/data-types/probabilistic/bloom-filter/)
- [Redis 官方文档 - 缓存模式](https://redis.io/docs/latest/develop/use/patterns/)
- [Redis 官方文档 - 过期策略](https://redis.io/docs/latest/develop/use/keyspace/)