---
date: 2026-01-06
author: Gaaming Zhang
isOriginal: false
article: true
category:
  - Redis
tag:
  - Redis
---

# 缓存击穿基本概念

## 1. 什么是缓存击穿？

缓存击穿（Cache Breakdown）是指一个热点数据（被大量请求访问的数据）在缓存中过期失效时，大量的并发请求会同时穿透缓存，直接访问数据库，导致数据库压力瞬间增大，严重时可能导致数据库服务不可用。

缓存击穿与缓存穿透的区别在于：
- **缓存穿透**：请求的数据在缓存和数据库中都不存在
- **缓存击穿**：请求的数据在数据库中存在，但在缓存中过期失效

缓存击穿通常发生在以下场景：
- 热点商品促销活动期间
- 热门新闻发布后
- 热点数据缓存过期时刻

## 2. 缓存击穿的危害

### 2.1 数据库压力瞬间增大

当热点数据缓存过期时，大量并发请求会同时访问数据库，导致数据库连接数激增、CPU和IO资源耗尽，数据库响应时间变长，甚至可能宕机。

### 2.2 系统性能下降

数据库压力增大后，会导致整个系统的响应时间变长，用户体验变差。

### 2.3 服务可用性降低

如果数据库因压力过大而宕机，会导致依赖该数据库的服务不可用，甚至可能引发连锁反应，导致整个系统崩溃。

### 2.4 经济损失

系统性能下降和可用性降低会直接影响用户体验，可能导致用户流失，给企业带来经济损失。

## 3. 缓存击穿的原因

### 3.1 热点数据过期

- **缓存自然过期**：设置了缓存过期时间，当时间到达后缓存自动失效
- **缓存被手动删除**：由于业务需求或缓存管理需要，手动删除了热点数据的缓存
- **缓存被LRU算法淘汰**：当缓存空间不足时，热点数据可能被LRU（Least Recently Used）算法淘汰

### 3.2 并发请求量大

- 热点数据本身被大量用户同时访问
- 促销活动、热门事件等导致请求量突增

### 3.3 缓存设计缺陷

- **缓存过期时间设置不当**：所有热点数据设置了相同的过期时间，导致同时过期
- **缺少缓存预热机制**：新上线的热点数据没有提前加载到缓存中
- **没有针对热点数据的特殊处理**：没有对热点数据采取额外的保护措施

## 4. 缓存击穿的解决方案

### 4.1 设置热点数据永不过期

#### 4.1.1 原理

对于热点数据，不设置过期时间，使其永久保存在缓存中。这样可以避免缓存过期导致的击穿问题。

#### 4.1.2 实现

```java
// 对于热点数据，不设置过期时间
redisTemplate.opsForValue().set("hot:product:1001", product);

// 或者设置一个非常长的过期时间
redisTemplate.opsForValue().set("hot:product:1001", product, 1, TimeUnit.YEARS);
```

#### 4.1.3 优缺点

**优点：**
- 实现简单，容易理解和维护
- 可以彻底避免缓存击穿问题

**缺点：**
- 占用缓存空间，可能导致缓存膨胀
- 数据更新不及时，可能导致用户获取到旧数据
- 需要手动或通过其他机制更新缓存数据

### 4.2 互斥锁（Mutex Lock）

#### 4.2.1 原理

当缓存失效时，不是所有请求都直接访问数据库，而是只有一个请求获得锁并访问数据库，其他请求则等待该请求更新缓存后，再从缓存中获取数据。

#### 4.2.2 实现

```java
public Object getData(String key) {
    // 1. 先查询缓存
    Object value = redisTemplate.opsForValue().get(key);
    if (value != null) {
        return value;
    }
    
    // 2. 缓存未命中，尝试获取锁
    String lockKey = "lock:" + key;
    boolean locked = false;
    int retryCount = 0;
    int maxRetryCount = 5;
    
    try {
        // 循环尝试获取锁
        while (retryCount < maxRetryCount) {
            // 尝试获取锁，设置超时时间为3秒
            locked = redisTemplate.opsForValue().setIfAbsent(lockKey, "1", 3, TimeUnit.SECONDS);
            if (locked) {
                break;
            }
            
            // 获取锁失败，等待一段时间后重试
            retryCount++;
            Thread.sleep(100 * retryCount); // 指数退避策略
        }
        
        if (locked) {
            // 3. 获取锁成功，再次查询缓存（防止其他线程已更新缓存）
            value = redisTemplate.opsForValue().get(key);
            if (value != null) {
                return value;
            }
            
            // 4. 查询数据库
            value = database.query(key);
            if (value != null) {
                // 5. 更新缓存，设置过期时间
                redisTemplate.opsForValue().set(key, value, 30, TimeUnit.MINUTES);
            }
            return value;
        } else {
            // 获取锁失败次数过多，返回null或默认值
            log.warn("获取锁失败次数过多，key: {}", key);
            return null;
        }
    } catch (InterruptedException e) {
        log.error("获取数据失败", e);
        Thread.currentThread().interrupt();
        return null;
    } finally {
        // 6. 释放锁
        if (locked) {
            redisTemplate.delete(lockKey);
        }
    }
}
```

#### 4.2.3 优缺点

**优点：**
- 可以有效防止缓存击穿
- 数据一致性较好，缓存中的数据始终是最新的

**缺点：**
- 实现相对复杂，需要处理锁的获取、释放和超时
- 可能导致请求等待，增加系统响应时间
- 存在死锁风险（如果锁没有正确释放）

### 4.3 提前刷新

#### 4.3.1 原理

在热点数据缓存过期前，主动刷新缓存，避免缓存过期导致的击穿问题。可以通过以下方式实现：
- 后台定时任务定期刷新热点数据缓存
- 当请求访问缓存时，如果缓存即将过期，则异步刷新缓存

#### 4.3.2 实现

**后台定时任务刷新：**

```java
@Component
public class CacheRefreshTask {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private ProductDao productDao;
    
    // 每天凌晨1点执行，刷新热点商品缓存
    @Scheduled(cron = "0 0 1 * * ?")
    public void refreshHotProductsCache() {
        // 1. 查询热点商品列表
        List<Product> hotProducts = productDao.queryHotProducts();
        
        // 2. 刷新缓存
        for (Product product : hotProducts) {
            String key = "product:" + product.getId();
            redisTemplate.opsForValue().set(key, product, 24, TimeUnit.HOURS);
        }
    }
}
```

**请求时异步刷新：**

```java
public Object getData(String key) {
    // 1. 先查询缓存
    Object value = redisTemplate.opsForValue().get(key);
    if (value != null) {
        // 2. 检查缓存是否即将过期（例如剩余时间小于5分钟）
        Long ttl = redisTemplate.getExpire(key, TimeUnit.MINUTES);
        if (ttl != null && ttl < 5) {
            // 3. 异步刷新缓存
            executorService.submit(() -> refreshCache(key));
        }
        return value;
    }
    
    // 4. 缓存未命中，查询数据库并更新缓存
    // ...
}

private void refreshCache(String key) {
    Object value = database.query(key);
    if (value != null) {
        redisTemplate.opsForValue().set(key, value, 30, TimeUnit.MINUTES);
    }
}
```

#### 4.3.3 优缺点

**优点：**
- 可以避免缓存过期导致的击穿问题
- 对用户请求的影响较小

**缺点：**
- 需要识别热点数据，增加了系统复杂性
- 后台定时任务可能增加系统负担
- 异步刷新可能导致数据不一致

### 4.4 二级缓存

#### 4.4.1 原理

使用两级缓存：一级缓存（内存缓存，如Caffeine、Guava Cache）和二级缓存（分布式缓存，如Redis）。当二级缓存过期时，一级缓存仍然可以提供服务，避免直接访问数据库。

#### 4.4.2 实现

```java
@Component
public class TwoLevelCacheManager {
    
    // 一级缓存：Caffeine
    private final Cache<String, Object> localCache = Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterWrite(10, TimeUnit.MINUTES)
        .build();
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private Database database;
    
    public Object getData(String key) {
        Object value;
        
        // 1. 先查询一级缓存
        value = localCache.getIfPresent(key);
        if (value != null) {
            return value;
        }
        
        // 2. 一级缓存未命中，查询二级缓存
        value = redisTemplate.opsForValue().get(key);
        if (value != null) {
            // 3. 二级缓存命中，更新一级缓存
            localCache.put(key, value);
            return value;
        }
        
        // 4. 二级缓存未命中，查询数据库
        value = database.query(key);
        if (value != null) {
            // 5. 更新二级缓存
            redisTemplate.opsForValue().set(key, value, 30, TimeUnit.MINUTES);
            // 6. 更新一级缓存
            localCache.put(key, value);
        }
        
        return value;
    }
}
```

#### 4.4.3 优缺点

**优点：**
- 可以有效防止缓存击穿
- 一级缓存访问速度快，提高系统性能
- 降低分布式缓存的压力

**缺点：**
- 实现复杂，需要维护两级缓存
- 可能导致数据不一致（两级缓存数据更新不同步）
- 占用本地内存空间

### 4.5 分布式锁

#### 4.5.1 原理

在分布式环境下，使用分布式锁（如Redis分布式锁、ZooKeeper分布式锁）来保证只有一个请求能够访问数据库并更新缓存。

#### 4.5.2 实现

**Redis分布式锁实现：**

```java
public Object getData(String key) {
    // 1. 先查询缓存
    Object value = redisTemplate.opsForValue().get(key);
    if (value != null) {
        return value;
    }
    
    // 2. 缓存未命中，尝试获取分布式锁
    String lockKey = "distributed_lock:" + key;
    String requestId = UUID.randomUUID().toString();
    boolean locked = false;
    int retryCount = 0;
    int maxRetryCount = 5;
    
    try {
        // 循环尝试获取锁
        while (retryCount < maxRetryCount) {
            // 尝试获取锁，设置超时时间为3秒
            locked = redisTemplate.opsForValue().setIfAbsent(lockKey, requestId, 3, TimeUnit.SECONDS);
            if (locked) {
                break;
            }
            
            // 获取锁失败，等待一段时间后重试（指数退避策略）
            retryCount++;
            Thread.sleep(100 * retryCount);
        }
        
        if (locked) {
            // 3. 获取锁成功，再次查询缓存（防止其他线程已更新缓存）
            value = redisTemplate.opsForValue().get(key);
            if (value != null) {
                return value;
            }
            
            // 4. 查询数据库
            value = database.query(key);
            if (value != null) {
                // 5. 更新缓存，设置过期时间
                redisTemplate.opsForValue().set(key, value, 30, TimeUnit.MINUTES);
            }
            return value;
        } else {
            // 获取锁失败次数过多，返回null或默认值
            log.warn("获取分布式锁失败次数过多，key: {}", key);
            return null;
        }
    } catch (InterruptedException e) {
        log.error("获取数据失败", e);
        Thread.currentThread().interrupt();
        return null;
    } finally {
        // 6. 释放锁（使用Lua脚本保证原子性）
        if (locked) {
            String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
            redisTemplate.execute(new DefaultRedisScript<>(script, Long.class), Collections.singletonList(lockKey), requestId);
        }
    }
}
```

#### 4.5.3 优缺点

**优点：**
- 可以在分布式环境下有效防止缓存击穿
- 保证数据一致性

**缺点：**
- 实现复杂，需要处理分布式锁的获取、释放和超时
- 可能导致请求等待，增加系统响应时间
- 存在死锁风险（如果锁没有正确释放）
- 依赖分布式锁服务的可用性

## 5. 各种解决方案的对比

| 解决方案 | 优点 | 缺点 | 适用场景 |
|---------|------|------|----------|
| 设置热点数据永不过期 | 实现简单，避免缓存击穿 | 占用缓存空间，数据更新不及时 | 热点数据更新不频繁的场景 |
| 互斥锁 | 有效防止缓存击穿，数据一致性好 | 实现复杂，可能导致请求等待 | 单节点环境，热点数据更新频繁的场景 |
| 提前刷新 | 对用户请求影响小 | 需要识别热点数据，增加系统复杂性 | 热点数据可预测的场景 |
| 二级缓存 | 访问速度快，降低分布式缓存压力 | 实现复杂，可能导致数据不一致 | 对性能要求高的场景 |
| 分布式锁 | 分布式环境下有效防止缓存击穿 | 实现复杂，依赖分布式锁服务 | 分布式环境，热点数据更新频繁的场景 |

## 6. 最佳实践

### 6.1 综合使用多种方案

单一的解决方案往往无法完全解决缓存击穿问题，建议综合使用多种方案，例如：
- 对于热点数据，设置永不过期或非常长的过期时间
- 使用互斥锁或分布式锁保证缓存更新的原子性
- 结合提前刷新机制，避免缓存过期
- 使用二级缓存提高系统性能

### 6.2 根据业务场景选择合适的方案

不同的业务场景需要选择不同的解决方案，以下是一些具体案例：

**电商系统热点商品场景：**
- 采用「设置永不过期+异步刷新」方案
- 将热点商品缓存设置为永不过期，避免缓存过期导致的击穿
- 使用后台定时任务或消息队列异步刷新缓存数据，确保数据的时效性
- 例如：在大促期间，将秒杀商品设置为永不过期，每5分钟通过定时任务刷新一次缓存

**新闻系统热门新闻场景：**
- 采用「提前刷新+二级缓存」方案
- 使用后台定时任务在缓存过期前10分钟主动刷新热门新闻缓存
- 结合本地缓存(Caffeine)和分布式缓存(Redis)的二级缓存架构，即使Redis缓存过期，本地缓存仍能提供服务

**分布式系统场景：**
- 采用「分布式锁+提前刷新」方案
- 使用Redis分布式锁保证在多节点环境下只有一个节点能够更新缓存
- 结合提前刷新机制，减少缓存过期的概率
- 例如：在微服务架构中，为每个热点数据设置分布式锁，并在缓存过期前5分钟主动刷新

### 6.3 识别和保护热点数据

#### 6.3.1 识别热点数据的方法

**1. 基于访问日志分析：**
- 分析应用服务器的访问日志，统计请求频率高的URL和参数
- 使用日志分析工具（如ELK Stack、Splunk）实时监控热点数据

**2. 使用Redis监控工具：**
- Redis 4.0+ 提供了`MEMORY USAGE`命令，可以查看键的内存占用
- 使用`redis-cli --hotkeys`命令识别热点键
- 利用Redis监控工具（如RedisInsight、Prometheus+Grafana）监控键的访问频率

**3. 业务经验判断：**
- 根据业务特点判断热点数据，如促销活动的商品、热门新闻、明星相关内容等
- 在系统设计阶段就考虑热点数据的处理策略

#### 6.3.2 保护热点数据的策略

- **特殊标记：** 为热点数据添加特殊标记，如在缓存键前添加`hot:`前缀
- **独立缓存策略：** 为热点数据设置不同的缓存策略，如更长的过期时间或永不过期
- **缓存扩容：** 为热点数据分配更多的缓存空间，避免被LRU算法淘汰
- **请求限流：** 对热点数据的请求进行限流，避免请求量过大导致系统崩溃

### 6.4 建立完善的监控和告警机制

- 监控缓存命中率和过期情况
- 监控数据库压力和响应时间
- 设置告警阈值，当缓存命中率过低或数据库压力过大时发出告警

### 6.5 定期优化和调整

- 定期分析缓存击穿的原因和解决方案的效果
- 根据实际情况调整缓存策略和过期时间
- 优化数据库查询性能，提高系统整体稳定性

## 7. 常见问题

### 7.1 缓存击穿和缓存穿透有什么区别？

缓存击穿是指请求的数据在数据库中存在，但在缓存中过期失效，导致大量并发请求穿透缓存直接访问数据库；而缓存穿透是指请求的数据在缓存和数据库中都不存在，导致每次请求都穿透缓存直接访问数据库。

### 7.2 如何识别热点数据？

可以通过以下方式识别热点数据：
- 分析访问日志，统计请求频率高的数据
- 使用监控工具（如Prometheus、Grafana）监控缓存访问情况
- 根据业务经验判断，如促销活动的商品、热门新闻等
- 使用Redis的MONITOR命令或slowlog功能分析热点键

### 7.3 互斥锁和分布式锁有什么区别？

互斥锁（Mutex Lock）是在单节点环境下使用的锁，保证同一进程内只有一个线程能够访问临界资源；而分布式锁是在分布式环境下使用的锁，保证多个进程或节点中只有一个能够访问临界资源。在分布式系统中，需要使用分布式锁来防止缓存击穿。

### 7.4 热点数据永不过期有什么问题？

热点数据永不过期可能导致以下问题：
- 占用缓存空间，可能导致缓存膨胀
- 数据更新不及时，用户可能获取到旧数据
- 需要手动或通过其他机制更新缓存数据，增加系统复杂性

### 7.5 如何设置合适的缓存过期时间？

设置缓存过期时间需要考虑以下因素：
- 数据更新频率：更新频繁的数据设置较短的过期时间，更新不频繁的数据设置较长的过期时间
- 系统对数据一致性的要求：对一致性要求高的场景设置较短的过期时间
- 缓存容量：缓存容量有限时，设置较短的过期时间
- 业务需求：根据业务需求设置合适的过期时间，例如促销活动期间可以临时延长过期时间

## 8. 总结

缓存击穿是缓存使用中常见的性能问题，会导致数据库压力增大、系统性能下降和可用性降低。通过综合使用设置热点数据永不过期、互斥锁、提前刷新、二级缓存、分布式锁等解决方案，可以有效防止缓存击穿。

在实际应用中，需要根据业务场景选择合适的解决方案，并建立完善的监控和告警机制，定期优化和调整缓存策略。同时，需要注意各种解决方案的优缺点和适用场景，避免过度设计或使用不当导致的问题。

通过合理的缓存设计和优化，可以充分发挥缓存的作用，提高系统的性能和可用性，为用户提供更好的体验。

## 参考资源

- [Redis 官方文档 - 缓存模式](https://redis.io/docs/latest/develop/use/patterns/)
- [Redis 官方文档 - 分布式锁](https://redis.io/docs/latest/develop/use/patterns/distributed-locks/)
- [Redis 官方文档 - 过期策略](https://redis.io/docs/latest/develop/use/keyspace/)