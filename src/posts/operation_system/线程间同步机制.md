# 线程间同步机制

## 引言

在多线程编程中，线程间同步机制是确保多个线程安全地共享资源、避免数据竞争和不一致的关键技术。当多个线程同时访问共享数据时，如果没有适当的同步措施，就会出现**竞争条件（Race Condition）**，导致数据不一致、程序行为异常甚至崩溃。

线程间同步机制的主要目标是：
1. **互斥（Mutual Exclusion）**：确保同一时间只有一个线程可以访问共享资源
2. **原子性（Atomicity）**：确保操作要么完全执行，要么完全不执行
3. **可见性（Visibility）**：确保一个线程对共享数据的修改对其他线程可见
4. **有序性（Ordering）**：确保操作按照预期的顺序执行

本文将详细介绍Linux系统中常用的线程间同步机制，包括互斥锁、条件变量、信号量等，分析它们的原理、使用方法和适用场景，并提供示例代码帮助理解。

## 同步机制分类

线程间同步机制可以按照不同的标准进行分类：

### 基于锁的同步机制
- 互斥锁（Mutex）
- 读写锁（Read-Write Lock）
- 自旋锁（Spin Lock）

### 基于条件的同步机制
- 条件变量（Condition Variable）

### 基于计数的同步机制
- 信号量（Semaphore）

### 基于协作的同步机制
- 屏障（Barrier）
- 读写屏障（Memory Barrier）

### 原子操作
- 原子变量（Atomic Variables）
- 原子操作指令

接下来，我们将详细介绍各种同步机制的原理、使用方法和示例代码。

## 互斥锁（Mutex）

### 什么是互斥锁

互斥锁（Mutual Exclusion Lock）是最基本的线程同步机制之一，用于实现对共享资源的互斥访问。互斥锁确保在同一时间只有一个线程可以持有锁，从而避免多个线程同时访问共享资源导致的竞争条件。

### 互斥锁的原理

互斥锁内部通常包含一个**状态标志**，表示锁是否被占用：
- **锁定状态**：锁被某个线程持有，其他线程尝试获取锁时会被阻塞
- **解锁状态**：锁可用，等待的线程可以尝试获取锁

互斥锁的基本操作包括：
1. **初始化**：创建并初始化互斥锁
2. **加锁**：尝试获取互斥锁，如果锁被占用则阻塞
3. **解锁**：释放互斥锁，允许其他线程获取锁
4. **销毁**：释放互斥锁占用的资源

### Linux中的互斥锁实现

在Linux系统中，互斥锁通过POSIX线程库（pthread）提供，主要使用以下函数：

```c
#include <pthread.h>

// 初始化互斥锁
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);

// 加锁
int pthread_mutex_lock(pthread_mutex_t *mutex);

// 尝试加锁（不阻塞）
int pthread_mutex_trylock(pthread_mutex_t *mutex);

// 限时加锁
int pthread_mutex_timedlock(pthread_mutex_t *mutex, const struct timespec *abs_timeout);

// 解锁
int pthread_mutex_unlock(pthread_mutex_t *mutex);

// 销毁互斥锁
int pthread_mutex_destroy(pthread_mutex_t *mutex);
```

### 互斥锁的类型

通过`pthread_mutexattr_t`可以设置互斥锁的类型，常用类型包括：

1. **默认互斥锁（PTHREAD_MUTEX_DEFAULT）**
   - 不进行错误检查
   - 不能递归加锁

2. **递归互斥锁（PTHREAD_MUTEX_RECURSIVE）**
   - 允许同一线程多次加锁
   - 需要相应次数的解锁操作才能完全释放锁

3. **错误检查互斥锁（PTHREAD_MUTEX_ERRORCHECK）**
   - 进行错误检查
   - 如果同一线程重复加锁会返回错误
   - 如果解锁一个未加锁的互斥锁会返回错误

4. **健壮互斥锁（PTHREAD_MUTEX_ROBUST）**
   - 当持有锁的线程异常终止时，其他线程可以恢复锁的状态

### 互斥锁示例代码

下面是一个使用互斥锁保护共享变量的简单示例：

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

// 共享变量
int shared_counter = 0;

// 互斥锁
pthread_mutex_t mutex;

// 线程函数：递增计数器
void *increment_counter(void *arg) {
    int *thread_id = (int *)arg;
    
    for (int i = 0; i < 100000; i++) {
        // 加锁
        pthread_mutex_lock(&mutex);
        
        // 临界区：访问共享变量
        shared_counter++;
        
        // 解锁
        pthread_mutex_unlock(&mutex);
        
        // 模拟其他工作
        usleep(1);
    }
    
    printf("Thread %d finished. Counter: %d\n", *thread_id, shared_counter);
    free(thread_id);
    return NULL;
}

int main() {
    pthread_t threads[5];
    
    // 初始化互斥锁
    pthread_mutex_init(&mutex, NULL);
    
    // 创建5个线程
    for (int i = 0; i < 5; i++) {
        int *thread_id = malloc(sizeof(int));
        *thread_id = i;
        pthread_create(&threads[i], NULL, increment_counter, thread_id);
    }
    
    // 等待所有线程完成
    for (int i = 0; i < 5; i++) {
        pthread_join(threads[i], NULL);
    }
    
    // 输出最终结果
    printf("Final counter value: %d\n", shared_counter);
    
    // 销毁互斥锁
    pthread_mutex_destroy(&mutex);
    
    return 0;
}
```

### 编译和运行

```bash
gcc mutex_example.c -o mutex_example -lpthread
./mutex_example
```

### 互斥锁的优缺点

**优点**：
- 实现简单，易于理解和使用
- 效率较高，特别是在临界区较小的情况下
- 能够有效防止竞争条件

**缺点**：
- 只能保证互斥访问，无法实现线程间的协作
- 如果使用不当可能导致死锁
- 可能会导致线程上下文切换开销

### 使用互斥锁的注意事项

1. **避免死锁**：
   - 避免一个线程持有多个锁
   - 如果必须持有多个锁，确保所有线程以相同的顺序获取锁
   - 避免在持有锁的情况下调用可能阻塞的函数

2. **减小临界区**：
   - 只在必要时加锁
   - 临界区应尽可能小，减少线程等待时间

3. **正确释放锁**：
   - 确保在所有路径上都能释放锁（包括异常情况）
   - 避免解锁一个未加锁的互斥锁

4. **避免递归调用**：
   - 除非使用递归互斥锁，否则不要在同一线程中重复加锁

## 条件变量（Condition Variable）

### 什么是条件变量

条件变量是一种线程同步机制，用于线程间的通信和协作。条件变量允许线程等待某个条件满足，当条件满足时，其他线程可以通知等待的线程继续执行。

### 条件变量的原理

条件变量通常与互斥锁结合使用，工作原理如下：
1. 线程获取互斥锁
2. 检查条件是否满足，如果不满足则等待条件变量
3. 当条件变量被通知时，线程被唤醒并重新检查条件
4. 条件满足时，执行相应操作并释放互斥锁

### Linux中的条件变量实现

在Linux系统中，条件变量通过POSIX线程库（pthread）提供，主要使用以下函数：

```c
#include <pthread.h>

// 初始化条件变量
int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);

// 等待条件变量
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);

// 限时等待条件变量
int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abs_timeout);

// 通知一个等待的线程
int pthread_cond_signal(pthread_cond_t *cond);

// 通知所有等待的线程
int pthread_cond_broadcast(pthread_cond_t *cond);

// 销毁条件变量
int pthread_cond_destroy(pthread_cond_t *cond);
```

### 条件变量示例代码

下面是一个使用条件变量实现生产者-消费者模型的示例：

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define BUFFER_SIZE 5

// 缓冲区
int buffer[BUFFER_SIZE];
int in = 0;
int out = 0;
int count = 0;

// 互斥锁和条件变量
pthread_mutex_t mutex;
pthread_cond_t not_full;
pthread_cond_t not_empty;

// 生产者线程函数
void *producer(void *arg) {
    int *producer_id = (int *)arg;
    int item;
    
    for (int i = 0; i < 10; i++) {
        item = rand() % 100;
        
        // 加锁
        pthread_mutex_lock(&mutex);
        
        // 等待缓冲区不满
        while (count == BUFFER_SIZE) {
            pthread_cond_wait(&not_full, &mutex);
        }
        
        // 生产数据
        buffer[in] = item;
        in = (in + 1) % BUFFER_SIZE;
        count++;
        
        printf("Producer %d produced: %d\n", *producer_id, item);
        
        // 通知消费者缓冲区不为空
        pthread_cond_signal(&not_empty);
        
        // 解锁
        pthread_mutex_unlock(&mutex);
        
        // 模拟生产时间
        sleep(1);
    }
    
    free(producer_id);
    return NULL;
}

// 消费者线程函数
void *consumer(void *arg) {
    int *consumer_id = (int *)arg;
    int item;
    
    for (int i = 0; i < 10; i++) {
        // 加锁
        pthread_mutex_lock(&mutex);
        
        // 等待缓冲区不为空
        while (count == 0) {
            pthread_cond_wait(&not_empty, &mutex);
        }
        
        // 消费数据
        item = buffer[out];
        out = (out + 1) % BUFFER_SIZE;
        count--;
        
        printf("Consumer %d consumed: %d\n", *consumer_id, item);
        
        // 通知生产者缓冲区不满
        pthread_cond_signal(&not_full);
        
        // 解锁
        pthread_mutex_unlock(&mutex);
        
        // 模拟消费时间
        sleep(2);
    }
    
    free(consumer_id);
    return NULL;
}

int main() {
    pthread_t prod_threads[2];
    pthread_t cons_threads[2];
    
    // 初始化互斥锁和条件变量
    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&not_full, NULL);
    pthread_cond_init(&not_empty, NULL);
    
    // 创建生产者线程
    for (int i = 0; i < 2; i++) {
        int *producer_id = malloc(sizeof(int));
        *producer_id = i + 1;
        pthread_create(&prod_threads[i], NULL, producer, producer_id);
    }
    
    // 创建消费者线程
    for (int i = 0; i < 2; i++) {
        int *consumer_id = malloc(sizeof(int));
        *consumer_id = i + 1;
        pthread_create(&cons_threads[i], NULL, consumer, consumer_id);
    }
    
    // 等待所有线程完成
    for (int i = 0; i < 2; i++) {
        pthread_join(prod_threads[i], NULL);
        pthread_join(cons_threads[i], NULL);
    }
    
    // 销毁互斥锁和条件变量
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&not_full);
    pthread_cond_destroy(&not_empty);
    
    return 0;
}
```

### 编译和运行

```bash
gcc condvar_example.c -o condvar_example -lpthread
./condvar_example
```

### 条件变量的优缺点

**优点**：
- 支持线程间的协作和通信
- 效率较高，避免了忙等待
- 可以同时通知多个线程

**缺点**：
- 使用复杂，容易出错
- 需要与互斥锁结合使用
- 可能出现虚假唤醒（Spurious Wakeup）

### 使用条件变量的注意事项

1. **始终与互斥锁结合使用**：
   - 条件变量必须与互斥锁一起使用，确保条件检查和等待的原子性

2. **使用while循环检查条件**：
   - 避免使用if语句检查条件，因为可能出现虚假唤醒
   - while循环确保条件不满足时继续等待

3. **正确释放资源**：
   - 确保条件变量和互斥锁都被正确销毁

4. **选择合适的通知方式**：
   - `pthread_cond_signal()`：通知一个等待的线程
   - `pthread_cond_broadcast()`：通知所有等待的线程

5. **避免死锁**：
   - 确保在等待条件变量之前已经获取了互斥锁
   - 避免在持有其他锁的情况下等待条件变量

## 信号量（Semaphore）

### 什么是信号量

信号量（Semaphore）是一种用于控制对共享资源访问的同步机制，它可以看作是互斥锁的扩展。信号量允许多个线程同时访问共享资源，而互斥锁只允许一个线程访问。

### 信号量的原理

信号量内部包含一个**计数器**，表示可用资源的数量：
- 当计数器大于0时，表示有可用资源，线程可以获取资源并将计数器减1
- 当计数器等于0时，表示没有可用资源，线程会被阻塞，直到有资源可用

信号量的基本操作包括：
1. **初始化**：创建并初始化信号量，设置初始计数器值
2. **P操作（Wait）**：尝试获取资源，如果没有可用资源则阻塞
3. **V操作（Signal）**：释放资源，通知等待的线程
4. **销毁**：释放信号量占用的资源

### Linux中的信号量实现

在Linux系统中，信号量可以通过以下两种方式实现：

#### POSIX信号量

```c
#include <semaphore.h>

// 初始化命名信号量
sem_t *sem_open(const char *name, int oflag, ... /* mode_t mode, unsigned int value */);

// 初始化无名信号量
int sem_init(sem_t *sem, int pshared, unsigned int value);

// P操作（获取资源）
int sem_wait(sem_t *sem);

// 尝试P操作（不阻塞）
int sem_trywait(sem_t *sem);

// 限时P操作
int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);

// V操作（释放资源）
int sem_post(sem_t *sem);

// 获取信号量的值
int sem_getvalue(sem_t *sem, int *sval);

// 关闭命名信号量
int sem_close(sem_t *sem);

// 销毁命名信号量
int sem_unlink(const char *name);

// 销毁无名信号量
int sem_destroy(sem_t *sem);
```

#### System V信号量

System V信号量是一种更复杂的信号量实现，支持信号量集（多个信号量的集合）。

### 信号量类型

根据信号量计数器的取值范围，信号量可以分为：

1. **二进制信号量**：计数器只能取0或1，相当于互斥锁
2. **计数信号量**：计数器可以取任意非负整数值，用于控制对多个相同资源的访问

### 信号量示例代码

下面是一个使用POSIX信号量实现生产者-消费者模型的示例：

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define BUFFER_SIZE 5

// 缓冲区
int buffer[BUFFER_SIZE];
int in = 0;
int out = 0;

// 信号量
sem_t empty;    // 空缓冲区数量
sem_t full;     // 满缓冲区数量
sem_t mutex;    // 互斥锁

// 生产者线程函数
void *producer(void *arg) {
    int *producer_id = (int *)arg;
    int item;
    
    for (int i = 0; i < 10; i++) {
        item = rand() % 100;
        
        // 等待空缓冲区
        sem_wait(&empty);
        
        // 获取互斥锁
        sem_wait(&mutex);
        
        // 生产数据
        buffer[in] = item;
        in = (in + 1) % BUFFER_SIZE;
        
        printf("Producer %d produced: %d\n", *producer_id, item);
        
        // 释放互斥锁
        sem_post(&mutex);
        
        // 通知有满缓冲区
        sem_post(&full);
        
        // 模拟生产时间
        sleep(1);
    }
    
    free(producer_id);
    return NULL;
}

// 消费者线程函数
void *consumer(void *arg) {
    int *consumer_id = (int *)arg;
    int item;
    
    for (int i = 0; i < 10; i++) {
        // 等待满缓冲区
        sem_wait(&full);
        
        // 获取互斥锁
        sem_wait(&mutex);
        
        // 消费数据
        item = buffer[out];
        out = (out + 1) % BUFFER_SIZE;
        
        printf("Consumer %d consumed: %d\n", *consumer_id, item);
        
        // 释放互斥锁
        sem_post(&mutex);
        
        // 通知有空缓冲区
        sem_post(&empty);
        
        // 模拟消费时间
        sleep(2);
    }
    
    free(consumer_id);
    return NULL;
}

int main() {
    pthread_t prod_threads[2];
    pthread_t cons_threads[2];
    
    // 初始化信号量
    sem_init(&empty, 0, BUFFER_SIZE);     // 初始有BUFFER_SIZE个空缓冲区
    sem_init(&full, 0, 0);                 // 初始有0个满缓冲区
    sem_init(&mutex, 0, 1);                // 互斥锁，初始值为1
    
    // 创建生产者线程
    for (int i = 0; i < 2; i++) {
        int *producer_id = malloc(sizeof(int));
        *producer_id = i + 1;
        pthread_create(&prod_threads[i], NULL, producer, producer_id);
    }
    
    // 创建消费者线程
    for (int i = 0; i < 2; i++) {
        int *consumer_id = malloc(sizeof(int));
        *consumer_id = i + 1;
        pthread_create(&cons_threads[i], NULL, consumer, consumer_id);
    }
    
    // 等待所有线程完成
    for (int i = 0; i < 2; i++) {
        pthread_join(prod_threads[i], NULL);
        pthread_join(cons_threads[i], NULL);
    }
    
    // 销毁信号量
    sem_destroy(&empty);
    sem_destroy(&full);
    sem_destroy(&mutex);
    
    return 0;
}
```

### 编译和运行

```bash
gcc semaphore_example.c -o semaphore_example -lpthread
./semaphore_example
```

### 信号量的优缺点

**优点**：
- 灵活，可以控制多个线程同时访问共享资源
- 支持线程间的协作和通信
- 可以实现生产者-消费者模型等复杂同步场景

**缺点**：
- 使用复杂，容易出错
- 可能导致死锁
- 对于简单的互斥访问，互斥锁更高效

### 使用信号量的注意事项

1. **避免死锁**：
   - 确保信号量的P操作和V操作成对出现
   - 避免在持有信号量的情况下调用可能阻塞的函数

2. **正确初始化**：
   - 确保信号量的初始值设置正确

3. **正确释放资源**：
   - 确保信号量被正确销毁

4. **避免竞争条件**：
   - 对于需要原子操作的情况，确保P操作和V操作之间的代码是原子的

5. **选择合适的信号量类型**：
   - 根据需要选择二进制信号量或计数信号量
   - 根据使用场景选择POSIX信号量或System V信号量

## 其他同步机制

### 读写锁（Read-Write Lock）

读写锁是一种特殊的锁，用于优化读多写少的场景。读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。

#### 读写锁的特点

- **读锁**：多个线程可以同时获取读锁
- **写锁**：只有一个线程可以获取写锁
- **优先级**：可以设置读优先或写优先

#### Linux中的读写锁实现

```c
#include <pthread.h>

// 初始化读写锁
int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);

// 获取读锁
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);

// 尝试获取读锁
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);

// 限时获取读锁
int pthread_rwlock_timedrdlock(pthread_rwlock_t *rwlock, const struct timespec *abs_timeout);

// 获取写锁
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);

// 尝试获取写锁
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);

// 限时获取写锁
int pthread_rwlock_timedwrlock(pthread_rwlock_t *rwlock, const struct timespec *abs_timeout);

// 释放读写锁
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);

// 销毁读写锁
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
```

#### 读写锁的适用场景

- 读多写少的场景，如缓存系统
- 共享数据的读操作远多于写操作的场景

### 自旋锁（Spin Lock）

自旋锁是一种特殊的锁，当线程尝试获取锁时，如果锁被占用，线程会不断检查锁的状态，而不是被阻塞。

#### 自旋锁的特点

- **忙等待**：线程在获取锁时会不断检查锁的状态
- **低延迟**：避免了线程上下文切换的开销
- **高CPU使用率**：在锁竞争激烈的情况下会消耗大量CPU资源

#### Linux中的自旋锁实现

```c
#include <pthread.h>

// 初始化自旋锁
int pthread_spin_init(pthread_spinlock_t *lock, int pshared);

// 获取自旋锁
int pthread_spin_lock(pthread_spinlock_t *lock);

// 尝试获取自旋锁
int pthread_spin_trylock(pthread_spinlock_t *lock);

// 释放自旋锁
int pthread_spin_unlock(pthread_spinlock_t *lock);

// 销毁自旋锁
int pthread_spin_destroy(pthread_spinlock_t *lock);
```

#### 自旋锁的适用场景

- 锁持有时间短的场景
- 多核CPU系统
- 实时系统，要求低延迟

### 屏障（Barrier）

屏障是一种用于同步多个线程的机制，它确保所有线程都到达某个点后才能继续执行。

#### 屏障的特点

- **同步点**：所有线程必须到达屏障点才能继续执行
- **计数器**：跟踪到达屏障的线程数量
- **重用性**：屏障可以被重复使用

#### Linux中的屏障实现

```c
#include <pthread.h>

// 初始化屏障
int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count);

// 等待屏障
int pthread_barrier_wait(pthread_barrier_t *barrier);

// 销毁屏障
int pthread_barrier_destroy(pthread_barrier_t *barrier);
```

#### 屏障的适用场景

- 并行计算，需要所有线程完成初始化后才能开始计算
- 多阶段任务，需要所有线程完成当前阶段后才能进入下一个阶段

### 原子操作

原子操作是指不可中断的操作，它要么完全执行，要么完全不执行，不会被其他线程中断。

#### 原子操作的特点

- **不可中断**：操作执行期间不会被其他线程中断
- **原子性**：确保操作的原子性
- **高性能**：不需要锁，避免了上下文切换的开销

#### Linux中的原子操作实现

```c
#include <stdatomic.h>

// 原子变量声明
atomic_int atomic_var;

// 原子操作示例
atomic_store(&atomic_var, 0);        // 设置原子变量的值
atomic_fetch_add(&atomic_var, 1);    // 原子加操作
atomic_fetch_sub(&atomic_var, 1);    // 原子减操作
atomic_compare_exchange_strong(&atomic_var, &expected, desired);  // 原子比较并交换操作
```

#### 原子操作的适用场景

- 简单的计数器更新
- 引用计数管理
- 无锁数据结构的实现

## 同步机制的比较与选择

不同的同步机制具有不同的特点和适用场景，下表总结了常用同步机制的比较：

| 同步机制 | 主要用途 | 优点 | 缺点 | 适用场景 |
|---------|---------|------|------|---------|
| 互斥锁 | 互斥访问共享资源 | 简单、高效 | 只支持互斥访问 | 简单的资源保护 |
| 条件变量 | 线程间通信和协作 | 支持复杂同步场景 | 使用复杂，需要与互斥锁结合 | 生产者-消费者模型 |
| 信号量 | 控制资源访问数量 | 灵活，支持多线程访问 | 使用复杂，可能导致死锁 | 有限资源的管理 |
| 读写锁 | 读多写少场景 | 读操作并发，提高性能 | 写操作互斥，可能导致写饥饿 | 缓存系统、配置管理 |
| 自旋锁 | 锁持有时间短的场景 | 低延迟 | 高CPU使用率 | 实时系统、内核代码 |
| 屏障 | 多线程同步点 | 简单易用 | 功能单一 | 并行计算、多阶段任务 |
| 原子操作 | 简单的原子更新 | 高性能，无锁 | 功能有限 | 计数器、引用计数 |

### 如何选择合适的同步机制

选择同步机制时，需要考虑以下因素：

1. **同步需求**：
   - 是否需要互斥访问？
   - 是否需要线程间通信？
   - 是否需要控制资源访问数量？

2. **性能要求**：
   - 锁持有时间的长短
   - 线程竞争的激烈程度
   - 对延迟的要求

3. **复杂度**：
   - 实现的难易程度
   - 维护成本
   - 错误的可能性

4. **可移植性**：
   - 是否需要跨平台支持
   - 是否需要与特定系统集成

## 常见问题

### 什么是竞争条件（Race Condition）？如何避免？

竞争条件是指多个线程同时访问共享数据时，由于执行顺序的不确定性导致的程序行为异常。避免竞争条件的主要方法是使用线程同步机制，如互斥锁、条件变量、信号量等，确保对共享数据的访问是原子的。

### 互斥锁和信号量有什么区别？

- 互斥锁只允许一个线程访问共享资源，而信号量允许多个线程同时访问共享资源
- 互斥锁通常用于保护临界区，而信号量通常用于控制资源的访问数量
- 互斥锁可以由同一线程递归获取（使用递归互斥锁），而信号量不能

### 什么是死锁？如何避免死锁？

死锁是指两个或多个线程互相等待对方释放资源，导致所有线程都无法继续执行的状态。避免死锁的主要方法包括：
- 避免一个线程持有多个锁
- 如果必须持有多个锁，确保所有线程以相同的顺序获取锁
- 避免在持有锁的情况下调用可能阻塞的函数
- 使用超时机制，避免无限等待

### 什么是虚假唤醒（Spurious Wakeup）？如何处理？

虚假唤醒是指线程在没有被显式通知的情况下从等待状态被唤醒。处理虚假唤醒的主要方法是使用while循环检查条件，而不是使用if语句，确保条件不满足时继续等待。

### 如何选择合适的线程同步机制？

选择线程同步机制时，需要考虑以下因素：
- 同步需求：是否需要互斥访问、线程间通信等
- 性能要求：锁持有时间的长短、线程竞争的激烈程度等
- 复杂度：实现的难易程度、维护成本等
- 可移植性：是否需要跨平台支持等

根据这些因素选择合适的同步机制，如互斥锁用于简单的资源保护，条件变量用于复杂的线程协作，信号量用于资源数量控制等。

## 总结

线程间同步机制是多线程编程中确保线程安全的关键技术。本文详细介绍了Linux系统中常用的线程间同步机制，包括互斥锁、条件变量、信号量等，分析了它们的原理、使用方法和适用场景，并提供了示例代码帮助理解。

选择合适的同步机制需要考虑同步需求、性能要求、复杂度和可移植性等因素。在实际开发中，应该根据具体情况选择最合适的同步机制，并注意避免常见的错误，如死锁、竞争条件等。

通过合理使用线程间同步机制，可以编写出安全、高效、可靠的多线程程序。