---
date: 2025-07-01
author: Gaaming Zhang
category:
  - 网络
tag:
  - 网络
  - 还在施工中
---

# TCP协议

## 核心概念

**TCP（Transmission Control Protocol）** 是 TCP/IP 协议族中位于传输层的核心协议，提供**面向连接、可靠、有序、字节流**的服务。TCP 协议通过一系列复杂的机制，确保数据在不可靠的 IP 网络上可靠传输，是互联网通信的基础。

### 1. TCP 服务模型

| 特性 | 描述 |
|------|------|
| 面向连接 | 通信前需要先建立连接，通信后需要释放连接 |
| 可靠传输 | 保证数据的无差错、不丢失、不重复、按序到达 |
| 有序交付 | 数据按发送顺序到达接收端 |
| 字节流 | 不保留消息边界，以字节为单位传输 |
| 全双工 | 允许通信双方同时发送和接收数据 |
| 流量控制 | 防止发送方速率过快导致接收方缓冲区溢出 |
| 拥塞控制 | 防止发送方速率过快导致网络拥塞 |

### 2. TCP 数据报结构

TCP 数据报由**首部**和**数据**两部分组成，首部长度可变（20-60 字节），包含以下关键字段：

- **源端口/目的端口**：各 16 位，标识通信的进程
- **序列号（Sequence Number）**：32 位，标识本报文中第一个数据字节的序号
- **确认号（Acknowledgment Number）**：32 位，期望收到的下一个字节的序号
- **数据偏移**：4 位，TCP 首部长度（以 32 位为单位）
- **标志位**：
  - URG：紧急指针有效
  - ACK：确认号有效
  - PSH：推送数据到接收应用
  - RST：重置连接
  - SYN：同步序列号，用于建立连接
  - FIN：结束连接
- **窗口大小**：16 位，接收端可用缓冲区大小（流量控制）
- **校验和**：16 位，用于错误检测
- **紧急指针**：16 位，URG 标志有效时，指向紧急数据的末尾
- **选项**：可变长度，包含 MSS、窗口缩放、SACK 等选项

---

## 连接建立与释放

### 1. 三次握手（3-Way Handshake）

TCP 连接建立采用三次握手机制，确保双方收发能力正常，并初始化序列号：

1. **第一次握手（SYN）**：
   - 客户端发送 SYN 报文，设置 SYN=1，初始序列号 seq=x
   - 客户端进入 SYN_SENT 状态

2. **第二次握手（SYN/ACK）**：
   - 服务端收到 SYN 报文，回复 SYN/ACK 报文
   - 设置 SYN=1，ACK=1，确认号 ack=x+1，初始序列号 seq=y
   - 服务端进入 SYN_RCVD 状态

3. **第三次握手（ACK）**：
   - 客户端收到 SYN/ACK 报文，回复 ACK 报文
   - 设置 ACK=1，确认号 ack=y+1，序列号 seq=x+1
   - 客户端进入 ESTABLISHED 状态
   - 服务端收到 ACK 报文后，也进入 ESTABLISHED 状态

**三次握手的必要性**：
- 防止历史连接的 SYN 报文干扰新连接
- 确保双方都能正常收发数据
- 初始化双方的序列号，为可靠传输奠定基础

### 2. 四次挥手（4-Way Handshake）

TCP 连接释放采用四次挥手机制，允许全双工通信的双方各自独立关闭连接：

1. **第一次挥手（FIN）**：
   - 主动关闭方发送 FIN 报文，设置 FIN=1，序列号 seq=u
   - 主动关闭方进入 FIN_WAIT_1 状态

2. **第二次挥手（ACK）**：
   - 被动关闭方收到 FIN 报文，回复 ACK 报文
   - 设置 ACK=1，确认号 ack=u+1，序列号 seq=v
   - 被动关闭方进入 CLOSE_WAIT 状态
   - 主动关闭方收到 ACK 后，进入 FIN_WAIT_2 状态

3. **第三次挥手（FIN）**：
   - 被动关闭方完成数据发送后，发送 FIN 报文
   - 设置 FIN=1，ACK=1，确认号 ack=u+1，序列号 seq=w
   - 被动关闭方进入 LAST_ACK 状态

4. **第四次挥手（ACK）**：
   - 主动关闭方收到 FIN 报文，回复 ACK 报文
   - 设置 ACK=1，确认号 ack=w+1，序列号 seq=u+1
   - 主动关闭方进入 TIME_WAIT 状态，等待 2MSL 后关闭
   - 被动关闭方收到 ACK 后，进入 CLOSED 状态

### 3. TIME_WAIT 状态

- **持续时间**：2MSL（Maximum Segment Lifetime，报文最大生存时间，通常为 60 秒）
- **作用**：
  - 确保最后一个 ACK 能被对方收到，避免对方超时重发 FIN
  - 确保网络中所有与该连接相关的报文都已消失，防止旧连接报文干扰新连接
- **影响**：大量 TIME_WAIT 连接会占用端口资源，可通过调整内核参数优化

---

## 可靠性与滑动窗口

### 1. 序列号与确认号机制

- **序列号**：
  - 按字节编号，每个字节都有唯一的序列号
  - 初始序列号（ISN）由系统随机生成，避免历史报文干扰
  - 用于标识发送的数据字节，确保有序交付和去重

- **确认号**：
  - 采用累计确认机制，确认号表示期望收到的下一个字节的序号
  - 例如：收到序列号为 100，长度为 50 的数据，确认号为 150
  - 允许接收端批量确认，减少 ACK 报文数量

### 2. 滑动窗口机制

滑动窗口是 TCP 实现流量控制和拥塞控制的核心机制，分为发送窗口和接收窗口：

- **接收窗口（rwnd）**：
  - 由接收端通告，反映接收端的处理能力
  - 动态变化，接收端根据缓冲区使用情况调整
  - 零窗口时，发送端停止发送数据，等待窗口更新

- **发送窗口**：
  - 发送窗口大小 = min(rwnd, cwnd)，其中 cwnd 为拥塞窗口
  - 控制发送端在途数据量，确保网络不拥塞，接收端能及时处理
  - 发送窗口内的数据分为四个部分：
    1. 已发送且已确认
    2. 已发送但未确认
    3. 未发送但可发送
    4. 未发送且不可发送

- **窗口探测机制**：
  - 当接收端通告零窗口时，发送端启动零窗口探测
  - 定期发送小的探测报文，询问接收端是否有可用窗口
  - 收到非零窗口通告后，恢复正常发送

### 3. 重传机制

TCP 采用两种重传机制确保可靠性：

- **超时重传**：
  - 为每个已发送但未确认的报文设置定时器（RTO，Retransmission Timeout）
  - RTO 基于 RTT（Round-Trip Time，往返时间）动态调整：
    - 平滑 RTT（SRTT）：SRTT = α×SRTT + (1-α)×新 RTT 样本
    - RTT 方差（RTTVAR）：RTTVAR = β×RTTVAR + (1-β)×|新 RTT 样本 - SRTT|
    - RTO = SRTT + 4×RTTVAR
  - 定时器超时未收到确认，则重传该报文
  - 重传后 RTO 加倍，采用指数退避策略

- **快速重传**：
  - 当收到 3 个重复 ACK 时，立即重传丢失的报文
  - 无需等待定时器超时，减少重传延迟
  - 基于接收端的反馈，更准确地检测丢包

- **选择性确认（SACK）**：
  - 允许接收端确认非连续的数据包
  - 减少不必要的重传，提高网络利用率
  - 通过 TCP 选项实现，需要双方支持

---

## 拥塞控制

TCP 拥塞控制是为了避免网络拥塞，确保网络资源的公平分配。经典的 TCP 拥塞控制算法包括 Reno、NewReno、SACK 等，现代 Linux 系统默认使用 CUBIC 算法，BBR 是近年来的重要改进。

### 1. 经典 Reno 算法

Reno 算法包含四个阶段：

1. **慢启动（Slow Start）**：
   - 初始 cwnd = 1 MSS（Maximum Segment Size，最大报文段长度）
   - 每收到一个 ACK，cwnd 增加 1 MSS，指数增长
   - 当 cwnd 达到 ssthresh（慢启动阈值）时，进入拥塞避免阶段

2. **拥塞避免（Congestion Avoidance）**：
   - cwnd 线性增长，每 RTT 增加 1 MSS
   - 探测网络容量，避免拥塞

3. **快速重传（Fast Retransmit）**：
   - 收到 3 个重复 ACK 时，立即重传丢失的报文
   - 进入快恢复阶段

4. **快恢复（Fast Recovery）**：
   - ssthresh = cwnd / 2
   - cwnd = ssthresh + 3 MSS
   - 每收到一个重复 ACK，cwnd 增加 1 MSS
   - 收到新的 ACK 后，cwnd 重置为 ssthresh，进入拥塞避免阶段

### 2. 现代拥塞控制算法

- **CUBIC**：
  - Linux 2.6.19 起默认算法
  - 基于三次函数增长，在高带宽延迟积网络中表现更好
  - 减少 RTT 不公平性，适合长肥网络（High Bandwidth Delay Product Network）

- **BBR（Bottleneck Bandwidth and RTT）**：
  - Google 开发，基于带宽和延迟估计
  - 不依赖丢包检测，适合丢包率较高的网络（如无线）
  - 测量瓶颈带宽和最小 RTT，调整发送速率
  - 在视频流等大流量场景表现优异

- **QUIC（Quick UDP Internet Connections）**：
  - 基于 UDP 的新一代传输协议
  - 整合了 TCP 的可靠性、TLS 的安全性和 HTTP/2 的多路复用
  - 0-RTT 连接建立，更快的重传机制

---

## 常见问题与排查

### 1. 连接建立问题

- **SYN Flood 攻击**：
  - 攻击者发送大量 SYN 报文但不回复 ACK，耗尽服务器资源
  - 防护措施：
    - SYN Cookie：无状态连接建立，避免维护半连接队列
    - 增大半连接队列（`net.ipv4.tcp_max_syn_backlog`）
    - 启用 SYN Proxy：由防火墙代为建立连接
    - 调整 `tcp_synack_retries`：减少 SYN/ACK 重传次数

- **连接超时**：
  - 检查网络连通性（`ping`、`traceroute`）
  - 检查目标端口是否开放（`telnet`、`nc`）
  - 检查防火墙规则
  - 检查服务器负载和资源使用情况

### 2. 性能问题

- **高 RTT/丢包**：
  - 使用 `mtr` 或 `ping` 测试链路质量
  - 观察 TCP 重传率（`ss -i` 或网络监控工具）
  - 检查拥塞窗口大小和变化趋势

- **低吞吐量**：
  - 检查 MSS 设置：过小的 MSS 会增加 overhead
  - 检查窗口缩放（Window Scaling）是否启用（`net.ipv4.tcp_window_scaling`）
  - 调整接收缓冲区（`net.core.rmem_max`）和发送缓冲区（`net.core.wmem_max`）
  - 检查是否受限于小包/ACK 延迟，可调整 Nagle 算法和延迟 ACK

- **延迟高**：
  - 检查延迟 ACK 配置（`net.ipv4.tcp_delack_min`、`tcp_delack_max`）
  - 调整 Nagle 算法（`net.ipv4.tcp_nodelay`）
  - 检查 TSO/GRO（TCP Segmentation Offload/Generic Receive Offload）是否启用

### 3. 连接释放问题

- **大量 TIME_WAIT 连接**：
  - 原因：短连接频繁建立和关闭
  - 优化措施：
    - 启用 TIME_WAIT 复用（`net.ipv4.tcp_tw_reuse=1`，仅客户端）
    - 缩短 TIME_WAIT 时间（`net.ipv4.tcp_fin_timeout`，不建议小于 30 秒）
    - 增大本地端口范围（`net.ipv4.ip_local_port_range`）
    - 使用长连接或连接池减少握手开销

- **CLOSE_WAIT 连接堆积**：
  - 原因：被动关闭方未及时调用 close() 函数
  - 排查方法：找出未正确关闭连接的应用程序
  - 解决方法：修复应用程序，确保及时关闭连接

---

## 相关高频面试题及答案

### Q1: 三次握手为什么不是两次？

**答案**：三次握手是为了确保双方都能正常收发数据，并防止历史连接的干扰：
- 第一次握手：客户端 → 服务端，确认服务端能接收
- 第二次握手：服务端 → 客户端，确认服务端能发送，客户端能接收
- 第三次握手：客户端 → 服务端，确认客户端能发送

如果是两次握手，服务端无法确认客户端是否能正常接收数据，可能导致资源浪费（服务端为无效连接分配资源），同时也无法有效防止历史连接的 SYN 报文干扰新连接。

### Q2: 四次挥手中 TIME_WAIT 的作用是什么？

**答案**：TIME_WAIT 状态的主要作用是：
1. **确保最后一个 ACK 能被对方收到**：如果被动关闭方未收到 ACK，会重发 FIN 报文，TIME_WAIT 状态确保主动关闭方能重新发送 ACK
2. **确保网络中所有旧连接的报文都已消失**：等待 2MSL 时间，确保所有与该连接相关的报文都已从网络中消失，防止旧连接报文干扰新连接
3. **避免端口复用冲突**：2MSL 后，该连接的端口才能被新连接安全复用

### Q3: 滑动窗口与拥塞窗口的区别是什么？

**答案**：
- **滑动窗口**：是一个通用概念，包括发送窗口和接收窗口
- **接收窗口（rwnd）**：由接收端通告，反映接收端的处理能力，用于流量控制
- **拥塞窗口（cwnd）**：由发送端维护，反映网络的拥塞状况，用于拥塞控制
- **发送窗口大小**：发送窗口 = min(rwnd, cwnd)，取两者最小值，同时考虑接收端能力和网络状况

### Q4: 快速重传与超时重传的触发条件和优缺点是什么？

**答案**：

| 特性 | 快速重传 | 超时重传 |
|------|----------|----------|
| 触发条件 | 收到 3 个重复 ACK | 定时器超时未收到确认 |
| 重传时机 | 立即重传 | 等待 RTO 时间 |
| 检测准确性 | 高（基于接收端反馈） | 低（可能误判） |
| 恢复速度 | 快 | 慢 |
| 网络开销 | 低 | 高（可能导致拥塞窗口急剧减小） |

### Q5: 延迟 ACK 有何影响？如何优化？

**答案**：
- **延迟 ACK**：接收端不立即发送 ACK，而是延迟一段时间（通常 200ms 或收到下一个数据报文时）合并发送，目的是减少 ACK 数量，降低网络开销

- **影响**：
  - 优点：减少 ACK 报文数量，降低网络带宽消耗
  - 缺点：
    - 增加交互延迟，特别是小包交互场景
    - 与 Nagle 算法结合可能导致 "延迟确认 + Nagle" 延迟，影响实时性

- **优化方法**：
  - 对于实时性要求高的场景，可关闭 Nagle 算法（`TCP_NODELAY` 选项）
  - 调整延迟 ACK 时间（如 Linux 下的 `tcp_delack_min` 和 `tcp_delack_max`）
  - 采用 SACK 选项，减少不必要的重传

### Q6: 如何提升 TCP 吞吐量？

**答案**：
1. **优化网络参数**：
   - 启用窗口缩放（Window Scaling），增大有效窗口
   - 调整接收缓冲区（`rmem`）和发送缓冲区（`wmem`）大小
   - 合理设置 MSS，减少报文数量

2. **启用硬件加速**：
   - 启用 TSO/GRO，利用 NIC 硬件进行 TCP 分段和重组
   - 启用 RSS（Receive Side Scaling），将接收处理分布到多个 CPU 核心

3. **优化拥塞控制算法**：
   - 根据网络特性选择合适的拥塞控制算法（如 CUBIC、BBR）
   - 对于高丢包网络，考虑使用 BBR 算法

4. **减少连接开销**：
   - 使用长连接或连接池，减少握手次数
   - 启用 TCP Fast Open（TFO），实现 0-RTT 连接建立

5. **优化应用层**：
   - 减少小包发送，合并数据发送
   - 合理设置 TCP_NODELAY 和 TCP_CORK 选项
   - 优化应用层协议，减少协议开销

6. **监控和调优**：
   - 监控网络指标：RTT、丢包率、重传率、拥塞窗口等
   - 根据实际情况动态调整参数

### Q7: TCP 与 UDP 的主要区别是什么？

**答案**：

| 特性 | TCP | UDP |
|------|-----|-----|
| 连接类型 | 面向连接 | 无连接 |
| 可靠性 | 可靠传输 | 不可靠传输 |
| 有序性 | 保证有序 | 不保证有序 |
| 流量控制 | 支持 | 不支持 |
| 拥塞控制 | 支持 | 不支持 |
| 首部开销 | 20-60 字节 | 8 字节 |
| 适用场景 | 要求可靠的场景（如 HTTP、FTP、SMTP） | 实时性要求高的场景（如视频流、语音通话、DNS） |
| 传输速度 | 相对较慢 | 相对较快 |
| 连接建立 | 三次握手 | 无 |
| 连接释放 | 四次挥手 | 无 |

### Q8: 什么是 TCP 粘包？如何解决？

**答案**：
- **TCP 粘包**：TCP 是字节流协议，不保留消息边界，多个小数据包可能被合并发送，或者一个大数据包可能被拆分成多个小包发送，导致接收端无法直接区分消息边界

- **解决方法**：
  1. **固定长度消息**：每个消息固定长度，接收端按固定长度读取
  2. **消息头 + 消息体**：在消息头中包含消息长度，接收端先读取消息头，再根据长度读取消息体
  3. **分隔符**：使用特殊分隔符标记消息边界（如换行符、特定字符序列）
  4. **协议约定**：通过应用层协议明确消息格式和边界

### Q9: 什么是 TCP 半连接队列和全连接队列？

**答案**：
- **半连接队列**：
  - 存储处于 SYN_RCVD 状态的连接（已收到 SYN，发送了 SYN/ACK，等待 ACK）
  - 大小由 `net.ipv4.tcp_max_syn_backlog` 控制
  - SYN Flood 攻击会导致半连接队列溢出

- **全连接队列**：
  - 存储处于 ESTABLISHED 状态但尚未被应用程序 accept() 的连接
  - 大小由 `backlog` 参数（listen() 系统调用的第二个参数）和 `net.core.somaxconn` 共同决定，取两者最小值
  - 全连接队列溢出会导致客户端连接失败

### Q10: 什么是 TCP Fast Open？

**答案**：
- **TCP Fast Open（TFO）**：是 TCP 的一个扩展，允许在第一次握手时就发送数据，实现 0-RTT 数据传输
- **工作原理**：
  1. 客户端首次连接服务器时，服务器返回 TFO Cookie
  2. 客户端保存 TFO Cookie
  3. 后续连接时，客户端在 SYN 报文中携带 TFO Cookie 和数据
  4. 服务器验证 TFO Cookie 后，可直接处理数据，无需等待三次握手完成
- **优点**：减少连接建立延迟，提升首包传输速度
- **适用场景**：对延迟敏感的应用，如 HTTPS、即时通讯

---

## 总结

TCP 协议是互联网通信的基础，通过复杂的机制确保可靠传输。理解 TCP 的核心概念、连接管理、可靠性机制和拥塞控制对于网络编程和系统调优至关重要。随着网络技术的发展，TCP 协议也在不断演进，出现了 CUBIC、BBR 等现代拥塞控制算法，以及 QUIC 等基于 UDP 的新型传输协议。

在实际应用中，需要根据具体场景选择合适的 TCP 参数和拥塞控制算法，并结合监控工具进行性能调优，确保网络通信的高效、可靠和低延迟。

