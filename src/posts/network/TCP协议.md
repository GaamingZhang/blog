---
date: 2025-07-01
author: Gaaming Zhang
isOriginal: false
article: true
category:
  - 网络
tag:
  - 网络
---

# TCP协议

## 核心概念

**TCP（Transmission Control Protocol）** 是 TCP/IP 协议族中位于传输层的核心协议，提供**面向连接、可靠、有序、字节流**的服务。TCP 协议通过一系列复杂的机制，确保数据在不可靠的 IP 网络上可靠传输，是互联网通信的基础。

### 1. TCP 服务模型

| 特性 | 描述 |
|------|------|
| 面向连接 | 通信前需要先建立连接，通信后需要释放连接 |
| 可靠传输 | 保证数据的无差错、不丢失、不重复、按序到达 |
| 有序交付 | 数据按发送顺序到达接收端 |
| 字节流 | 不保留消息边界，以字节为单位传输 |
| 全双工 | 允许通信双方同时发送和接收数据 |
| 流量控制 | 防止发送方速率过快导致接收方缓冲区溢出 |
| 拥塞控制 | 防止发送方速率过快导致网络拥塞 |

### 2. TCP 数据报结构

TCP 数据报由**首部**和**数据**两部分组成，首部长度可变（20-60 字节），包含以下关键字段：

- **源端口/目的端口**：各 16 位，标识通信的进程
- **序列号（Sequence Number）**：32 位，标识本报文中第一个数据字节的序号
- **确认号（Acknowledgment Number）**：32 位，期望收到的下一个字节的序号
- **数据偏移**：4 位，TCP 首部长度（以 32 位为单位）
- **标志位**：
  - URG：紧急指针有效
  - ACK：确认号有效
  - PSH：推送数据到接收应用
  - RST：重置连接
  - SYN：同步序列号，用于建立连接
  - FIN：结束连接
- **窗口大小**：16 位，接收端可用缓冲区大小（流量控制）
- **校验和**：16 位，用于错误检测
- **紧急指针**：16 位，URG 标志有效时，指向紧急数据的末尾
- **选项**：可变长度，包含 MSS、窗口缩放、SACK 等选项

### 3. TCP 头部结构

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          源端口 (16位)        |        目标端口 (16位)         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        序列号 (32位)                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        确认号 (32位)                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  头长 |保留|U|A|P|R|S|F|           窗口大小 (16位)             |
|  (4位)|(6位)|R|C|S|S|Y|I|                                      |
|       |    |G|K|H|T|N|N|                                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          校验和 (16位)        |        紧急指针 (16位)         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       选项 (可变长度)                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          数据                                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

TCP头部大小：20-60字节（基本20字节 + 最多40字节选项）

### 4. TCP 与 UDP 的对比

| 特性 | TCP | UDP |
|------|-----|-----|
| 连接性 | 面向连接 | 无连接 |
| 可靠性 | 可靠传输 | 不可靠传输 |
| 有序性 | 有序交付 | 无序交付 |
| 传输效率 | 较低（头部开销大） | 较高（头部开销小） |
| 流量控制 | 有 | 无 |
| 拥塞控制 | 有 | 无 |
| 传输方式 | 面向字节流 | 面向报文 |
| 首部开销 | 20-60 字节 | 8 字节 |
| 应用场景 | 文件传输、邮件、网页浏览 | 视频流、DNS、实时游戏 |

### 5. TCP 的应用场景

- **文件传输**：FTP、HTTP（网页内容）、SMTP（邮件传输）
- **远程登录**：SSH、Telnet
- **数据库访问**：MySQL、PostgreSQL
- **需要可靠传输的场景**：任何对数据完整性要求高的应用

## 连接建立与释放

### 1. 三次握手（3-Way Handshake）

TCP 连接建立采用三次握手机制，确保双方收发能力正常，并初始化序列号：

1. **第一次握手（SYN）**：
   - 客户端发送 SYN 报文，设置 SYN=1，初始序列号 seq=x
   - 客户端进入 SYN_SENT 状态
   - 此时客户端知道：自己的发送和接收能力正常

2. **第二次握手（SYN/ACK）**：
   - 服务端收到 SYN 报文，回复 SYN/ACK 报文
   - 设置 SYN=1，ACK=1，确认号 ack=x+1，初始序列号 seq=y
   - 服务端进入 SYN_RCVD 状态
   - 此时服务端知道：自己的发送和接收能力正常，客户端的发送能力正常

3. **第三次握手（ACK）**：
   - 客户端收到 SYN/ACK 报文，回复 ACK 报文
   - 设置 ACK=1，确认号 ack=y+1，序列号 seq=x+1
   - 客户端进入 ESTABLISHED 状态
   - 服务端收到 ACK 报文后，也进入 ESTABLISHED 状态
   - 此时双方都知道：自己和对方的发送和接收能力都正常

**三次握手的必要性**：
- **防止历史连接的 SYN 报文干扰新连接**：如果使用两次握手，当客户端发送的延迟 SYN 报文到达服务端时，服务端误认为是新连接的请求，建立错误的连接。三次握手可以确保连接是当前建立的，而不是历史残留
- **确保双方都能正常收发数据**：第一次握手验证客户端的发送能力，第二次握手验证服务端的发送和接收能力，第三次握手验证客户端的接收能力
- **初始化双方的序列号**：TCP 是可靠传输协议，需要序列号来保证数据的有序性和去重。三次握手允许双方交换各自的初始序列号（ISN）

**为什么不是四次握手**：三次握手已经足够建立可靠的连接，四次握手会增加不必要的延迟。第二次握手时，服务端发送 SYN 和 ACK 可以合并为一个报文，提高效率。

### 2. 四次挥手（4-Way Handshake）

TCP 连接释放采用四次挥手机制，允许全双工通信的双方各自独立关闭连接：

1. **第一次挥手（FIN）**：
   - 主动关闭方发送 FIN 报文，设置 FIN=1，序列号 seq=u
   - 主动关闭方进入 FIN_WAIT_1 状态
   - 表示主动关闭方没有数据要发送了，但仍可以接收数据

2. **第二次挥手（ACK）**：
   - 被动关闭方收到 FIN 报文，回复 ACK 报文
   - 设置 ACK=1，确认号 ack=u+1，序列号 seq=v
   - 被动关闭方进入 CLOSE_WAIT 状态
   - 主动关闭方收到 ACK 后，进入 FIN_WAIT_2 状态
   - 表示被动关闭方收到了关闭请求，但可能还有数据要发送

3. **第三次挥手（FIN）**：
   - 被动关闭方完成数据发送后，发送 FIN 报文
   - 设置 FIN=1，ACK=1，确认号 ack=u+1，序列号 seq=w
   - 被动关闭方进入 LAST_ACK 状态
   - 表示被动关闭方也没有数据要发送了

4. **第四次挥手（ACK）**：
   - 主动关闭方收到 FIN 报文，回复 ACK 报文
   - 设置 ACK=1，确认号 ack=w+1，序列号 seq=u+1
   - 主动关闭方进入 TIME_WAIT 状态，等待 2MSL 后关闭
   - 被动关闭方收到 ACK 后，进入 CLOSED 状态

**为什么需要四次挥手**：TCP 是全双工协议，每个方向都可以独立关闭。当一方发送 FIN 报文时，仅表示自己没有数据发送了，但仍可以接收对方的数据。因此，双方都需要各自发送 FIN 和 ACK，总共需要四次挥手。

**为什么三次握手可以合并 SYN 和 ACK，而四次挥手不能合并 FIN 和 ACK**：
- **三次握手**：服务端收到 SYN 报文后，可以立即发送 SYN 和 ACK，因为连接建立时双方都没有数据要发送
- **四次挥手**：被动关闭方收到 FIN 报文后，可能还有数据要发送，因此先回复 ACK，等待数据发送完毕后再发送 FIN

### 3. TIME_WAIT 状态

- **持续时间**：2MSL（Maximum Segment Lifetime，报文最大生存时间，通常为 60 秒）
- **作用**：
  1. **确保最后一个 ACK 能被对方收到**：如果最后一个 ACK 丢失，被动关闭方会超时重发 FIN，主动关闭方可以重发 ACK
  2. **确保网络中所有与该连接相关的报文都已消失**：防止旧连接的报文干扰新连接，避免数据混淆
- **影响**：大量 TIME_WAIT 连接会占用端口资源，可能导致端口耗尽
- **优化措施**：
  - 启用 TIME_WAIT 复用（`net.ipv4.tcp_tw_reuse=1`，仅客户端）
  - 缩短 TIME_WAIT 时间（`net.ipv4.tcp_fin_timeout`，不建议小于 30 秒）
  - 增大本地端口范围（`net.ipv4.ip_local_port_range`）
  - 使用长连接或连接池减少握手开销

### 4. TCP 状态转换

- **CLOSED**：初始状态，连接未建立或已关闭
- **LISTEN**：服务端监听状态，等待连接请求
- **SYN_SENT**：客户端已发送 SYN 报文，等待 SYN/ACK
- **SYN_RCVD**：服务端已收到 SYN 报文，已发送 SYN/ACK，等待 ACK
- **ESTABLISHED**：连接已建立，可以传输数据
- **FIN_WAIT_1**：主动关闭方已发送 FIN 报文，等待 ACK
- **FIN_WAIT_2**：主动关闭方已收到 ACK，等待对方 FIN
- **CLOSING**：双方同时关闭，等待对方 ACK
- **TIME_WAIT**：主动关闭方已收到对方 FIN，已发送 ACK，等待 2MSL
- **CLOSE_WAIT**：被动关闭方已收到 FIN，等待应用层关闭
- **LAST_ACK**：被动关闭方已发送 FIN，等待对方 ACK

## 可靠性与滑动窗口

### 1. 校验和机制

**校验和（Checksum）** 是 TCP 首部中的一个 16 位字段，用于检测数据在传输过程中是否发生错误。它是 TCP 可靠性的第一道防线，确保数据完整性。

- **计算方法**：
  - TCP 校验和覆盖 TCP 首部、TCP 数据和伪首部（Pseudo-header）
  - 伪首部包含源 IP 地址、目的 IP 地址、协议号（TCP 为 6）和 TCP 长度
  - 计算时将校验和字段置 0，按 16 位字进行反码求和，最后取反得到校验和

- **校验和的作用**：
  1. **检测传输错误**：检测数据在传输过程中是否发生比特翻转、丢包、乱序等错误
  2. **防止损坏数据被处理**：如果校验和错误，接收端直接丢弃报文，不进行任何处理
  3. **提高可靠性**：配合重传机制，确保只有正确的数据才能被接收端处理

- **校验和的局限性**：
  - 不能检测所有类型的错误（如偶数个比特翻转可能抵消）
  - 不提供纠错功能，只能检测错误
  - 计算和校验会带来一定的 CPU 开销

- **与 IP 校验和的区别**：
  - IP 校验和只覆盖 IP 首部，不包含数据
  - TCP 校验和覆盖 TCP 首部、数据和伪首部，范围更广
  - TCP 校验和是强制的，而 IPv4 中 IP 校验和是强制的，IPv6 中取消了 IP 校验和

### 2. 序列号与确认号机制

- **序列号**：
  - 按字节编号，每个字节都有唯一的序列号
  - 初始序列号（ISN）由系统随机生成，避免历史报文干扰
  - 用于标识发送的数据字节，确保有序交付和去重
  - 序列号是 32 位，循环使用，约 4GB 后回绕

- **确认号**：
  - 采用累计确认机制，确认号表示期望收到的下一个字节的序号
  - 例如：收到序列号为 100，长度为 50 的数据，确认号为 150
  - 允许接收端批量确认，减少 ACK 报文数量
  - 确认号是 32 位，与序列号配合使用

- **序列号回绕问题**：
  - 由于序列号是 32 位，约 4GB 后会回绕
  - TCP 使用 PAWS（Protect Against Wrapped Sequence Numbers）机制防止回绕问题
  - PAWS 使用时间戳选项，确保旧报文不会被误认为是新报文

### 3. 滑动窗口机制

滑动窗口是 TCP 实现流量控制和拥塞控制的核心机制，分为发送窗口和接收窗口：

- **接收窗口（rwnd）**：
  - 由接收端通告，反映接收端的处理能力
  - 动态变化，接收端根据缓冲区使用情况调整
  - 零窗口时，发送端停止发送数据，等待窗口更新
  - 窗口大小在 TCP 首部的窗口大小字段中通告

- **发送窗口**：
  - 发送窗口大小 = min(rwnd, cwnd)，其中 cwnd 为拥塞窗口
  - 控制发送端在途数据量，确保网络不拥塞，接收端能及时处理
  - 发送窗口内的数据分为四个部分：
    1. 已发送且已确认：可以释放
    2. 已发送但未确认：等待确认，需要重传定时器
    3. 未发送但可发送：可以立即发送
    4. 未发送且不可发送：等待窗口更新

- **窗口滑动**：
  - 收到 ACK 后，窗口向右滑动
  - 滑动距离取决于 ACK 确认的字节数
  - 滑动后，新的数据可以发送

- **窗口探测机制**：
  - 当接收端通告零窗口时，发送端启动零窗口探测
  - 定期发送小的探测报文（1 字节），询问接收端是否有可用窗口
  - 收到非零窗口通告后，恢复正常发送
  - 避免死锁：如果窗口更新的 ACK 丢失，发送端会一直等待

- **窗口缩放选项**：
  - 16 位窗口大小最大为 65535 字节，在高带宽延迟积网络中不够用
  - 窗口缩放选项允许窗口大小扩大 2^shift 倍（shift 最大为 14）
  - 例如：窗口大小为 65535，shift=7，实际窗口大小为 65535 × 128 = 8,388,480 字节
  - 需要双方都支持窗口缩放选项

### 4. 重传机制

TCP 采用两种重传机制确保可靠性：

- **超时重传**：
  - 为每个已发送但未确认的报文设置定时器（RTO，Retransmission Timeout）
  - RTO 基于 RTT（Round-Trip Time，往返时间）动态调整：
    - 平滑 RTT（SRTT）：SRTT = α×SRTT + (1-α)×新 RTT 样本（α 通常为 0.125）
    - RTT 方差（RTTVAR）：RTTVAR = β×RTTVAR + (1-β)×|新 RTT 样本 - SRTT|（β 通常为 0.25）
    - RTO = SRTT + 4×RTTVAR
    - RTO 最小值为 200ms，最大值为 120s
  - 定时器超时未收到确认，则重传该报文
  - 重传后 RTO 加倍，采用指数退避策略，避免网络拥塞加剧
  - 超时重传会进入慢启动阶段，重新评估网络状况

- **快速重传**：
  - 当收到 3 个重复 ACK 时，立即重传丢失的报文
  - 无需等待定时器超时，减少重传延迟
  - 基于接收端的反馈，更准确地检测丢包
  - 3 个重复 ACK 表示接收端收到了后续报文，但中间有报文丢失
  - 快速重传后进入快恢复阶段，不进入慢启动

- **选择性确认（SACK）**：
  - 允许接收端确认非连续的数据包
  - 减少不必要的重传，提高网络利用率
  - 通过 TCP 选项实现，需要双方支持
  - SACK 选项包含多个 SACK 块，每个块表示已收到的连续数据范围
  - 例如：SACK 块 [1000:2000] 表示已收到序列号 1000 到 1999 的数据
  - 发送端根据 SACK 信息，只重传丢失的报文，不重传已确认的报文

- **FACK（Forward Acknowledgment）**：
  - SACK 的改进版本，更精确地控制重传
  - 使用 forward sequence number 表示已收到的最高序列号
  - 减少重传的报文数量，提高网络利用率

### 5. 延迟确认与 Nagle 算法

- **延迟确认（Delayed ACK）**：
  - 接收端不立即发送 ACK，而是等待一段时间（通常 200ms）
  - 目的：减少 ACK 报文数量，提高网络利用率
  - 如果收到多个报文，可以合并为一个 ACK
  - 如果有数据要发送，可以捎带 ACK（Piggybacking）
  - 延迟确认可能导致延迟增加，可以通过 `tcp_delack_min` 和 `tcp_delack_max` 调整

- **Nagle 算法**：
  - 目的：减少小包数量，提高网络利用率
  - 机制：如果已发送但未确认的数据小于 MSS，则等待收到 ACK 或积累足够数据后再发送
  - 适用于 Telnet、SSH 等交互式应用
  - 可能导致延迟增加，可以通过 `TCP_NODELAY` 选项禁用
  - 与延迟确认配合使用时，可能导致额外的延迟

## 拥塞控制

TCP 拥塞控制是为了避免网络拥塞，确保网络资源的公平分配。经典的 TCP 拥塞控制算法包括 Reno、NewReno、SACK 等，现代 Linux 系统默认使用 CUBIC 算法，BBR 是近年来的重要改进。

### 1. 拥塞控制的基本概念

- **拥塞窗口（cwnd）**：发送端根据网络拥塞状况调整的窗口大小
- **慢启动阈值（ssthresh）**：慢启动和拥塞避免的分界点
- **拥塞检测**：通过超时或收到 3 个重复 ACK 检测拥塞
- **拥塞控制目标**：在保证网络不拥塞的前提下，最大化网络利用率

### 2. 经典 Reno 算法

Reno 算法包含四个阶段：

1. **慢启动（Slow Start）**：
   - 初始 cwnd = 1 MSS（Maximum Segment Size，最大报文段长度）
   - 每收到一个 ACK，cwnd 增加 1 MSS，指数增长
   - 每个 RTT，cwnd 翻倍
   - 当 cwnd 达到 ssthresh（慢启动阈值）时，进入拥塞避免阶段
   - 慢启动的目的是快速探测网络容量

2. **拥塞避免（Congestion Avoidance）**：
   - cwnd 线性增长，每 RTT 增加 1 MSS
   - 每收到一个 ACK，cwnd 增加 1 MSS × MSS / cwnd
   - 探测网络容量，避免拥塞
   - 拥塞避免的目的是缓慢增加发送速率，避免引发拥塞

3. **快速重传（Fast Retransmit）**：
   - 收到 3 个重复 ACK 时，立即重传丢失的报文
   - 无需等待定时器超时，减少重传延迟
   - 进入快恢复阶段

4. **快恢复（Fast Recovery）**：
   - ssthresh = cwnd / 2
   - cwnd = ssthresh + 3 MSS
   - 每收到一个重复 ACK，cwnd 增加 1 MSS
   - 收到新的 ACK 后，cwnd 重置为 ssthresh，进入拥塞避免阶段
   - 快恢复的目的是在检测到丢包后，快速恢复发送速率

**Reno 算法的局限性**：
- 只能恢复一个丢失的报文，如果多个报文丢失，性能下降
- 在高带宽延迟积网络中，恢复速度慢
- 对丢包敏感，容易触发慢启动

### 3. NewReno 算法

NewReno 是 Reno 的改进版本，主要改进：

- 可以恢复多个丢失的报文
- 使用 partial ACK（部分 ACK）检测多个丢包
- 收到 partial ACK 时，重传下一个丢失的报文，不进入拥塞避免
- 在快恢复阶段，cwnd 减半，但不进入拥塞避免，直到所有丢失的报文都恢复

### 4. SACK 算法

SACK（Selective Acknowledgment）算法：

- 允许接收端确认非连续的数据包
- 通过 SACK 选项告诉发送端已收到的数据范围
- 发送端根据 SACK 信息，只重传丢失的报文
- 减少不必要的重传，提高网络利用率
- 需要双方都支持 SACK 选项

### 5. 现代拥塞控制算法

- **CUBIC**：
  - Linux 2.6.19 起默认算法
  - 基于三次函数增长，在高带宽延迟积网络中表现更好
  - cwnd 的增长函数：W(t) = C × (t - K)^3 + W_max
  - 其中 C 是常数，K 是达到 W_max 的时间，W_max 是上次拥塞时的窗口大小
  - 减少 RTT 不公平性，适合长肥网络（High Bandwidth Delay Product Network）
  - 在高带宽、低丢包率的网络中表现优异

- **BBR（Bottleneck Bandwidth and RTT）**：
  - Google 开发，基于带宽和延迟估计
  - 不依赖丢包检测，适合丢包率较高的网络（如无线）
  - 测量瓶颈带宽（BtlBw）和最小 RTT（RTProp），调整发送速率
  - BBR 有两个阶段：STARTUP（快速启动）和 STEADY（稳定状态）
  - 在视频流等大流量场景表现优异
  - 减少 RTT 抖动，提高用户体验
  - 在 Linux 4.9+ 内核中可用

- **BBR v2**：
  - BBR 的改进版本，解决 BBR 在某些场景下的不公平性问题
  - 增加拥塞检测机制，更好地与其他算法共存
  - 在高丢包率网络中表现更好

- **QUIC（Quick UDP Internet Connections）**：
  - 基于 UDP 的新一代传输协议
  - 整合了 TCP 的可靠性、TLS 的安全性和 HTTP/3 的多路复用
  - 0-RTT 连接建立，更快的重传机制
  - 支持连接迁移，适合移动网络
  - 在 Chrome、Firefox 等浏览器中广泛使用

- **Hybla**：
  - 针对卫星网络等高延迟网络优化
  - 使用归一化 RTT，减少高延迟对性能的影响
  - 在高延迟网络中表现更好

- **Westwood**：
  - 基于带宽估计的拥塞控制算法
  - 通过测量 ACK 间隔估计带宽
  - 在无线网络中表现较好

### 6. 拥塞控制算法的选择

- **高带宽、低延迟网络**：CUBIC、BBR
- **高延迟网络**：Hybla
- **无线网络**：BBR、Westwood
- **卫星网络**：Hybla
- **公平性要求高**：Reno、NewReno
- **视频流、大文件传输**：BBR、CUBIC

可以通过 `sysctl net.ipv4.tcp_congestion_control` 查看和修改拥塞控制算法。

## 常见问题

### 1. 为什么 TCP 需要三次握手，而不是两次或四次？

三次握手是建立可靠连接的最小次数。两次握手无法防止历史连接的干扰，也无法确认双方的接收能力。四次握手虽然更安全，但会增加不必要的延迟。三次握手在安全性和效率之间达到了平衡：

- 第一次握手：客户端发送 SYN，确认客户端发送能力
- 第二次握手：服务端回复 SYN/ACK，确认服务端发送和接收能力，以及客户端发送能力
- 第三次握手：客户端回复 ACK，确认客户端接收能力

### 2. 为什么 TCP 连接释放需要四次挥手，而不是三次？

TCP 是全双工协议，每个方向都可以独立关闭。当一方发送 FIN 报文时，仅表示自己没有数据发送了，但仍可以接收对方的数据。因此，双方都需要各自发送 FIN 和 ACK，总共需要四次挥手。而三次握手可以合并 SYN 和 ACK，是因为连接建立时双方都没有数据要发送。

### 3. TIME_WAIT 状态的作用是什么？为什么需要等待 2MSL？

TIME_WAIT 状态有两个重要作用：

1. **确保最后一个 ACK 能被对方收到**：如果最后一个 ACK 丢失，被动关闭方会超时重发 FIN，主动关闭方可以重发 ACK
2. **确保网络中所有与该连接相关的报文都已消失**：防止旧连接的报文干扰新连接，避免数据混淆

等待 2MSL 是因为：
- 一个报文在网络中的最大生存时间是 MSL
- 主动关闭方发送 ACK 后，需要等待 MSL 确保 ACK 到达对方
- 对方收到 ACK 后，可能需要重发 FIN，再等待 MSL 确保重发的 FIN 消失
- 因此总共需要等待 2MSL

### 4. TCP 和 UDP 的区别是什么？如何选择？

TCP 和 UDP 的主要区别：

| 特性 | TCP | UDP |
|------|-----|-----|
| 连接性 | 面向连接 | 无连接 |
| 可靠性 | 可靠传输 | 不可靠传输 |
| 有序性 | 有序交付 | 无序交付 |
| 传输效率 | 较低（头部开销大） | 较高（头部开销小） |
| 流量控制 | 有 | 无 |
| 拥塞控制 | 有 | 无 |
| 传输方式 | 面向字节流 | 面向报文 |
| 首部开销 | 20-60 字节 | 8 字节 |

选择建议：
- **选择 TCP**：需要可靠传输、有序交付、流量控制的应用，如文件传输、邮件、网页浏览
- **选择 UDP**：需要低延迟、高吞吐量的应用，如视频流、DNS、实时游戏

### 5. 什么是 SYN Flood 攻击？如何防护？

SYN Flood 攻击是一种 DDoS 攻击，攻击者发送大量 SYN 报文但不回复 ACK，耗尽服务器资源：

**攻击原理**：
- 攻击者发送大量 SYN 报文，伪造源 IP 地址
- 服务器为每个 SYN 报文分配资源，进入 SYN_RCVD 状态
- 由于源 IP 是伪造的，服务器永远不会收到 ACK
- 大量半连接耗尽服务器资源，导致无法处理正常请求

**防护措施**：
1. **SYN Cookie**：无状态连接建立，避免维护半连接队列
2. **增大半连接队列**：`net.ipv4.tcp_max_syn_backlog`
3. **启用 SYN Proxy**：由防火墙代为建立连接
4. **调整重传次数**：`net.ipv4.tcp_synack_retries`
5. **启用 RST 攻击防护**：`net.ipv4.tcp_rfc1337`
6. **使用防火墙**：限制 SYN 报文的速率
