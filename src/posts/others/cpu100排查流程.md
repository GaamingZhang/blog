---
date: 2026-01-12
author: Gaaming Zhang
isOriginal: false
article: true
category:
  - 运维
tag:
  - 运维
---

# 服务器CPU占用100%排查流程

## 1. 引言

服务器CPU占用率达到100%是生产环境中常见的紧急故障之一。这种情况会导致服务器响应缓慢、应用程序卡顿甚至崩溃，严重影响业务的正常运行。作为运维工程师或开发人员，快速定位并解决CPU高占用问题是一项必备技能。

本文将详细介绍服务器CPU占用100%的排查流程、常用工具、分析方法和解决方案，帮助读者系统掌握这一关键故障的处理能力。

## 2. CPU占用100%的危害

CPU占用率持续处于100%会对服务器和业务产生多方面的负面影响：

1. **系统响应缓慢**：所有进程都在争夺CPU资源，导致用户请求处理延迟增加
2. **应用程序崩溃**：关键服务可能因CPU饥饿而无法正常运行
3. **服务可用性下降**：负载均衡可能将流量转移到其他服务器，导致集群压力不均衡
4. **硬件损耗增加**：CPU长时间高负载运行会加速硬件老化
5. **数据丢失风险**：在极端情况下，系统可能出现不可预测的行为，导致数据损坏

## 3. 常用排查工具

### 3.1 系统监控工具

#### 3.1.1 top - 实时进程监控

```bash
top
```

- **主要功能**：实时显示系统进程的CPU、内存使用情况
- **关键指标**：
  - `%CPU`：进程CPU使用率
  - `%MEM`：进程内存使用率
  - `PID`：进程ID
  - `USER`：进程所有者
  - `COMMAND`：进程命令
- **交互操作**：
  - `P`：按CPU使用率排序
  - `M`：按内存使用率排序
  - `q`：退出

#### 3.1.2 htop - 增强版top工具

```bash
htop
```

- **主要功能**：top的增强版，提供更友好的界面
- **优势**：
  - 支持鼠标操作
  - 彩色显示不同类型的进程
  - 支持进程树视图

### 3.2 进程分析工具

#### 3.2.1 ps - 查看进程状态

```bash
ps aux | head -20  # 查看前20个进程
ps -eo pid,ppid,cmd,%cpu,%mem --sort=-%cpu | head -20  # 按CPU排序
```

#### 3.2.2 pidstat - 进程CPU使用统计

```bash
pidstat -u 1  # 每秒输出一次进程CPU使用情况
```

### 3.3 线程分析工具

#### 3.3.1 top -H - 查看线程信息

```bash
top -H -p <PID>  # 查看指定进程的线程CPU使用情况
```

#### 3.3.2 pthread_top - 线程监控工具

```bash
pthread_top -p <PID>  # 查看指定进程的线程详细信息
```

### 3.4 CPU性能分析工具

#### 3.4.1 perf - Linux性能分析工具

```bash
perf top -p <PID>  # 实时分析指定进程的CPU热点
perf record -p <PID>  # 记录指定进程的性能数据
perf report  # 分析性能记录文件
```

#### 3.4.2 gdb - 调试工具

```bash
gdb -p <PID>  # 调试指定进程
thread apply all bt  # 查看所有线程的调用栈
```

## 4. 详细排查流程

### 4.1 第一步：确认CPU高占用状态

首先，我们需要确认服务器的CPU确实处于高占用状态：

```bash
# 查看整体CPU使用情况
top -bn1 | grep "%Cpu"

# 查看每个CPU核心的使用情况
mpstat -P ALL 1
```

### 4.2 第二步：定位占用CPU最高的进程

使用top或ps命令找出占用CPU最高的进程：

```bash
# 使用top实时查看
top  # 然后按P键按CPU排序

# 使用ps命令查看
ps aux --sort=-%cpu | head -10
```

### 4.3 第三步：分析进程的线程情况

确定进程后，我们需要查看该进程内部的线程情况，找出占用CPU最高的线程：

```bash
# 查看指定进程的线程情况
top -H -p <PID>

# 查看线程的CPU使用统计
pidstat -p <PID> -t 1
```

### 4.4 第四步：定位线程的具体代码

对于占用CPU最高的线程，我们需要查看其执行的具体代码：

```bash
# 转换线程ID为十六进制（gdb需要十六进制格式）
printf "%x\n" <THREAD_ID>

# 使用perf分析CPU热点
perf top -p <PID>

# 使用gdb查看线程调用栈
gdb -p <PID>
# 在gdb中执行
thread <THREAD_ID_HEX>
bt
```

### 4.5 第五步：分析代码逻辑，定位问题根因

根据线程的调用栈信息，分析代码逻辑，找出导致CPU高占用的原因：

- **无限循环**：检查是否存在没有退出条件的循环
- **死循环**：检查循环条件是否始终为真
- **大量计算**：检查是否存在复杂的数学计算或递归调用
- **资源竞争**：检查是否存在大量的锁竞争或线程上下文切换
- **内存泄漏**：虽然内存泄漏主要影响内存，但严重的内存碎片可能导致CPU高占用

### 4.6 第六步：验证解决方案

针对定位到的问题，提出解决方案并验证：

1. **临时解决**：
   - 重启相关服务
   - 杀死占用CPU过高的进程
   - 增加服务器资源

2. **永久解决**：
   - 修复代码中的逻辑错误
   - 优化算法，减少计算复杂度
   - 改进并发设计，减少资源竞争
   - 增加系统资源，如升级CPU或增加服务器

3. **验证**：
   - 监控CPU使用率是否恢复正常
   - 测试应用程序功能是否正常
   - 观察系统性能指标是否稳定

## 5. 常见问题类型及解决方案

### 5.1 无限循环

**问题表现**：进程始终占用100% CPU，且不会自动恢复

**排查方法**：
```bash
perf top -p <PID>  # 查看CPU热点
```

**解决方案**：
- 修复代码中的循环条件
- 增加退出机制，如超时控制

**示例**：
```python
# 错误代码
while True:
    # 没有退出条件
    process_data()

# 正确代码
start_time = time.time()
timeout = 300  # 5分钟超时
while time.time() - start_time < timeout:
    if process_data():
        break
```

### 5.2 死锁

**问题表现**：多个进程或线程互相等待对方释放资源

**排查方法**：
```bash
# 使用pstack查看进程调用栈
pstack <PID>

# 使用gdb查看线程状态
gdb -p <PID>
thread apply all bt
```

**解决方案**：
- 统一锁的获取顺序
- 使用超时锁
- 减少锁的粒度
- 使用无锁数据结构

### 5.3 大量的上下文切换

**问题表现**：系统CPU使用率高，但单个进程的CPU使用率不高

**排查方法**：
```bash
# 查看上下文切换情况
vmstat 1
# cs列表示每秒上下文切换次数

# 查看每个进程的上下文切换情况
pidstat -w 1
```

**解决方案**：
- 减少线程数量
- 优化线程池大小
- 减少锁的使用频率
- 使用更高效的同步机制

### 5.4 大量IO操作

**问题表现**：进程CPU使用率高，同时IO等待时间长

**排查方法**：
```bash
# 查看IO使用情况
iostat -x 1

# 查看进程IO统计
pidstat -d 1
```

**解决方案**：
- 优化IO操作，减少读写次数
- 使用缓存机制
- 异步IO操作
- 升级存储设备

### 5.5 外部资源请求超时

**问题表现**：进程在等待外部资源时占用大量CPU

**排查方法**：
```bash
# 查看网络连接情况
netstat -antp | grep <PID>

# 查看文件描述符
lsof -p <PID>
```

**解决方案**：
- 增加请求超时时间
- 优化外部资源访问逻辑
- 增加重试机制
- 考虑使用缓存

## 6. 预防措施

### 6.1 监控系统

建立完善的监控系统，及时发现CPU高占用情况：

- 使用Prometheus + Grafana监控系统指标
- 设置CPU使用率告警阈值（如80%）
- 定期分析系统性能趋势

### 6.2 代码质量

提高代码质量，减少CPU高占用问题的发生：

- 进行代码审查，重点检查循环和并发逻辑
- 使用静态代码分析工具
- 进行性能测试，模拟高负载场景

### 6.3 系统优化

优化系统配置，提高CPU资源的利用效率：

- 调整内核参数，如线程调度策略
- 合理配置进程优先级
- 使用cgroups限制进程资源使用
- 定期清理无用进程和服务

### 6.4 容量规划

合理规划系统容量，避免CPU资源不足：

- 根据业务增长预测CPU需求
- 考虑使用自动扩展机制
- 定期评估系统负载情况

## 7. 常见问题

### 7.1 服务器CPU占用100%但没有明显的高占用进程，怎么办？

这种情况通常是由以下原因导致的：

1. **大量低优先级进程**：多个进程各占用少量CPU，但总和达到100%
   - 解决方案：使用`ps aux | awk '$3 > 1' | wc -l`查看高CPU进程数量，然后逐一分析

2. **内核线程占用**：某些内核线程（如kworker）可能占用大量CPU
   - 解决方案：使用`top -H`查看所有线程，包括内核线程，然后分析具体的内核线程

3. **硬件问题**：CPU硬件故障可能导致异常高占用
   - 解决方案：检查系统日志（`dmesg`），查看是否有硬件错误信息

### 7.2 如何快速定位Java应用的CPU高占用问题？

对于Java应用，可以使用以下工具和方法：

1. **使用jps查看Java进程**：
   ```bash
   jps
   ```

2. **使用top -H查看Java线程**：
   ```bash
   top -H -p <Java_PID>
   ```

3. **转换线程ID为十六进制**：
   ```bash
   printf "%x\n" <THREAD_ID>
   ```

4. **使用jstack查看线程栈**：
   ```bash
   jstack <Java_PID> | grep -A 20 <THREAD_ID_HEX>
   ```

5. **使用VisualVM或JProfiler进行分析**：这些工具提供更直观的图形界面，方便分析Java应用性能

### 7.3 CPU占用100%时，如何安全地重启服务？

在CPU高占用时重启服务需要谨慎，避免数据丢失：

1. **优雅关闭**：尽量使用服务的优雅关闭命令（如`systemctl stop service`）

2. **强制关闭**：如果优雅关闭失败，可以使用`kill -15 <PID>`（SIGTERM），如果仍然失败再使用`kill -9 <PID>`（SIGKILL）

3. **数据保护**：在关闭服务前，确保关键数据已保存

4. **监控重启过程**：重启后密切监控服务状态和CPU使用率

### 7.4 如何区分CPU密集型和IO密集型的高CPU占用？

1. **CPU密集型**：
   - 特点：CPU使用率高，IO等待时间低
   - 排查方法：使用`top`命令查看，`%wa`（IO等待）值较低
   - 常见原因：复杂计算、无限循环、死循环

2. **IO密集型**：
   - 特点：CPU使用率高，IO等待时间也高
   - 排查方法：使用`top`命令查看，`%wa`（IO等待）值较高
   - 常见原因：大量磁盘读写、网络请求超时、数据库查询慢

### 7.5 如何防止CPU占用100%导致的系统崩溃？

可以通过以下措施防止系统崩溃：

1. **设置进程资源限制**：使用`ulimit`或`cgroups`限制进程的CPU使用率

2. **启用OOM Killer**：确保系统的OOM Killer功能正常工作，可以在内存不足时杀死占用大量资源的进程

3. **使用看门狗机制**：实现监控脚本，当CPU使用率持续过高时自动重启关键服务

4. **部署高可用集群**：使用负载均衡和集群技术，确保单点故障不会影响整个系统

## 8. 总结

服务器CPU占用100%是一种常见但危害较大的故障。本文详细介绍了CPU高占用的排查流程，包括：

1. **确认问题**：使用top、mpstat等工具确认CPU高占用状态
2. **定位进程**：找出占用CPU最高的进程
3. **分析线程**：查看进程内部的线程情况
4. **定位代码**：使用perf、gdb等工具查看线程执行的具体代码
5. **解决问题**：根据分析结果修复代码或优化系统

同时，本文介绍了常见的CPU高占用问题类型、解决方案和预防措施，以及5个高频常见问题的解答。

掌握CPU高占用的排查和解决能力，对于保障服务器的稳定运行和业务的可用性至关重要。通过建立完善的监控系统、提高代码质量和系统优化，可以有效减少CPU高占用问题的发生，提高系统的稳定性和可靠性。