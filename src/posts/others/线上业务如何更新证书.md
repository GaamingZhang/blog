---
date: 2025-12-24
author: Gaaming Zhang
isOriginal: false
article: true
category:
  - 线上事故复盘
tag:
  - 线上事故复盘
---

# 线上业务如何更新证书

## 概述

证书更新是保障线上业务安全的重要操作，需要在不影响业务可用性的前提下完成。本文将详细介绍线上业务证书更新的各种场景、方法和最佳实践。

## 证书更新前的准备工作

### 证书有效期监控
- 建立证书有效期监控机制，提前30-90天预警（建议关键业务提前90天，一般业务提前30天）
- 使用工具如Prometheus+Grafana、Zabbix、Certbot等监控证书状态
- **Prometheus + Blackbox Exporter 监控配置示例**：
  ```yaml
  # prometheus.yml 中添加证书监控目标
  - job_name: 'tls_certificates'
    static_configs:
      - targets: ['example.com:443', 'api.example.com:443']
    metrics_path: /probe
    params:
      module: [tls_ssl]
    relabel_configs:
      - source_labels: [__address__]
        target_label: __param_target
      - source_labels: [__param_target]
        target_label: instance
      - target_label: __address__
        replacement: blackbox-exporter:9115  # Blackbox Exporter地址
  ```
  ```promql
  # 证书过期时间查询（单位：天）
  (probe_ssl_earliest_cert_expiry{job="tls_certificates"} - time()) / 86400
  
  # 设置告警规则
  - alert: TLSCertExpiringSoon
    expr: (probe_ssl_earliest_cert_expiry{job="tls_certificates"} - time()) / 86400 < 30
    for: 1h
    labels:
      severity: warning
    annotations:
      summary: "TLS certificate expiring soon (instance {{ $labels.instance }})"
      description: "TLS certificate will expire in {{ $value | printf '%.1f' }} days."
  
  - alert: TLSCertExpiringVerySoon
    expr: (probe_ssl_earliest_cert_expiry{job="tls_certificates"} - time()) / 86400 < 7
    for: 1h
    labels:
      severity: critical
    annotations:
      summary: "TLS certificate expiring very soon (instance {{ $labels.instance }})"
      description: "TLS certificate will expire in {{ $value | printf '%.1f' }} days."
  ```
- 定期手动检查证书到期时间：
  ```bash
  # 查看证书过期时间
  openssl x509 -noout -dates -in certificate.crt
  # 查看证书详细信息（包括有效期）
  openssl x509 -noout -text -in certificate.crt | grep -A2 Validity
  ```

### 备份现有证书
- 备份当前使用的证书和私钥到安全位置
- 记录证书部署位置和相关配置文件路径
- 建立回滚机制，确保更新失败时可快速恢复
- **自动化备份脚本示例**：
  ```bash
  #!/bin/bash
  BACKUP_DIR="/backup/certs/$(date +%Y%m%d_%H%M%S)"
  mkdir -p $BACKUP_DIR
  
  # 备份Nginx证书
  cp /etc/nginx/ssl/* $BACKUP_DIR/
  
  # 备份Kubernetes Secret
  kubectl get secret tls-secret -o yaml > $BACKUP_DIR/tls-secret.yaml 2>/dev/null
  
  echo "证书备份完成：$BACKUP_DIR"
  ```

### 准备新证书
- 确保证书申请信息与旧证书一致（CN、SAN、密钥算法等）
- 验证新证书的有效性：
  ```bash
  openssl x509 -noout -text -in new_certificate.crt
  ```
- 确保证书链完整，包含中间证书
- 验证证书与私钥匹配：
  ```bash
  openssl x509 -noout -modulus -in new_certificate.crt | openssl md5
  openssl rsa -noout -modulus -in new_private.key | openssl md5
  ```

## 不同架构下的证书更新方法

### 单服务器架构

#### 传统重启方式
1. 停止服务
2. 替换证书文件
3. 重启服务
4. 验证服务正常

**适用场景**：测试环境、低优先级业务
**优缺点**：简单但会导致服务中断

#### 热重载方式
许多服务支持热重载证书而无需重启，这是生产环境推荐的方式：

**Nginx**：
```bash
# 替换证书文件后执行
nginx -s reload
```

**Apache**：
```bash
# 替换证书文件后执行
apachectl graceful
```

**HAProxy**：
```bash
# 替换证书文件后执行
haproxy -f /etc/haproxy/haproxy.cfg -st $(cat /var/run/haproxy.pid)
```

**适用场景**：对可用性要求较高的单服务器业务
**优缺点**：无服务中断，但需服务支持热重载

### 负载均衡集群架构

#### 滚动更新（Rolling Update）
1. 从负载均衡池中移除部分服务器（设置权重为0或标记为维护模式）
2. 更新这部分服务器的证书
3. 验证服务正常后重新加入集群
4. 依次处理剩余服务器

**适用场景**：所有负载均衡集群
**优缺点**：零 downtime，需合理配置负载均衡权重

**示例1**：使用HAProxy的滚动更新
```bash
# 禁用服务器
echo "disable server mybackend/server1" | socat stdio /var/run/haproxy.sock
# 更新证书后启用服务器
echo "enable server mybackend/server1" | socat stdio /var/run/haproxy.sock
```

**示例2**：使用Nginx Plus的动态配置
```bash
# 使用Nginx Plus API移除服务器
curl -X POST -d '{"op":"remove","path":"/upstreams/mybackend/servers/server1"}' http://localhost:8080/api/3/http/upstreams/mybackend/servers
# 更新证书后添加服务器
curl -X POST -d '{"op":"add","path":"/upstreams/mybackend/servers","value":{"id":"server1","server":"10.0.0.1:80","weight":1}}' http://localhost:8080/api/3/http/upstreams/mybackend/servers
```

#### 蓝绿部署（Blue-Green Deployment）
1. 准备一套与现有环境完全相同的新环境（绿环境）
2. 在绿环境中更新证书
3. 切换负载均衡流量从蓝环境到绿环境
4. 验证成功后，可选择保留或销毁蓝环境

**适用场景**：大规模集群、对稳定性要求极高的业务
**优缺点**：零 downtime，资源消耗较大

### 容器化与微服务架构

#### Kubernetes环境

**使用Secret管理证书**：
```bash
# 创建新的证书Secret
kubectl create secret tls my-tls-secret-new --cert=new.crt --key=new.key -n my-namespace
# 更新Ingress或Service配置以使用新Secret
kubectl patch ingress my-ingress -n my-namespace --type='json' -p='[{"op": "replace", "path": "/spec/tls/0/secretName", "value": "my-tls-secret-new"}]'
```

**自动滚动更新**：
- 配置Deployment的`imagePullPolicy: Always`
- 更新Secret后，手动触发滚动更新：
  ```bash
  kubectl rollout restart deployment/my-app -n my-namespace
  ```
- **验证滚动更新状态**：
  ```bash
  kubectl rollout status deployment/my-app -n my-namespace
  ```

**使用Cert-Manager自动化**：
- 安装Cert-Manager：
  ```bash
  kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.12.0/cert-manager.yaml
  ```
- 配置Let's Encrypt Issuer：
  ```yaml
  apiVersion: cert-manager.io/v1
  kind: ClusterIssuer
  metadata:
    name: letsencrypt-prod
  spec:
    acme:
      server: https://acme-v02.api.letsencrypt.org/directory
      email: admin@example.com
      privateKeySecretRef:
        name: letsencrypt-prod
      solvers:
      - http01:
          ingress:
            class: nginx
  ```
- 配置Certificate资源：
  ```yaml
  apiVersion: cert-manager.io/v1
  kind: Certificate
  metadata:
    name: example-com
    namespace: my-namespace
  spec:
    secretName: example-com-tls
    issuerRef:
      name: letsencrypt-prod
      kind: ClusterIssuer
    commonName: example.com
    dnsNames:
    - example.com
    - www.example.com
    - api.example.com
  ```

**适用场景**：容器化微服务环境
**优缺点**：自动化程度高，需Kubernetes知识

#### Service Mesh（如Istio）

**Istio证书管理架构**：
- **根证书（Root CA）**：最高信任级别，用于签发中间证书
- **中间证书（Intermediate CA）**：由根证书签发，用于签发工作负载证书
- **工作负载证书**：由中间证书签发，用于服务间通信加密

**自动证书轮换**：
- Istio默认自动轮换Sidecar代理证书（默认有效期24小时）
- 控制平面证书默认有效期10年，可手动更新

**手动更新Istio证书**：
1. **生成新的根证书**：
   ```bash
   istioctl x create-ca-root-cert \
     --root-cert=root-cert.pem \
     --key=root-key.pem \
     --cert-chain=cert-chain.pem \
     --org=Istio
   ```

2. **更新Istio控制平面证书**：
   ```bash
   # 更新Istio CA
   istioctl install \
     --set profile=default \
     --set values.global.caAddress=istiod.istio-system.svc:15012 \
     --set values.global.pilotCertProvider=istiod
   ```

3. **强制更新所有工作负载证书**：
   ```bash
   # 滚动更新所有Deployment以获取新证书
   kubectl rollout restart deployment -n my-namespace
   
   # 监控更新进度
   kubectl rollout status deployment/my-app -n my-namespace
   ```

**自定义证书配置**：
```yaml
# Istio安装配置示例，使用自定义证书
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
metadata:
  name: istio-control-plane
spec:
  components:
    pilot:
      k8s:
        env:
        - name: PILOT_CERT_PROVIDER
          value: istiod
  values:
    global:
      caAddress: istiod.istio-system.svc:15012
      pilotCertProvider: istiod
      caCertificates: |
        # 自定义根证书内容
        -----BEGIN CERTIFICATE-----
        ...
        -----END CERTIFICATE-----
```

**高级特性**：
- **mTLS证书过期预警**：可通过Prometheus监控证书有效期
- **证书撤销**：支持通过Istio配置撤销特定服务的证书
- **多CA支持**：可配置多个证书颁发机构

**适用场景**：大规模微服务架构，需要统一流量管理和安全策略
**优缺点**：统一证书管理，自动化程度高，支持细粒度访问控制；但增加了系统复杂度和学习成本

## 零 Downtime 证书更新最佳实践

### 采用支持热重载的服务
- **验证服务热重载能力**：在测试环境中验证证书热重载功能
- **配置服务支持热重载**：
  ```nginx
  # Nginx 配置示例，确保使用支持热重载的配置
  worker_processes auto;
  pid /var/run/nginx.pid;
  
  http {
    # ... 其他配置 ...
    ssl_certificate /etc/nginx/ssl/certificate.crt;
    ssl_certificate_key /etc/nginx/ssl/private.key;
    # ... 其他配置 ...
  }
  ```

### 合理规划更新顺序
- **分层更新策略**：先更新边缘服务（CDN、负载均衡），再更新内部服务
- **优先级排序**：先更新非核心服务，再更新核心服务
- **时间窗口选择**：避开业务高峰期，选择凌晨或低流量时段
- **通知机制**：提前通知相关团队和用户（如需）

### 使用负载均衡实现无缝切换
- **健康检查配置**：确保负载均衡的健康检查能正确检测证书状态
- **流量控制**：逐步调整服务器权重，避免流量突增
- **故障隔离**：更新过程中发现问题的服务器立即隔离

### 自动化更新流程
- **编写自动化脚本**：
  ```bash
  #!/bin/bash
  # 证书自动更新脚本示例
  
  # 备份旧证书
  backup_certs() {
    BACKUP_DIR="/backup/certs/$(date +%Y%m%d_%H%M%S)"
    mkdir -p $BACKUP_DIR
    cp /etc/nginx/ssl/* $BACKUP_DIR/
    echo "备份完成：$BACKUP_DIR"
  }
  
  # 更新证书
  update_certs() {
    cp /tmp/new_cert.crt /etc/nginx/ssl/certificate.crt
    cp /tmp/new_key.key /etc/nginx/ssl/private.key
    chmod 600 /etc/nginx/ssl/private.key
  }
  
  # 热重载服务
  reload_service() {
    nginx -t && nginx -s reload
    if [ $? -eq 0 ]; then
      echo "服务重载成功"
      return 0
    else
      echo "服务重载失败，开始回滚"
      rollback_certs
      return 1
    fi
  }
  
  # 回滚机制
  rollback_certs() {
    LATEST_BACKUP=$(ls -td /backup/certs/* | head -1)
    if [ -d "$LATEST_BACKUP" ]; then
      cp $LATEST_BACKUP/* /etc/nginx/ssl/
      nginx -s reload
      echo "回滚完成"
    fi
  }
  
  # 验证证书
  verify_certs() {
    openssl x509 -noout -dates -in /etc/nginx/ssl/certificate.crt
    curl -v https://localhost --insecure 2>&1 | grep -A 5 "SSL certificate"
  }
  
  # 主流程
  backup_certs
  update_certs
  reload_service && verify_certs
  ```

- **CI/CD流水线集成**：
  - 使用Jenkins、GitLab CI等工具实现证书更新自动化
  - 配置流水线步骤：证书验证 → 备份 → 更新 → 验证 → 通知
  - 实现自动回滚机制

### 监控与告警
- **实时监控**：更新过程中实时监控服务状态和证书信息
- **告警配置**：设置证书更新相关告警（如服务不可用、证书无效）
- **日志分析**：收集和分析更新过程中的日志信息

## 证书更新后的验证

### 证书有效性验证
```bash
# 检查证书有效期
openssl x509 -noout -dates -in /etc/nginx/ssl/certificate.crt

# 验证证书链完整性
openssl verify -CAfile /etc/nginx/ssl/ca.crt /etc/nginx/ssl/certificate.crt

# 检查证书与私钥是否匹配
openssl x509 -noout -modulus -in /etc/nginx/ssl/certificate.crt | openssl md5
openssl rsa -noout -modulus -in /etc/nginx/ssl/private.key | openssl md5
```

### 业务可用性验证
- **浏览器验证**：访问业务URL，检查地址栏证书信息
- **命令行验证**：
  ```bash
  # 检查HTTPS连接
  curl -v https://your-domain.com
  
  # 检查证书详情
  echo | openssl s_client -servername your-domain.com -connect your-domain.com:443 2>/dev/null | openssl x509 -noout -dates
  ```
- **第三方工具验证**：使用SSL Labs等工具进行全面证书检测

### 监控系统验证
- 确认监控仪表盘上证书状态正常
- 检查是否有证书相关告警
- 验证业务指标恢复正常

## 常见问题与解决方案

### 证书更新后服务无法启动
- **权限问题**：确保私钥权限为600
  ```bash
  chmod 600 /etc/nginx/ssl/private.key
  ```
- **证书格式错误**：检查证书是否为PEM格式
  ```bash
  openssl x509 -in certificate.crt -text -noout  # 验证是否为有效的X.509证书
  ```
- **配置错误**：检查服务配置文件中证书路径是否正确
- **证书与私钥不匹配**：验证证书和私钥的modulus值是否相同

### 客户端仍然显示旧证书
- **CDN缓存问题**：清除CDN缓存
- **浏览器缓存问题**：强制刷新浏览器或清除浏览器缓存
- **负载均衡问题**：确保所有后端服务器都已更新证书
- **TLS会话复用**：部分客户端可能复用旧的TLS会话，等待会话超时或重启客户端

### 证书链不完整
- **缺少中间证书**：确保证书文件包含完整的证书链
- **配置错误**：检查服务配置中是否正确指定了中间证书
  ```nginx
  # Nginx配置示例：包含完整证书链
  ssl_certificate /etc/nginx/ssl/fullchain.crt;  # 包含服务器证书和中间证书
  ssl_certificate_key /etc/nginx/ssl/private.key;
  ```
- **验证方法**：使用`openssl verify -CAfile ca.crt certificate.crt`检查证书链完整性

### 证书更新后性能下降
- **证书算法问题**：检查是否使用了低效的加密算法
- **配置优化**：启用会话缓存和会话票证
  ```nginx
  # Nginx TLS性能优化
  ssl_session_cache shared:SSL:10m;
  ssl_session_timeout 10m;
  ssl_session_tickets on;
  ```

## 相关常见问题及答案

### 1. 如何在不重启Nginx服务的情况下更新SSL证书？
**答案**：Nginx支持通过`nginx -s reload`命令进行热重载。更新证书文件后执行此命令，Nginx会重新加载配置和证书，而不会中断现有连接。这是因为Nginx采用了多进程模型，主进程会创建新的工作进程使用新证书，同时等待旧工作进程处理完现有连接后退出。

### 2. 什么是零 downtime 证书更新？如何实现？
**答案**：零 downtime 证书更新是指在证书更新过程中业务服务不中断。实现方法包括：
- 利用负载均衡的滚动更新：逐台服务器更新，保持集群持续可用
- 使用支持热重载的服务：如Nginx、Apache、Envoy等
- 采用蓝绿部署策略：切换流量到已更新证书的备用环境
- 确保更新过程中至少有部分服务器正常提供服务

### 3. Kubernetes环境中如何管理和更新TLS证书？
**答案**：
- 使用Kubernetes Secret存储证书：`kubectl create secret tls my-tls-secret --cert=cert.crt --key=key.key`
- 更新Secret后手动触发Deployment滚动更新：`kubectl rollout restart deployment/my-app`
- 推荐使用Cert-Manager自动化证书管理：支持自动申请、更新和轮换证书
- 可配置证书过期预警和自动更新策略
- 对于K8s自身组件证书，使用`kubeadm certs renew`命令更新

### 4. 什么是证书链？为什么证书链不完整会导致浏览器警告？
**答案**：证书链是从终端用户证书到根CA证书的信任路径，包含终端证书、中间CA证书和根CA证书。浏览器需要验证证书链上的所有证书都有效且受信任。如果证书链不完整，浏览器无法建立完整的信任路径，会显示安全警告。

### 5. 如何监控证书有效期？
**答案**：
- 使用Prometheus+Grafana+Blackbox Exporter监控证书状态
- 配置Zabbix等监控系统的证书过期告警
- 编写脚本定期检查并发送邮件/短信通知
- 使用云服务提供商的证书管理服务（如AWS ACM、阿里云证书服务）
- 使用Certbot的自动续期功能和通知机制
- 第三方工具如Let's Monitor、SSL Labs Monitor等

### 6. 证书更新的最佳实践有哪些？
**答案**：
- 建立证书生命周期管理机制和监控预警
- 提前备份现有证书和配置文件
- 采用支持热重载的服务和架构
- 合理规划更新顺序和时间窗口（低峰期）
- 利用负载均衡实现无缝切换
- 自动化更新流程，减少人为错误
- 更新前后进行充分验证（证书有效性、业务可用性）
- 建立回滚机制，准备应急预案

### 7. 什么是CDN证书？如何更新CDN证书？
**答案**：CDN证书是部署在CDN节点上的SSL/TLS证书，用于加密用户与CDN节点之间的通信。更新CDN证书的步骤：
- 在CDN控制台上传新证书和私钥
- 配置证书绑定到对应的域名
- 等待CDN节点证书同步（通常几分钟到几小时）
- 验证CDN证书更新成功（使用`curl -v`或浏览器检查）
- 部分CDN服务商支持自动证书轮换（如阿里云CDN、Cloudflare）

### 8. 如何验证证书与私钥是否匹配？
**答案**：可以通过比较证书和私钥的模数（modulus）值来验证是否匹配：
```bash
# 获取证书的模数
openssl x509 -noout -modulus -in certificate.crt | openssl md5
# 获取私钥的模数
openssl rsa -noout -modulus -in private.key | openssl md5
```
如果两个MD5值相同，说明证书和私钥匹配。

### 9. 什么是证书撤销列表（CRL）？它与OCSP有什么区别？
**答案**：
- **证书撤销列表（CRL）**：是一份由CA发布的已撤销证书列表，包含被撤销证书的序列号、撤销原因和撤销时间。浏览器需要定期下载完整CRL进行检查。
- **OCSP（在线证书状态协议）**：是一种实时查询证书状态的协议，浏览器可以直接向CA的OCSP服务器查询特定证书是否被撤销。
- **区别**：CRL需要下载完整列表，可能导致性能问题；OCSP是实时查询，更高效但依赖CA服务器可用性。现代浏览器通常同时支持两种机制。

### 10. Apache服务器如何实现零停机证书更新？
**答案**：Apache服务器支持两种方式实现零停机证书更新：
- **配置热重载**：使用`apachectl graceful`命令，该命令会重新加载配置和证书，而不会中断现有连接
- **滚动重启**：使用`systemctl reload httpd`（Systemd环境），同样支持热重载功能
- 确保Apache配置中指定了正确的证书路径，更新证书文件后执行上述命令即可

### 11. 什么是OCSP Stapling？它如何提高证书验证性能？
**答案**：
- **OCSP Stapling**（在线证书状态协议装订）是一种TLS扩展，允许服务器在TLS握手时主动提供证书的OCSP响应，而不是让客户端单独去CA的OCSP服务器查询。
- **性能提升**：
  - 减少客户端延迟：无需单独发起OCSP查询请求
  - 提高隐私性：客户端无需暴露访问的网站信息给CA
  - 增强可靠性：不依赖CA的OCSP服务器可用性
- **配置示例**（Nginx）：
  ```nginx
  ssl_stapling on;
  ssl_stapling_verify on;
  ssl_trusted_certificate /etc/nginx/ssl/fullchain.pem;
  resolver 8.8.8.8 8.8.4.4 valid=300s;
  resolver_timeout 5s;
  ```

### 12. 如何在Service Mesh（如Istio）环境中更新证书？
**答案**：在Service Mesh环境中，证书更新通常由网格控制平面管理：
- **自动证书轮换**：Istio默认会自动轮换Sidecar代理的证书（默认有效期24小时）
- **手动更新根证书**：
  ```bash
  # 生成新的根证书
  istioctl x create-ca-root-cert \
    --root-cert=root-cert.pem \
    --key=root-key.pem \
    --cert-chain=cert-chain.pem \
    --org=Istio
  
  # 更新Istio CA
  istioctl install \
    --set profile=default \
    --set values.global.caAddress=istiod.istio-system.svc:15012 \
    --set values.global.pilotCertProvider=istiod
  ```
- **自定义证书**：可以配置Istio使用自定义证书，更新时需要重新配置并滚动更新相关资源

### 13. 自签名证书和CA签名证书在生产环境中有什么区别？
**答案**：
- **自签名证书**：由自己生成和签名，不被浏览器默认信任，需要手动导入信任。主要用于测试环境或内部服务。
- **CA签名证书**：由受信任的证书颁发机构签名，浏览器默认信任。用于生产环境，确保用户安全访问。
- **生产环境选择**：
  - 面向外部用户的服务必须使用CA签名证书
  - 内部服务可以使用自签名证书或内部CA签发的证书
  - 推荐使用Let's Encrypt等免费CA服务获取生产环境证书

## 八、总结

线上业务证书更新需要综合考虑业务架构、可用性要求和自动化程度，选择合适的更新策略。最佳实践是：建立证书监控机制、采用支持热重载的服务、利用负载均衡实现无缝切换、自动化更新流程，并在更新后进行充分验证。通过合理的规划和执行，可以在保障业务安全的同时，实现证书的零 downtime 更新。