---
date: 2025-12-28
author: Gaaming Zhang
icon: hugeicons:zip-01
cover: /assets/images/cover1.png
sticky: 1000
star: 1000
isOriginal: true
---

# 快速回顾

## TCP 协议

提供**面向连接、可靠、有序、字节流**的服务

### 头部结构

16位源端口、16位目标端口、32位序列号、32位确认号、4位首部长度、6个保留位、6个标志位（URG紧急指针、ACK确认、PSH推送、RST重置、SYN同步、FIN结束）、16位窗口大小、16位校验和、16位紧急指针、最大40字节的选项字段
TCP面向字节流，无边界，**无TCP包总长度字段**。
```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          源端口 (16位)        |        目标端口 (16位)           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        序列号 (32位)                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        确认号 (32位)                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  首部  |  保留      |U|A|P|R|S|F|           窗口大小 (16位)      |
|  长度  | (6位)      |R|C|S|S|Y|I|                              |
| （4位）|            |G|K|H|T|N|N|                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          校验和 (16位)        |        紧急指针 (16位)           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       选项 (可变长度)                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          数据                                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### 首部长度
首部长度4位，单位为4字节，默认20字节，最大60字节，其中选项字段长度为0-40字节。

### 可靠交付
确认机制、超时重传、快速重传、流量控制、拥塞控制

### 滑动窗口
接收窗口、拥塞窗口、发送窗口=min(接收窗口, 拥塞窗口)

### 拥塞控制
- **慢开始**：初始时，拥塞窗口设为1个MSS（最大报文段大小），每收到一个确认，拥塞窗口加倍，指数增加。
- **拥塞避免**：当拥塞窗口超过拥塞避免阈值（ssthresh）时，进入拥塞避免阶段。每个RTT内，拥塞窗口增加1个MSS，线性增加。
- **快重传**：收到重复确认时，立即重传缺失的数据包，而不是等待超时。
- **快恢复**：在快重传后，进入快恢复阶段。当收到3个重复确认时，拥塞避免阈值设置为当前拥塞窗口的一半，拥塞窗口减半。然后进入拥塞避免阶段。

### 超时重传
如果在超时时间内未收到确认，重传数据包。拥塞窗口重新设置为1个MSS（最大报文段大小）

### 三次握手
1. **第一次握手（SYN）**：
    - 客户端发送 SYN 报文，设置 SYN=1，初始序列号 seq=x
    - 客户端进入 SYN_SENT 状态

2. **第二次握手（SYN/ACK）**：
    - 服务端收到 SYN 报文，回复 SYN/ACK 报文
    - 设置 SYN=1，ACK=1，确认号 ack=x+1，初始序列号 seq=y
    - 服务端进入 SYN_RCVD 状态

3. **第三次握手（ACK）**：
    - 客户端收到 SYN/ACK 报文，回复 ACK 报文
    - 设置 ACK=1，确认号 ack=y+1，序列号 seq=x+1
    - 客户端进入 ESTABLISHED 状态
    - 服务端收到 ACK 报文后，也进入 ESTABLISHED 状态

**三次握手的必要性**：
- 防止历史连接的 SYN 报文干扰新连接
- 确保双方都能正常收发数据
- 初始化双方的序列号，为可靠传输奠定基础

### 四次挥手
1. **第一次挥手（FIN）**：
   - 主动关闭方发送 FIN 报文，设置 FIN=1，序列号 seq=x
   - 主动关闭方进入 FIN_WAIT_1 状态

2. **第二次挥手（ACK）**：
   - 被动关闭方收到 FIN 报文，回复 ACK 报文
   - 设置 ACK=1，确认号 ack=x+1，序列号 seq=y
   - 被动关闭方进入 CLOSE_WAIT 状态
   - 主动关闭方收到 ACK 后，进入 FIN_WAIT_2 状态

3. **第三次挥手（FIN）**：
   - 被动关闭方完成数据发送后，发送 FIN 报文
   - 设置 FIN=1，ACK=1，确认号 ack=x+1，序列号 seq=w
   - 被动关闭方进入 LAST_ACK 状态

4. **第四次挥手（ACK）**：
   - 主动关闭方收到 FIN 报文，回复 ACK 报文
   - 设置 ACK=1，确认号 ack=w+1，序列号 seq=x+1
   - 主动关闭方进入 TIME_WAIT 状态，等待 2MSL 后关闭
   - 被动关闭方收到 ACK 后，进入 CLOSED 状态

**CLOSE_WAIT 状态**
- **被动关闭方**：收到第一次挥手 FIN 报文后，进入 CLOSE_WAIT 状态
- **作用**：
  - 通知应用层连接已关闭，等待应用层处理剩余数据
  - 应用层处理完成后，发送 FIN 报文确认关闭

**TIME_WAIT 状态**
- **主动关闭方**：发送最后一个 ACK 报文，进入 TIME_WAIT 状态
- **持续时间**：2MSL（Maximum Segment Lifetime，报文最大生存时间，通常为 60 秒）
- **作用**：
  - 确保最后一个 ACK 能被对方收到，避免对方超时重发 FIN
  - 确保网络中所有与该连接相关的报文都已消失，防止旧连接报文干扰新连接
- **影响**：大量 TIME_WAIT 连接会占用端口资源，可通过调整内核参数优化

## UDP 协议

提供**最小化传输层服务**，只负责数据报的封装和传输，不保证可靠性和顺序。

### 头部结构

16位源端口、16位目的端口、16位UDP包总长度、16位校验和

```
0      7 8     15 16    23 24    31
+--------+--------+--------+--------+
|   Source Port   |   Dest Port     |
+--------+--------+--------+--------+
|     Length      |    Checksum     |
+--------+--------+--------+--------+
|         Data Payload...           |
+-----------------------------------+
```

### 关键特性
- **无连接**：无需三次握手建立连接，直接发送数据报
- **不可靠传输**：无重传机制、无顺序保证、无拥塞控制
- **低开销**：头部仅 8 字节（远小于TCP的20-60字节）
- **支持多播/广播**：一对多通信场景，如IPTV、局域网设备发现
- **实时性优异**：无TCP的重传延迟和队头阻塞问题
- **数据报完整性**：通过校验和机制检测数据损坏（IPv4可选，IPv6必须）

## QUIC 协议

基于 UDP 的新一代传输层协议

### 头部结构

QUIC协议有两种头部格式：**长头部**（Long Header）和**短头部**（Short Header）。

#### 长头部（Long Header）
用于连接建立、版本协商、0-RTT数据传输等场景。

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1|1|1|T|T|     Type (4位)      |    Version (32位)            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Destination Connection ID                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Source Connection ID                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Payload Length (16位)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Packet Number (PN)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Payload...                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**字段说明**：
- **Header Form (1位)**：1表示长头部
- **Fixed Bit (1位)**：固定为1
- **Long Packet Type (2位)**：标识长头部类型
  - 0x00：Initial（初始包）
  - 0x01：0-RTT Protected（0-RTT保护包）
  - 0x02：Handshake（握手包）
  - 0x03：Retry（重试包）
- **Type-Specific Bits (4位)**：类型特定位
- **Version (32位)**：QUIC协议版本（如0x00000001）
- **Destination Connection ID (可变长度)**：目标连接ID，长度由第一个字节的高4位指定
- **Source Connection ID (可变长度)**：源连接ID
- **Payload Length (16位)**：负载数据长度（不包括头部）
- **Packet Number (可变长度)**：包序号，长度由包类型决定
- **Payload（负载数据）**：**包含加密的TLS握手消息或应用数据**

**TLS与QUIC头部的关系**：
- **TLS不在头部**：TLS握手消息和应用数据都作为加密的Payload传输
- **Initial包**：包含TLS ClientHello，使用初始密钥加密
- **Handshake包**：包含TLS握手消息（ServerHello、Certificate、Finished等）
- **0-RTT包**：包含早期应用数据，使用0-RTT密钥加密
- **短头部包**：包含应用数据，使用1-RTT密钥加密

#### 短头部（Short Header）
用于已建立连接的数据传输，头部更紧凑。

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0|1|S|R|R|K|T|  |  Destination Connection ID (0-160位)        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|              Packet Number (8-32位)                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Payload...                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**字段说明**：
- **Header Form (1位)**：0表示短头部
- **Fixed Bit (1位)**：固定为1
- **Spin Bit (1位)**：用于延迟检测
- **Reserved Bits (2位)**：保留位，必须为0
- **Key Phase (1位)**：密钥阶段，用于密钥轮换
- **Reserved Bit (1位)**：保留位
- **Destination Connection ID (可变长度)**：目标连接ID，0-20字节
- **Packet Number (可变长度)**：包序号，1-4字节
- **Payload**：加密的负载数据

### 关键特性

#### 1. 基于 UDP 与用户态实现
- **UDP 作为传输层**：避免 TCP 的内核实现限制，无需操作系统升级即可部署
- **用户态实现**：网络栈在用户空间运行，降低内核态与用户态切换开销，便于快速迭代协议特性
- **端口选择**：默认使用 UDP 443 端口，提高与现有网络基础设施的兼容性

#### 2. 内置 TLS 1.3 加密
- **握手与加密合并**：将传输层握手与 TLS 握手合并，减少往返次数
- **0-RTT 数据传输**：支持首包发送应用数据，进一步降低延迟
- **全程加密**：除必要的 QUIC 头部字段外，所有数据（包括握手过程）均加密
- **前向安全性**：提供完善的密钥协商机制，保障通信安全

#### 3. 真正的多路复用
- **Stream 机制**：连接内支持多个独立的 Stream，每个 Stream 有序但相互独立
- **无队头阻塞（HOL Blocking）**：单个 Stream 的丢包仅影响该 Stream，不影响其他 Stream
- **双向数据流**：每个 Stream 可独立支持双向数据传输
- **流量控制**：基于 Stream 和连接级别的流量控制窗口

#### 4. 连接迁移
- **Connection ID (CID)**：使用 CID 标识连接，而非依赖传统的四元组（源IP、源端口、目的IP、目的端口）
- **路径验证**：通过 PATH CHALLENGE/PATH RESPONSE 帧验证新路径的可达性
- **无缝切换**：支持 IP/端口变更时的连接无缝迁移（如 Wi-Fi 切换到 4G）
- **密钥复用**：连接迁移后复用原有密钥材料，无需重新握手

#### 5. 拥塞控制与可靠性
- **可插拔拥塞控制**：支持 BBR、CUBIC 等多种拥塞控制算法，可根据场景选择
- **独立包号空间**：初始、握手、应用数据使用独立的包号空间，简化重传逻辑
- **基于帧的确认**：使用 ACK Frame 确认收到的数据，支持累计确认和选择性确认
- **快速重传**：基于超时和重复确认的快速重传机制
- **丢失检测**：通过时间戳和包号分析实现高效的丢失检测

### QUIC 握手流程详解

#### 1. 1-RTT 握手（首次连接）

**1-RTT 握手是 QUIC 协议为首次连接设计的高效握手机制**，通过将传输层握手与 TLS 1.3 握手合并，仅需 1 个往返时间即可完成连接建立并开始传输应用数据。以下是详细的握手过程：

**阶段 1：客户端初始数据包（Client Initial）**
- **时间点**：0ms（开始）
- **发送方**：客户端
- **数据包内容**：
  - **公共头部**：包含 QUIC 版本、连接 ID、包号
  - **Token**：首次连接时为空（后续连接会携带服务器提供的 Token 用于防重放）
  - **TLS Client Hello**：加密的 TLS 客户端问候消息，包含：
    - 支持的密码套件
    - 支持的扩展
    - 随机数
    - 会话票据（首次连接时为空）
  - **QUIC 特定参数**：最大数据包大小、支持的拥塞控制算法等
- **加密状态**：使用临时密钥加密（基于客户端随机数和公共参数）
- **目的**：发起连接请求，协商加密参数和协议版本

**阶段 2：服务器初始数据包（Server Initial）**
- **时间点**：~RTT/2（网络传输时间）
- **发送方**：服务器
- **数据包内容**：
  - **公共头部**：包含服务器生成的连接 ID
  - **Token**：服务器生成的连接令牌（用于后续连接的 0-RTT 快速握手）
  - **TLS Server Hello**：加密的 TLS 服务器问候消息，包含：
    - 选定的密码套件
    - 选定的扩展
    - 服务器随机数
  - **TLS Encrypted Extensions**：加密的扩展信息
  - **TLS Certificate**：服务器证书链
  - **TLS Certificate Verify**：服务器证书验证消息
  - **TLS Finished**：TLS 握手完成消息
  - **QUIC 确认帧**：确认收到客户端的 Initial 数据包
- **加密状态**：使用握手密钥加密（基于双方随机数协商）
- **目的**：响应客户端请求，提供服务器证书，完成 TLS 握手的服务器端部分

**阶段 3：客户端完成握手与首次数据**
- **时间点**：~RTT（完成第一个往返）
- **发送方**：客户端
- **数据包内容**：
  - **TLS Finished**：客户端 TLS 握手完成消息（验证服务器证书和握手过程）
  - **应用数据**：首次应用层数据（如 HTTP/3 请求）
  - **QUIC 确认帧**：确认收到服务器的 Initial 数据包
- **加密状态**：使用应用密钥加密（基于完整握手生成的会话密钥）
- **目的**：完成客户端握手，开始传输应用数据

**阶段 4：服务器响应应用数据**
- **时间点**：~1.5RTT
- **发送方**：服务器
- **数据包内容**：
  - **应用数据**：对客户端请求的响应（如 HTTP/3 响应）
  - **QUIC 确认帧**：确认收到客户端的应用数据
- **加密状态**：使用应用密钥加密
- **目的**：开始正常的数据传输

## IP 协议

负责**逻辑寻址和数据包的路由转发**

### 头部结构

4位IP版本、4位IP数据包首部长度、8位服务类型、16位IP数据包总长度、16位IP数据包ID、3个标志位、13位片偏移量、8位TTL、8位上层协议、16位校验和、32位源IP地址、32位目的IP地址、可选选项

```
0         4         8        12        16        20        24        28        32
+---------+---------+---------+---------+---------+---------+---------+---------+
| Version | Header  |     Type of Service (ToS)      |      Total Length (bytes)   |
|  (4bit) | Length  |         (8 bits)                |         (16 bits)           |
+---------+---------+---------+---------+---------+---------+---------+---------+
|          Identification (16 bits)       | Flags | Fragment Offset (13 bits)  |
+---------+---------+---------+---------+---------+---------+---------+---------+
|      Time To Live (TTL)     |    Protocol (8 bits)    |    Header Checksum     |
|          (8 bits)           |                         |      (16 bits)          |
+---------+---------+---------+---------+---------+---------+---------+---------+
|                    Source IP Address (32 bits)                                |
+---------+---------+---------+---------+---------+---------+---------+---------+
|                 Destination IP Address (32 bits)                              |
+---------+---------+---------+---------+---------+---------+---------+---------+
|                        Options (可选，0-40 字节)                               |
+---------+---------+---------+---------+---------+---------+---------+---------+
|                           Data Payload                                        |
+---------+---------+---------+---------+---------+---------+---------+---------+
```

## DNS 协议

**DNS（Domain Name System）** 是互联网的域名系统，将人类可读的域名（如 google.com）转换为机器可识别的 IP 地址（如 142.251.41.14）。DNS 使用**分布式数据库和递归查询**的方式，高效地完成这个转换过程。

### DNS 查询流程（完整示例）

假设用户在浏览器输入 **www.google.com**，DNS 解析过程如下：

#### 第一步：本地查询（客户端）
```
用户浏览器
  ↓
查看本地缓存（浏览器 DNS 缓存）
  ├─ 如果命中 → 直接返回 IP，流程结束
  └─ 如果未命中 → 继续下一步
  ↓
查询本地 DNS 缓存（操作系统缓存）
  ├─ Windows: ipconfig /displaydns
  ├─ Linux/Mac: 无系统级缓存（由应用管理）
  └─ 如果未命中 → 继续下一步
  ↓
查询 /etc/hosts 文件（本地映射）
  ├─ 如果命中 → 直接返回，流程结束
  └─ 如果未命中 → 继续下一步
```

#### 第二步：递归查询（本地 DNS 解析器）

用户配置的本地 DNS 服务器（通常由 ISP 提供）进行递归查询：

```
本地 DNS 解析器（Recursive Resolver）
  例：8.8.8.8（Google DNS），1.1.1.1（CloudFlare）
  ↓
查询根域名服务器（Root Nameserver）
  位置：全球 13 个根服务器（a-m.root-servers.net）
  查询内容："www.google.com 的权威服务器在哪里？"
  回复："问顶级域名服务器（.com 服务器）去"
  ↓
查询顶级域名服务器（TLD Nameserver）
  位置：.com, .org, .net 等的服务器
  查询内容："google.com 的权威服务器在哪里？"
  回复："问 google.com 的权威服务器去"
  ↓
查询权威域名服务器（Authoritative Nameserver）
  位置：google.com 的 DNS 服务器
  查询内容："www.google.com 的 IP 是多少？"
  回复："142.251.41.14"
  ↓
本地 DNS 缓存该结果
  并返回给用户的 DNS 客户端
  ↓
用户操作系统缓存结果
用户浏览器缓存结果
  ↓
浏览器获得 IP 地址，发起 HTTP/HTTPS 连接
```

## HTTP 协议

**HTTP（HyperText Transfer Protocol）** 是应用层无状态、基于请求-响应的协议，运行在 TCP（或 TLS）之上。它定义了浏览器与服务器如何交换数据，常见版本有 **HTTP/1.1、HTTP/2、HTTP/3**。

### HTTP/1.1
**核心特性**：
- **持久连接**（Keep-Alive）：默认开启，同一TCP连接可复用处理多个请求
- **管线化**（Pipelining）：允许在一个TCP连接上连续发送多个请求，但受限于队头阻塞
- **分块传输编码**（chunked）：支持流式传输，无需提前知道内容长度
- **虚拟主机**（Host头）：单IP多域名支持
- **范围请求**（Range头）：支持断点续传
- **缓存机制完善**：ETag、Last-Modified等

### HTTP/2
**核心改进**：
- **二进制分帧**：将报文拆分为二进制帧，提高解析效率
- **多路复用**：单TCP连接上并行传输多个请求-响应，消除应用层队头阻塞
- **头部压缩**：HPACK算法压缩请求/响应头，减少冗余
- **优先级与流量控制**：为不同请求设置优先级，优化资源加载顺序
- **服务端推送**：服务器可主动推送资源到客户端（实践中多禁用）
- **首部字段优化**：静态表、动态表、Huffman编码减少头部开销

**架构对比**：
```
HTTP/1.1: 连接 → 请求1→响应1→请求2→响应2...（串行）
HTTP/2:   连接 → [帧1,帧2,帧3...帧n]（并行）
```

### HTTP/3
**核心特性**：
- **基于 QUIC/UDP**：替代TCP，彻底消除TCP队头阻塞
- **内置 TLS 1.3**：将传输层和加密层握手合并，减少往返次数
- **连接迁移**：基于Connection ID标识连接，支持网络切换（WiFi→4G）时的快速恢复
- **多路复用**：基于QUIC Stream机制，真正的独立并行传输
- **0-RTT 数据传输**：首次连接第二个RTT即可传输数据，后续支持0-RTT
- **可靠性保障**：QUIC内置重传、拥塞控制、流量控制等机制

## HTTPS 协议

HTTPS（Hypertext Transfer Protocol Secure）即安全超文本传输协议，是HTTP协议的安全版本。它通过在HTTP协议基础上加入SSL/TLS（Secure Sockets Layer/Transport Layer Security）加密层，为网络通信提供加密、身份验证和数据完整性保障。

### 1. HTTPS的基本工作原理
HTTPS的基本工作原理是在HTTP协议基础上加入SSL/TLS加密层，通过以下步骤保障通信安全：
1. 客户端与服务器建立TCP连接
2. 客户端与服务器进行SSL/TLS握手，协商加密算法和密钥
3. 客户端与服务器使用协商好的密钥进行加密通信
4. 通信结束后，关闭SSL/TLS连接和TCP连接

### 2. SSL/TLS协议的作用
SSL/TLS协议是HTTPS的核心，主要提供以下功能：
- **加密**：对传输的数据进行加密，防止被窃听
- **身份验证**：验证通信双方的身份，防止中间人攻击
- **完整性校验**：确保数据在传输过程中不被篡改

### 握手过程

#### TLS 1.2 握手过程（2-RTT）

TLS 1.2握手需要2个往返时间（2-RTT）才能完成密钥协商并开始传输应用数据。

**详细步骤**：

**第1步：ClientHello（客户端问候）**
- **支持的TLS版本**：如TLS 1.2
- **随机数**：32字节，用于生成会话密钥
- **支持的密码套件**：如TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
- **支持的压缩方法**：通常为空（压缩有安全风险）
- **扩展**：如Server Name Indication（SNI）、支持的椭圆曲线等

**第2步：ServerHello + Certificate + ServerHelloDone（服务器响应）**
- **ServerHello**：
  - 选择的TLS版本
  - 服务器随机数
  - 选择的密码套件
  - 会话ID（可选）
- **Certificate**：服务器证书链
- **ServerKeyExchange**：服务器密钥交换参数（如ECDHE公钥）
- **ServerHelloDone**：表示服务器消息发送完毕

**第3步：ClientKeyExchange + ChangeCipherSpec + Finished（客户端完成）**
- **ClientKeyExchange**：客户端密钥交换参数（如ECDHE公钥）
- **ChangeCipherSpec**：通知服务器后续消息将使用协商的密钥加密
- **Finished**：验证握手消息的完整性

**第4步：ChangeCipherSpec + Finished（服务器完成）**
- **ChangeCipherSpec**：通知客户端后续消息将使用协商的密钥加密
- **Finished**：验证握手消息的完整性

**第5步：应用数据传输**
- 双方使用协商好的会话密钥进行加密通信

#### TLS 1.3 握手过程（1-RTT）

TLS 1.3通过优化握手流程，将往返时间从2-RTT减少到1-RTT，大幅提升连接建立速度。

**详细步骤**：

**第1步：ClientHello（客户端问候）**
- **支持的TLS版本**：TLS 1.3
- **随机数**：32字节
- **KeyShare**：客户端的密钥交换参数（如X25519公钥）
- **支持的密码套件**：仅支持AEAD密码套件（如AES_128_GCM_SHA256）
- **支持的签名算法**：如RSA-PSS、ECDSA等

**第2步：ServerHello + Certificate + Finished（服务器响应）**
- **ServerHello**：
  - 选择的TLS版本：TLS 1.3
  - 服务器随机数
  - 选择的密码套件
  - KeyShare：服务器的密钥交换参数（如X25519公钥）
- **Certificate**：服务器证书链
- **Finished**：验证握手消息的完整性

**第3步：Finished（客户端完成）**
- 客户端验证服务器证书
- 计算会话密钥
- 发送Finished消息验证握手完整性

**第4步：应用数据传输**
- 双方使用协商好的会话密钥进行加密通信

#### TLS 1.3 0-RTT 握手（后续连接）

TLS 1.3支持0-RTT数据传输，允许客户端在首次握手后的后续连接中，在第一个往返时间内发送应用数据。

**0-RTT的特点**：
- **会话恢复**：客户端使用之前协商的会话参数
- **早期数据**：客户端在第一个往返时间内发送应用数据
- **安全性限制**：0-RTT数据不保证前向安全性，可能被重放攻击
- **适用场景**：适合非敏感数据的快速传输

## ICMP 协议

ICMP（Internet Control Message Protocol，互联网控制消息协议）是 TCP/IP 协议簇中的一个核心协议，**位于网络层**，用于在 IP 主机、路由器之间传递控制消息和差错报告。ICMP 报文封装在 IP 数据报内进行传输（IP 协议号为 1），本身**不提供端口概念**，也不直接用于传输应用层数据。

### 报文结构

ICMP报文由**通用头部**和**类型特定部分**组成，封装在IP数据报中传输。

#### 通用头部结构

所有ICMP报文都包含以下通用头部字段：

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type (8位)  |     Code (8位)  |        Checksum (16位)      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   类型特定部分（可变长度）                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**字段说明**：
- **Type（8位）**：标识ICMP报文类型
- **Code（8位）**：提供该类型的进一步信息
- **Checksum（16位）**：整个ICMP报文的校验和（包括头部和数据）
- **类型特定部分**：根据Type和Code的不同，包含不同的数据

### 常见 ICMP 报文类型

#### 1. 回显请求/应答（Echo Request/Reply）
- **Type/Code**：8/0（请求）、0/0（应答）
- **用途**：用于网络连通性测试（如 ping 命令）
- **特点**：请求和应答保持相同的 Identifier、Sequence 和数据部分

#### 2. 目标不可达（Destination Unreachable）
- **Type**：3
- **常见 Code**：
  - 0：网络不可达（Network Unreachable）
  - 1：主机不可达（Host Unreachable）
  - 3：端口不可达（Port Unreachable）- UDP 特有
  - 4：需要分片但 DF（Don't Fragment）位已设置
  - 5：源路由失败（Source Route Failed）
- **用途**：当路由器或主机无法将数据报转发到目标时返回

#### 3. 超时（Time Exceeded）
- **Type**：11
- **常见 Code**：
  - 0：TTL 超时（TTL Expired in Transit）
  - 1：分片重组超时（Fragment Reassembly Time Exceeded）
- **用途**：TTL 减至 0 时路由器返回该报文（支撑 traceroute）；或接收端重组分片超时

#### 4. 参数问题（Parameter Problem）
- **Type**：12
- **常见 Code**：
  - 0：IP 首部参数错误
  - 1：缺少必要选项
- **用途**：当接收方发现 IP 首部或 ICMP 首部存在错误时返回

#### 5. 重定向（Redirect Message）
- **Type**：5
- **常见 Code**：
  - 0：网络重定向（Network Redirect）
  - 1：主机重定向（Host Redirect）
  - 2：网络 TOS 重定向（Network TOS Redirect）
  - 3：主机 TOS 重定向（Host TOS Redirect）
- **用途**：路由器通知源主机使用更优的下一跳路径

## Linux 命令行工具

### wc 命令
`wc`命令常用于：
- 统计代码文件的行数（查看项目规模）
- 计算文档的单词数和字符数（检查写作要求）
- 验证文本文件的完整性（检查字节数或行数）
- 与其他命令结合使用，处理和分析文本数据

```bash
# 统计文件的行数
wc -l file.txt

# 统计文档中的单词数
wc -w file.txt
```

### top 命令
**top** 是 Linux/Unix 系统中最常用的实时系统监控工具，可以动态显示系统整体运行状态、进程资源占用情况、CPU、内存使用等信息。它是系统管理员和开发人员排查性能问题的第一工具。


**完整的 top 输出示例**：

```
top - 15:30:45 up 10 days,  2:15,  3 users,  load average: 0.52, 0.58, 0.59
Tasks: 245 total,   1 running, 244 sleeping,   0 stopped,   0 zombie
%Cpu(s):  5.2 us,  2.1 sy,  0.0 ni, 92.3 id,  0.3 wa,  0.0 hi,  0.1 si,  0.0 st
MiB Mem :  16384.0 total,   2048.5 free,   8192.3 used,   6143.2 buff/cache
MiB Swap:   8192.0 total,   6144.0 free,   2048.0 used.   6800.5 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
 1234 root      20   0 5123456 512000  10240 S   5.0   3.1  10:23.45 mysqld
 5678 www       20   0 2048576 256000   8192 S   2.0   1.6   5:12.34 nginx
 9012 app       20   0 1024000 128000   4096 R   1.5   0.8   2:34.56 python
 3456 root      20   0  512000  64000   2048 S   0.5   0.4   1:23.45 sshd
```

### tail 命令

tail命令用于查看文件的末尾内容，是Linux/Unix系统中非常常用的命令之一，特别适合查看日志文件的最新输出。

**1. 查看文件末尾10行（默认）**

```bash
# 查看文件末尾10行（默认）
tail /var/log/syslog

# 实时查看文件末尾内容（新增行时自动显示）
tail -f /var/log/syslog
```

### sed 命令

sed（Stream Editor）是**流式文本编辑器**，用于非交互式批量文本处理，广泛应用于日志分析、配置文件修改、数据清洗等场景。

```bash
# 过滤出包含特定 IP 的访问日志
sed -n '/192\.168\.1\.1/p' access.log

# 批量修改服务器端口
sed -i.bak 's/^server_port=.*/server_port=8080/' *.conf 

# 移除 CSV 文件中的引号
sed 's/"//g' data.csv
```

### curl 命令

**curl**（Client URL）是一个强大的命令行工具，用于通过 URL 传输数据。它支持多种协议（HTTP、HTTPS、FTP、SMTP 等），是开发人员、运维人员进行 API 测试、调试网络请求、下载文件的必备工具。

```bash
# 获取网页内容（GET 请求）
curl https://www.example.com

# 下载文件
curl -O https://example.com/file.zip

# 发送 POST 请求
curl -X POST https://api.example.com/users
```

### awk 命令

**awk** 是一个专为文本处理设计的编程语言工具，它结合了模式匹配、数据提取和计算功能，特别适合结构化文本数据的处理和分析。

```bash
# 提取文件中所有 IP 地址
awk '{print $1}' log.txt

# 计算文件中所有数字的总和
awk '{sum += $1} END {print sum}' numbers.txt

# 过滤出包含特定字符串的行
awk '/pattern/ {print $0}' log.txt
```

## Linux 负载相关命令

1. **概览型**：快速了解整体系统状态（top、htop、dstat）
2. **深度型**：详细分析具体指标（vmstat、iostat、netstat）
3. **专项型**：针对特定问题的诊断（perf、strace、tcpdump）

## 上下文切换

**上下文切换**（Context Switch）是指 CPU 从一个进程或线程切换到另一个进程或线程时，保存当前执行状态并恢复新任务执行状态的过程。这是操作系统实现多任务并发执行的核心机制。

**1. CPU 寄存器状态**：
- **通用寄存器**：如 EAX, EBX, ECX, EDX（x86）或 R0-R15（ARM）
- **程序计数器（PC/IP）**：指向下一条要执行的指令地址
- **栈指针（SP）**：指向当前栈顶
- **帧指针（FP/BP）**：指向当前栈帧
- **状态寄存器（EFLAGS）**：包含条件码、中断标志等
- **段寄存器**：CS（代码段）、DS（数据段）、SS（栈段）等

**2. 内存管理信息**：
- **页表基址寄存器**：如 CR3（x86），指向进程的页表
- **TLB（Translation Lookaside Buffer）**：地址转换缓存（切换时需要刷新）

**3. 内核栈信息**：
- 每个进程/线程都有独立的内核栈
- 保存系统调用参数、返回地址等

**4. 其他状态**：
- FPU（浮点运算单元）状态
- SIMD 寄存器（如 SSE、AVX）
- 调试寄存器
- 性能计数器

## 死锁产生的四个条件

**死锁（Deadlock）**是指两个或多个进程/线程在执行过程中，因争夺资源而造成的一种**互相等待**的现象。若无外力干涉，它们都将无法继续执行下去。

死锁的发生必须**同时满足**以下四个条件，缺一不可：

**1. 互斥条件（Mutual Exclusion）**
- **定义**：资源不能被多个进程同时使用，一次只能由一个进程占用
- **说明**：某个资源在一段时间内只能由一个进程持有，其他进程必须等待
- **例子**：打印机、临界区资源、数据库连接
- **特点**：这是资源本身的特性，通常无法破坏

**2. 持有并等待条件（Hold and Wait）**
- **定义**：进程已经持有至少一个资源，但又申请新的资源，而该资源已被其他进程占有
- **说明**：进程在等待获取新资源时，不释放已持有的资源
- **例子**：进程A持有资源1，又申请资源2；进程B持有资源2，又申请资源1
- **特点**：进程保持贪婪，既不放手又想要更多

**3. 不可剥夺条件（No Preemption）**
- **定义**：进程已获得的资源在未使用完之前，不能被强行剥夺，只能由进程自己释放
- **说明**：资源只能由持有者主动释放，外部无法强制回收
- **例子**：某进程持有的锁不能被其他进程强制解锁
- **特点**：资源的归还完全由持有者决定

**4. 循环等待条件（Circular Wait）**
- **定义**：存在一个进程资源的循环等待链，每个进程都在等待下一个进程所持有的资源
- **说明**：形成一个环形等待序列：P1等P2，P2等P3，...，Pn等P1
- **例子**：P1持有R1等待R2，P2持有R2等待R3，P3持有R3等待R1
- **特点**：形成闭环，谁也无法继续执行

## 进程间的通讯方式
1. **管道（Pipe）**
   - 半双工通信，数据只能在一个方向上流动
   - 分为匿名管道和命名管道
2. **命名管道（Named Pipe）**
   - 与管道不同，命名管道可以在不相关的进程之间通信
   - 通常用于服务器与客户端之间的通信
3. **信号（Signal）**
   - 用于进程间通信，也可以用于进程间的事件通知
   - 信号可以是系统定义的，也可以是用户自定义的
4. **消息队列（Message Queue）**
   - 进程可以将消息发送到队列中，其他进程可以从队列中接收消息
   - 消息队列可以实现异步通信
5. **共享内存（Shared Memory）**
   - 多个进程可以直接访问同一块内存区域
   - 共享内存通常用于需要高速度数据交换的场景
6. **信号量（Semaphore）**
   - 用于进程间的同步和互斥

## 进程、线程、协程

**进程（Process）**
- 进程是资源分配的基本单位，是操作系统进行资源分配和调度的独立单位
- 每个进程都有独立的地址空间、内存、数据栈以及其他用于追踪执行的辅助数据
- 进程间相互独立，一个进程崩溃不会影响其他进程

**线程（Thread）**
- 线程是CPU调度的基本单位，是进程中的一个执行单元
- 同一进程内的多个线程共享进程的地址空间、内存、文件句柄等资源
- 线程有自己的程序计数器、寄存器集合和栈

**协程（Coroutine）**
- 协程是一种用户态的轻量级线程，由用户程序自己控制调度
- 协程的切换不需要内核参与，完全由程序控制，开销极小
- 协程在一个线程内执行，通过主动让出CPU来实现调度
- 协程支持协作式调度，当前协程运行时可以主动yield，将控制权交给其他协程
- 协程通常使用单栈或分段栈实现，内存占用极低
- 现代编程语言如Go(Goroutine)、Python(async/await)、JavaScript(async/await)等都内置了协程支持

## 僵尸进程与孤儿进程

**僵尸进程（Zombie Process）**
- 子进程已经终止，但其进程描述符（PCB）仍然保留在系统中
- 已完成执行但父进程尚未调用wait()或waitpid()回收其退出状态
- 占用进程表项，但不占用内存和CPU资源
- 进程状态标记为Z（Zombie）

**孤儿进程（Orphan Process）**
- 父进程先于子进程终止，子进程成为孤儿进程
- 孤儿进程会被init进程（PID=1）或systemd收养
- 由init进程负责回收其退出状态
- 孤儿进程是正常的进程，能正常运行

## 栈和堆的区别

**栈（Stack）**
- 由编译器自动分配和释放的内存区域
- 用于存储局部变量、函数参数、返回地址等
- 遵循后进先出（LIFO）的数据结构
- 连续的内存空间，由高地址向低地址增长
- 分配速度快，但空间有限（通常几MB）

**堆（Heap）**
- 由程序员手动分配和释放（或由垃圾回收器管理）的内存区域
- 用于动态分配内存，生命周期由程序控制
- 不遵循特定的数据结构，内存可能不连续
- 从低地址向高地址增长
- 分配速度较慢，但空间大（受限于虚拟内存）

```
高地址
┌─────────────────┐
│   内核空间      │
├─────────────────┤
│   栈 (Stack)    │ ← 向下增长
│       ↓         │
│                 │
│   (未使用)      │
│                 │
│       ↑         │
│   堆 (Heap)     │ ← 向上增长
├─────────────────┤
│   BSS段         │  未初始化的全局变量
├─────────────────┤
│   Data段        │  已初始化的全局变量
├─────────────────┤
│   Text段        │  代码段（只读）
└─────────────────┘
低地址
```

## Nginx

Nginx是一款轻量级、高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。它以事件驱动、异步非阻塞的架构设计而闻名，能够高效处理大量并发连接，是现代Web架构中不可或缺的核心组件之一。

### 调度算法

1. 轮询 (Round Robin) - 默认算法
**工作原理**：将客户端请求按顺序依次分配给后端服务器，循环往复。

2. 加权轮询 (Weighted Round Robin)
**工作原理**：根据后端服务器的权重值分配请求，权重大的服务器获得更多请求。

3. IP哈希 (IP Hash)
**工作原理**：根据客户端IP地址的哈希值分配请求，同一IP的请求始终分配到同一台后端服务器。

4. 最少连接 (Least Connections)
**工作原理**：将请求分配给当前活跃连接数最少的后端服务器。

5. 加权最少连接 (Weighted Least Connections)
**工作原理**：结合权重和最少连接数，优先分配请求给权重/连接数比值最大的服务器。

6. 最短响应时间 (Least Time) - Nginx Plus
**工作原理**：将请求分配给平均响应时间最短的后端服务器。

7. URL哈希 (URL Hash)
**工作原理**：根据请求URL的哈希值分配请求，同一URL的请求始终分配到同一台后端服务器。

8. 随机算法 (Random)
**工作原理**：随机选择一台后端服务器处理请求。

### Nginx的架构设计

#### （1）进程模型
Nginx采用**多进程模型**，主要包含三类进程：

- **Master进程**：
  - 负责管理Worker进程和Cache Manager进程
  - 读取并验证配置文件
  - 监听信号（如重启、重载配置）
  - 不处理具体请求

- **Worker进程**：
  - 实际处理客户端请求
  - 数量通常与CPU核心数相同（可配置）
  - 采用事件驱动模型处理连接
  - 进程间相互独立，某个进程异常退出不影响其他进程

- **Cache Manager进程**：
  - 管理缓存内容
  - 定期清理过期缓存
  - 控制缓存大小不超过配置的限制

#### （2）事件驱动模型
Nginx的高性能核心在于其**事件驱动模型**，主要组件包括：

- **事件队列**：存储待处理的网络事件
- **事件收集器（Event Collector）**：使用epoll（Linux）、kqueue（BSD/Darwin）、select等系统调用收集事件
- **事件分发器（Event Dispatcher）**：将事件分发给对应的处理模块
- **事件处理器（Event Handler）**：处理具体的网络事件（如连接建立、数据接收、数据发送等）

## MySQL

### B+树索引

B+树是MySQL中最常用的索引数据结构，几乎所有的存储引擎（如InnoDB、MyISAM）都支持B+树索引。

#### B+树的基本结构

B+树是一种多路平衡查找树，具有以下特点：

- **树结构**：由根节点、中间节点和叶子节点组成
- **节点内容**：
  - 根节点和中间节点：只存储键值和指向子节点的指针
  - 叶子节点：存储键值和指向数据记录的指针（或直接存储数据记录）
- **平衡特性**：所有叶子节点都在同一层，树的高度较低
- **顺序链接**：叶子节点之间通过双向链表连接，便于范围查询

#### B+树的查询过程

1. 从根节点开始，根据键值找到对应的子节点
2. 递归地在子节点中查找，直到到达叶子节点
3. 在叶子节点中找到对应的键值，获取指向数据记录的指针
4. 通过指针访问实际的数据记录

#### B+树索引的特点

- **有序性**：索引中的键值是有序排列的
- **范围查询高效**：通过叶子节点的双向链表，可以快速进行范围查询
- **支持前缀匹配**：对于复合索引，支持最左前缀匹配
- **磁盘友好**：节点大小通常与磁盘页大小一致，减少磁盘I/O
- **适合大量数据**：树的高度较低，即使数据量大，查询效率也很高

## Kubernetes

### 就绪探针和存活探针的区别

在Kubernetes中，探针（Probes）是用于监控容器健康状态的关键机制，确保应用程序的可靠性和高可用性。存活探针和就绪探针是最常用的两种探针，它们分别解决不同的问题场景：

**存活探针（Liveness Probe）**：
- **目的**：检测容器是否还活着（是否死锁、假死）
- **失败后果**：重启容器
- **使用场景**：检测应用程序是否陷入死锁、无限循环等无法自动恢复的状态

**就绪探针（Readiness Probe）**：
- **目的**：检测容器是否准备好接收流量
- **失败后果**：从Service的Endpoints中移除，不会重启容器
- **使用场景**：应用启动需要时间、依赖服务未就绪、临时不可用

### 核心概念

**Pod**
- K8s 最小部署单元，包含一个或多个紧密关联的容器
- 共享网络命名空间（同一 Pod 内容器通过 localhost 通信）
- 共享存储卷（可以挂载相同的 Volume）
- 共享 PID 和 IPC 命名空间（可选）
- 支持探针机制（liveness、readiness、startup）确保容器健康
- 包含 Init Container（初始化容器），在主容器启动前执行

**Service**
- 为 Pod 提供稳定的网络访问入口（固定 IP 和 DNS 名称）
- 通过标签选择器（label selector）动态关联 Pod
- 支持多种类型：
  - ClusterIP：集群内部访问（默认）
  - NodePort：暴露端口到所有节点
  - LoadBalancer：结合云平台负载均衡器
  - ExternalName：通过 DNS CNAME 指向外部服务
  - Headless：无头服务，不分配 ClusterIP，用于 StatefulSet 服务发现

**Deployment**
- 管理无状态应用的部署、扩展和更新
- 通过 ReplicaSet 控制 Pod 副本数量
- 支持滚动更新（RollingUpdate）和蓝绿部署（Blue-Green）
- 支持回滚到之前的版本
- 配置更新策略（maxSurge、maxUnavailable）控制更新过程

**StatefulSet**
- 管理有状态应用（如数据库、缓存）
- 为 Pod 提供稳定的网络标识（主机名、域名）
- 支持稳定的持久化存储
- 有序部署和删除（按序号）

**DaemonSet**
- 在每个节点上运行一个 Pod 副本
- 用于部署系统级服务（如日志收集、监控代理）
- 自动适配节点增减

**Job/CronJob**
- Job：执行一次性任务，完成后停止
- CronJob：定期执行任务（类似 Linux cron）

**Namespace**
- 逻辑隔离资源，实现多租户环境
- 提供资源配额（ResourceQuota）和限制范围（LimitRange）
- 默认命名空间：
  - default：默认用户空间
  - kube-system：系统组件空间
  - kube-public：公共空间，所有用户可读
  - kube-node-lease：节点心跳信息

**ConfigMap/Secret**
- ConfigMap：存储非敏感配置信息，支持环境变量和文件挂载
- Secret：存储敏感信息（密码、证书），默认 Base64 编码
  - Opaque：通用 Secret
  - docker-registry：Docker 镜像仓库认证
  - tls：TLS 证书

**Volume**
- 持久化存储抽象，生命周期与 Pod 无关
- 支持多种后端：本地存储、云存储、分布式存储（如 Ceph、GlusterFS）
- PVC（PersistentVolumeClaim）：动态申请存储
- PV（PersistentVolume）：存储资源池

### 控制平面组件（Master）

**kube-apiserver**
- 集群的统一入口，提供 RESTful API 接口
- 处理和验证所有客户端请求（kubectl、kubelet、控制器等）
- 实现认证（Authentication）、授权（Authorization）和准入控制（Admission Control）
- 作为集群的 "枢纽"，所有组件都通过它进行通信
- 与 etcd 交互存储和获取集群状态数据

**etcd**
- 分布式键值对（KV）存储系统
- 保存集群所有配置和状态数据（如 Pod 定义、Service、ReplicaSet 等）
- 提供强一致性保证，是集群的 "唯一事实来源"
- 支持高可用部署（通常为奇数个节点，如 3、5、7 个）

**kube-scheduler**
- 负责 Pod 的调度决策
- 监听待调度的 Pod，根据以下因素选择合适节点：
  - 资源需求（CPU、内存、GPU 等）
  - 节点资源可用性
  - 亲和力（Affinity）和反亲和力（Anti-Affinity）规则
  - 节点污点（Taint）和容忍度（Toleration）
  - 拓扑约束（Topology Constraints）
  - 其他调度策略

**kube-controller-manager**
- 运行各种控制器进程的组件
- 确保集群实际状态与期望状态一致
- 包含的主要控制器：
  - Node Controller：管理节点生命周期
  - Replication Controller：维持 Pod 副本数量
  - Deployment Controller：管理 Deployment 资源
  - StatefulSet Controller：管理有状态应用
  - Endpoints Controller：维护 Service 与 Pod 的关联
  - Service Account & Token Controller：管理服务账号和令牌

**cloud-controller-manager**
- 与云平台交互的控制器集合
- 实现与云服务商的特定功能集成
- 包括的主要控制器：
  - Node Controller：与云平台交互管理节点
  - Route Controller：配置网络路由
  - Service Controller：管理云平台负载均衡器
  - Volume Controller：管理云存储卷

### Node 组件

**kubelet**
- 运行在每个节点上的核心代理组件
- 负责管理 Pod 生命周期的各个阶段：创建、启动、监控、停止和销毁
- 与 kube-apiserver 通信，接收 Pod 规范并确保节点上运行的容器与规范一致
- 执行容器健康检查（通过探针机制）
- 向 kube-apiserver 报告节点和 Pod 的状态、资源使用情况
- 管理节点上的卷（Volume）和网络

**kube-proxy**
- 运行在每个节点上的网络代理组件
- 实现 Kubernetes Service 的网络功能
- 维护网络规则（使用 iptables 或 ipvs 模式）：
  - ClusterIP 类型：通过 DNAT 实现内部访问
  - NodePort 类型：在每个节点上打开端口转发
  - LoadBalancer 类型：配合云平台负载均衡器
- 提供简单的负载均衡功能（轮询算法）
- 支持会话亲和性（Session Affinity）

**容器运行时**
- 负责容器的实际运行环境
- 通过容器运行时接口（CRI）与 kubelet 交互
- 支持多种实现：
  - Docker：最常用的容器运行时（但 Kubernetes 已逐渐减少对 Docker 的直接依赖）
  - containerd：轻量级容器运行时，专注于核心功能
  - CRI-O：专门为 Kubernetes 设计的容器运行时
  - rkt：由 CoreOS 开发的容器运行时
- 负责容器镜像的拉取、容器的创建、运行、停止和删除
- 管理容器的网络、存储和资源隔离

### Pod 拉不起应该怎么排查

**排查原则**：从外到内，从简到繁，逐层深入

```
排查顺序：
1. 查看 Pod 状态 (kubectl get/describe)
2. 查看容器日志 (kubectl logs)
3. 查看事件信息 (kubectl events)
4. 检查资源配额 (Resource Quota)
5. 检查节点状态 (Node)
6. 检查网络策略 (Network Policy)
7. 检查存储卷 (PV/PVC)
8. 检查安全策略 (Security Context)
```

**常见 Pod 状态及排查方法**

| 状态                           | 说明              | 常见原因                         | 排查方法                 |
| ------------------------------ | ----------------- | -------------------------------- | ------------------------ |
| **Pending**                    | Pod已创建但未调度 | 资源不足、节点选择器、污点容忍   | 检查资源、节点、调度策略 |
| **ImagePullBackOff**           | 镜像拉取失败      | 镜像不存在、认证失败、网络问题   | 检查镜像名、Secret、网络 |
| **CrashLoopBackOff**           | 容器反复崩溃      | 应用错误、配置错误、健康检查失败 | 查看日志、检查配置       |
| **Error**                      | 容器异常退出      | 应用崩溃、OOM、启动失败          | 查看日志、资源限制       |
| **Running**                    | 运行中但不正常    | 应用逻辑错误、探针失败           | 查看日志、检查探针       |
| **Terminated**                 | 容器已终止        | 任务完成或异常退出               | 查看退出码和原因         |
| **Unknown**                    | 状态未知          | 节点失联、kubelet问题            | 检查节点、kubelet        |
| **CreateContainerConfigError** | 容器配置错误      | ConfigMap/Secret缺失             | 检查配置资源             |
| **Init:Error**                 | Init容器失败      | Init容器异常                     | 查看Init容器日志         |

### Pod跨节点访问的完整流程

```
场景：Node1上的Pod A (10.244.1.10) 访问 Node2上的Pod B (10.244.2.20)

┌─────────────────────────────────────────────────────────────┐
│                         Node 1                              │
│  ┌──────────────────────────────────────────────┐           │
│  │  Pod A (10.244.1.10)                         │           │
│  │  ┌──────────────────────────────────────┐    │           │
│  │  │  Container                           │    │           │
│  │  │  eth0: 10.244.1.10                   │    │           │
│  │  └───────────────┬──────────────────────┘    │           │
│  │                  │                           │           │
│  │            veth pair 虚拟网线                 │           │
│  │                  │                           │           │
│  └──────────────────┼───────────────────────────┘           │
│                     │                                       │
│  ┌──────────────────▼───────────────────────────┐           │
│  │  cni0 网桥 (10.244.1.1)                       │           │
│  └──────────────────┬───────────────────────────┘           │
│                     │                                       │
│  ┌──────────────────▼────────────────────────────┐          │
│  │  Node网络栈 (eth0: 192.168.1.10)               │          │
│  └──────────────────┬────────────────────────────┘          │
└─────────────────────┼───────────────────────────────────────┘
                      │
                      │  物理网络/Overlay网络
                      │
┌─────────────────────▼───────────────────────────────────────┐
│                         Node 2                              │
│  ┌──────────────────┬────────────────────────────┐          │
│  │  Node网络栈 (eth0: 192.168.1.11)               │          │
│  └──────────────────┼────────────────────────────┘          │
│                     │                                       │
│  ┌──────────────────▼────────────────────────────┐          │
│  │  cni0 网桥 (10.244.2.1)                       │           │
│  └──────────────────┬────────────────────────────┘          │
│                     │                                       │
│  ┌──────────────────▼────────────────────────────┐          │
│  │            veth pair                          │          │
│  │                  │                            │          │
│  │  ┌───────────────▼──────────────────────┐   │            │
│  │  │  Container                            │   │           │
│  │  │  eth0: 10.244.2.20                   │   │            │
│  │  └──────────────────────────────────────┘   │            │
│  │  Pod B (10.244.2.20)                         │           │
│  └──────────────────────────────────────────────┘           │
└─────────────────────────────────────────────────────────────┘
```

### Deployment实现Pod部署的详细流程

当用户使用`kubectl apply -f deployment.yaml`命令部署应用时，Kubernetes会执行以下完整流程：

#### 3.1 配置文件解析与验证

1. **文件解析**：Kubernetes API服务器解析Deployment YAML文件
2. **语法验证**：检查YAML语法和字段合法性
3. **权限验证**：验证用户是否有创建Deployment的权限
4. **存储配置**：将验证通过的配置存储到etcd数据库中

#### 3.2 Deployment资源创建

1. **资源创建**：API服务器创建Deployment资源对象
2. **事件触发**：触发Deployment控制器的协调循环
3. **ReplicaSet生成**：Deployment控制器根据Pod模板生成新的ReplicaSet

#### 3.3 Pod的创建与调度

1. **ReplicaSet协调**：ReplicaSet控制器接收到新的ReplicaSet资源
2. **Pod创建请求**：向API服务器发送Pod创建请求
3. **调度决策**：Scheduler根据资源需求和调度策略将Pod分配到合适的节点
4. **Pod启动**：Kubelet在目标节点上启动Pod并监控其状态

#### 3.4 状态确认与健康检查

1. **状态监控**：Kubelet持续监控Pod的容器状态
2. **健康检查**：执行livenessProbe和readinessProbe验证Pod健康状态
3. **状态更新**：将Pod状态更新到API服务器
4. **部署完成**：当所有Pod都处于Running状态且通过健康检查后，Deployment状态变为Available

### Pod调度的大致流程

Pod从创建到最终在Node上运行的过程可以概括为以下几个主要阶段：

1. **Pod创建**：用户或控制器通过API服务器创建Pod资源
2. **验证和准入控制**：API服务器验证Pod配置并执行准入控制
3. **调度决策**：调度器选择最合适的Node来运行Pod
4. **绑定**：将Pod绑定到选定的Node
5. **容器运行**：Node上的kubelet负责启动Pod中的容器

## Docker

### 隔离机制

Docker 容器隔离基于 Linux 内核的三大核心技术：**Namespace（命名空间）**、**Cgroups（控制组）** 和 **Union FS（联合文件系统）**，实现进程、网络、文件系统、资源的多维度隔离。这些技术共同作用，使得容器能够在共享宿主内核的同时，实现高度的隔离性和安全性。

#### Namespace（命名空间）- 视图隔离

Namespace 是 Linux 内核提供的一种轻量级虚拟化技术，通过为容器创建独立的系统资源视图，让容器"以为"自己独占整个系统。

**进程隔离** PID Namespace
- **功能**：为容器创建独立的进程 ID 命名空间，使容器内的进程 ID 从 1 开始，与宿主机进程 ID 隔离

**网络隔离** Network Namespace
- **功能**：为容器创建独立的网络栈，包括网卡、IP 地址、路由表、iptables 规则和端口号

**文件系统隔离** Mount Namespace
- **功能**：为容器创建独立的挂载点，使容器内的挂载操作不影响宿主机

**主机名隔离** UTS Namespace
- **功能**：为容器创建独立的主机名，使容器内的主机名与宿主机不同

**进程间通信隔离** IPC Namespace
- **功能**：为容器创建独立的 IPC 命名空间，使容器内的进程间通信不影响宿主机

**用户隔离** User Namespace
- **功能**：为容器创建独立的用户命名空间，使容器内的用户 ID 与宿主机不同

#### Cgroup Namespace（控制组隔离，Linux 4.6+）

**功能**：隔离容器内的 Cgroup 视图，使容器只能看到自己的 Cgroup 层次结构
- **资源限制**：限制进程组可以使用的资源总量
- **优先级分配**：为不同进程组分配不同的资源使用优先级
- **资源监控**：统计进程组使用的资源量
- **资源控制**：暂停/恢复进程组，或终止超出资源限制的进程

**隔离效果**：
  - 容器内无法查看或修改宿主机的 Cgroup 配置
  - 容器只能管理自己的资源限制

**实现细节**：
  - 每个 Cgroup Namespace 有自己的 Cgroup 根目录
  - 容器内的 `/sys/fs/cgroup` 挂载点只显示容器自己的 Cgroup

#### Union FS（联合文件系统）- 文件隔离

Union FS 是一种分层、轻量级的文件系统，允许将多个不同的文件系统挂载到同一个目录下，形成一个统一的文件系统视图。Docker 使用 Union FS 实现镜像的分层存储和容器的文件系统隔离。

**分层存储机制**

- **镜像层**：只读层，由 Dockerfile 中的指令生成
- **容器层**：可写层，在容器运行时创建，用于存储容器的修改
- **共享机制**：多个容器可以共享同一个镜像层，节省磁盘空间

**写时复制（Copy-on-Write）**

- **原理**：当容器修改文件时，系统会将该文件从只读的镜像层复制到可写的容器层，然后进行修改
- **优势**：
  - 节省磁盘空间，多个容器共享镜像层
  - 提高容器启动速度，无需复制整个镜像
  - 保证镜像的完整性，防止被意外修改

### docker容器创建流程

1. Docker CLI解析命令并发送请求给Docker Daemon
2. Docker Daemon检查本地是否存在`nginx:latest`镜像，如果不存在则从Docker Hub拉取
3. Docker Daemon为容器创建命名空间和控制组
4. Docker Daemon配置网络，创建veth pair并连接到docker0网桥，设置端口映射
5. Docker Daemon配置存储，创建容器层并挂载镜像层，绑定宿主机的`/my/data`目录到容器的`/app/data`目录
6. Docker Daemon设置环境变量`ENV=production`
7. Docker Daemon通过containerd和runc创建容器进程，执行nginx命令
8. 容器在后台运行，Docker CLI返回容器ID

## kafka

### 文件结构

每个Partition由多个Segment（段）组成，每个Segment包含：
- `.log`文件：存储实际消息数据
- `.index`文件：存储消息索引，通过offset快速定位
- `.timeindex`文件：存储时间戳索引，支持按时间查询

```
Partition
├── Segment 1
│   ├── 00000000000000000000.log
│   ├── 00000000000000000000.index
│   └── 00000000000000000000.timeindex
├── Segment 2
│   ├── 00000000000000000010.log
│   ├── 00000000000000000010.index
│   └── 00000000000000000010.timeindex
└── Segment 3
    ├── 00000000000000000020.log
    ├── 00000000000000000020.index
    └── 00000000000000000020.timeindex
```

```
Message Format
├── CRC32（4字节）：校验和
├── Magic Byte（1字节）：版本号
├── Attributes（1字节）：压缩类型、时间戳类型
├── Timestamp（8字节）：时间戳
├── Key Length（4字节）：Key长度
├── Key（变长）：Key内容
├── Value Length（4字节）：Value长度
└── Value（变长）：Value内容
```

**文件的清理策略**

Kafka支持两种消息清理策略：

**基于时间的清理**：
```properties
log.retention.hours=168  # 保留7天
```

**基于大小的清理**：
```properties
log.retention.bytes=1073741824  # 保留1GB
```

**日志超过阈值后，创建新的日志**：
```properties
log.segment.bytes=1073741824  # 每个段1GB
log.retention.check.interval.ms=300000  # 每5分钟检查一次
```

### 9. kafka的Rebalance（重平衡）是什么？

Rebalance是指消费者组成员变化或分区变化时，Kafka重新分配分区和消费者关系的过程。

1. 停止所有消费者消费
2. 选举新的协调节点，Group Coordinator
3. 新的Coordinator通知所有消费者组成员新的分配方案
4. 每个消费者组成员重新订阅分区
5. 消费者组成员开始消费新的分区

**Rebalance的影响**：
1. **消费暂停**：所有消费者停止消费，直到Rebalance完成
2. **消息积压**：消费暂停期间，消息会积压
3. **重复消费**：Rebalance可能导致重复消费
4. **性能下降**：频繁的Rebalance会影响消费性能

**具体选择过程**

1. 使用消费者组ID（group ID）的哈希值
2. 对集群中Broker总数取模
3. 计算结果对应的Broker就是该消费者组的Group Coordinator

**选择范围**
- 从所有Broker节点中选择 ：Group Coordinator是从Kafka集群中的所有Broker节点中选择的，不是从特定节点中选择
- 负载均衡 ：通过哈希取模的方式，不同消费者组的Coordinator会均匀分布在各个Broker上，实现负载均衡

### kafka 如何保证数据不丢？
- **Broker 端**：
  - 启用多副本复制（replication.factor >= 3）
  - 设置 ACK=all（producer 等待所有 ISR 副本确认）
  - 配置 min.insync.replicas >= 2（确保至少 2 个副本同步）
  - 禁用 unclean leader election（防止非 ISR 副本成为 leader）
  - 启用 Topic 和 Partition 的持久化
- **Producer 端**：
  - 启用重试机制（retries > 0, retry.backoff.ms 合理设置）
  - 启用幂等生产（enable.idempotence=true）防止重复发送
  - 启用事务（transactional.id）确保批量消息的原子性
- **Consumer 端**：
  - 手动提交 Offset（enable.auto.commit=false）
  - 处理完消息后再提交 Offset（避免处理失败但 Offset 已提交）
  - 实现幂等消费（防止重复处理）

### kafka 如何实现消息延迟
kafka 原生不支持消息延迟，需要业务端实现

## RocketMQ

### 存储结构

```
Broker节点存储结构
├── CommitLog
│   ├── 00000000000000000000：存储所有消息（顺序写入）
│   ├── 0000000000001073741824：下一个Segment开始位置
│   └── ...
├── ConsumeQueue（按Topic/Queue组织）
│   ├── TopicA
│   │   ├── 0：Queue0的消费队列索引
│   │   ├── 1：Queue1的消费队列索引
│   │   └── ...
│   ├── TopicB
│   │   ├── 0：Queue0的消费队列索引
│   │   ├── 1：Queue1的消费队列索引
│   │   └── ...
│   └── ...
└── IndexFile
    ├── 00000000000000000000：消息索引文件
    ├── 00000000000000000001
    └── ...
```